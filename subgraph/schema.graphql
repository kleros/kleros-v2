enum Period {
  evidence
  commit
  vote
  appeal
  execution
}

type Court @entity {
  id: ID!
  parent: Court
  hiddenVotes: Boolean!
  children: [Court!]! @derivedFrom(field: "parent")
  minStake: BigInt!
  alpha: BigInt!
  feeForJuror: BigInt!
  jurorsForCourtJump: BigInt!
  timesPerPeriod: [BigInt!]!
  supportedDisputeKits: [DisputeKit!]!
  disputes: [Dispute!]! @derivedFrom(field: "court")
  numberDisputes: BigInt!
  stakedJurors: [JurorTokensPerCourt!]! @derivedFrom(field: "court")
  numberStakedJurors: BigInt!
  stake: BigInt!
  paidETH: BigInt!
  paidPNK: BigInt!
  policy: String
}

type Dispute @entity {
  id: ID!
  court: Court!
  arbitrated: Bytes!
  period: Period!
  ruled: Boolean!
  lastPeriodChange: BigInt!
  rounds: [Round!]! @derivedFrom(field: "dispute")
  currentRound: Round!
  currentRoundIndex: BigInt!
  shifts: [TokenAndETHShift!]! @derivedFrom(field: "dispute")
  disputeKitDispute: DisputeKitDispute @derivedFrom(field: "coreDispute")
}

type Round @entity {
  id: ID! # Set to `${dispute.id}-${dispute.rounds.length}`
  disputeKit: DisputeKit!
  tokensAtStakePerJuror: BigInt!
  totalFeesForJurors: BigInt!
  nbVotes: BigInt!
  repartitions: BigInt!
  penalties: BigInt!
  drawnJurors: [Draw!]! @derivedFrom(field: "round")
  dispute: Dispute!
}

interface DisputeKitRound {
  id: ID! # Set to `${disputeKit.id}-{dispute.id}-{dispute.rounds.length}`
}

type ClassicRound implements DisputeKitRound @entity {
  id: ID! # Set to `${disputeKit.id}-{dispute.id}-{dispute.rounds.length}`
  votes: [ClassicVote!]!
  winningChoice: BigInt!
  counts: [BigInt!]!
  tied: Boolean!
  totalVoted: BigInt!
  totalCommited: BigInt!
  paidFees: [BigInt!]!
  contributions: [Contribution!]! @derivedFrom(field: "round")
  feeRewards: BigInt!
  nbVotes: BigInt!
}

type Contribution @entity {
  id: ID! # Set to `${dispute.id}-${round.id}-${contributor}-${choice}`
  contributor: Bytes!
  amount: BigInt!
  choice: BigInt!
  round: ClassicRound!
}

type ClassicVote @entity {
  id: ID!
}

interface DisputeKitDispute {
  id: ID! # Set to ${disputeKit.id}-{disputeKit.disputes.length}
  coreDispute: Dispute!
}

type ClassicDispute implements DisputeKitDispute @entity {
  id: ID! # Set to ${disputeKit.id}-{disputeKit.disputes.length}
  coreDispute: Dispute!

  numberOfChoices: BigInt!
  jumped: Boolean!
  extraData: Bytes!
}

type Juror @entity {
  id: ID! # Set to address
  tokens: [JurorTokensPerCourt!]! @derivedFrom(field: "juror")
  totalStake: BigInt!
  shifts: [TokenAndETHShift!]! @derivedFrom(field: "juror")
  draws: [Draw!]! @derivedFrom(field: "juror")
  votes: [Vote!]! @derivedFrom(field: "juror")
}

type TokenAndETHShift @entity {
  id: ID! # Set to `${juror.id}-${dispute.id}`
  juror: Juror!
  dispute: Dispute!
  tokenAmount: BigInt!
  ethAmount: BigInt!
}

type JurorTokensPerCourt @entity {
  id: ID! # Set to `${juror.id}-${court.id}`
  juror: Juror!
  court: Court!
  staked: BigInt!
  locked: BigInt!
}

type EvidenceGroup @entity {
  id: ID!
  evidences: [Evidence!]! @derivedFrom(field: "evidenceGroup")
  lastEvidenceID: BigInt!
}

type Evidence @entity {
  id: ID! # Set to `${evidenceGroupID}-${id}`
  evidence: String!
  evidenceGroup: EvidenceGroup!
  sender: Bytes!
}

type Vote @entity {
  id: ID! # Set to `${coreDisputeID}-${coreRoundID}-${jurorAddress}`
  dispute: Dispute!
  round: Round!
  juror: Juror!
  choice: BigInt
  justification: String
}

type Draw @entity {
  id: ID! # Set to `${dispute.id}-${currentRound}-${voteID}`
  dispute: Dispute!
  round: Round!
  juror: Juror!
  voteID: BigInt!
}

type DisputeKit @entity {
  id: ID!
  address: Bytes
  parent: DisputeKit
  children: [DisputeKit!]! @derivedFrom(field: "parent")
  needsFreezing: Boolean!
  depthLevel: BigInt!
  rounds: [Round!]! @derivedFrom(field: "disputeKit")
  courts: [Court!]! @derivedFrom(field: "supportedDisputeKits")
}

type GatewayDispute @entity {
  id: ID!
  homeDispute: Dispute!
  arbitrator: Bytes!
  disputeHash: Bytes!
  arbitrationCost: BigInt!
  relayer: Bytes!
}

type OutgoingBatch @entity {
  id: ID! # Set to messageHash
  size: BigInt!
  epoch: BigInt!
  batchMerkleRoot: String!
}

type Counter @entity {
  id: ID! # Will be the timestamp except for the counter which will be 0
  stakedPNK: BigInt!
  redistributedPNK: BigInt!
  paidETH: BigInt!
  activeJurors: BigInt!
  cases: BigInt!
  casesVoting: BigInt!
  casesRuled: BigInt!
}
