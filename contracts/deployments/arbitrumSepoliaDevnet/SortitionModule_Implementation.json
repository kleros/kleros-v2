{
  "address": "0xd15138319C9589d85aC94e8587a832df3895a48C",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DisputesWithoutJurorsAndMaxDrawingTimeNotPassed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FailedDelegateCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "InvalidImplementation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "KMustBeGreaterThanOne",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "KlerosCoreOnly",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MinStakingTimeNotPassed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoDelayedStakeToExecute",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoDisputesThatNeedJurors",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotDrawingPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotEligibleForWithdrawal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotInitializing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotStakingPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OwnerOnly",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RandomNumberNotReady",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TreeAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UUPSUnauthorizedCallContext",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "slot",
          "type": "bytes32"
        }
      ],
      "name": "UUPSUnsupportedProxiableUUID",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "version",
          "type": "uint64"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "LeftoverPNK",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "LeftoverPNKWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum ISortitionModule.Phase",
          "name": "_phase",
          "type": "uint8"
        }
      ],
      "name": "NewPhase",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "StakeDelayed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "StakeDelayedExecutionFailed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_relativeAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "_unlock",
          "type": "bool"
        }
      ],
      "name": "StakeLocked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_address",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_courtID",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_amountAllCourts",
          "type": "uint256"
        }
      ],
      "name": "StakeSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxDrawingTime",
          "type": "uint256"
        }
      ],
      "name": "changeMaxDrawingTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxStakePerJuror",
          "type": "uint256"
        }
      ],
      "name": "changeMaxStakePerJuror",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxTotalStaked",
          "type": "uint256"
        }
      ],
      "name": "changeMaxTotalStaked",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minStakingTime",
          "type": "uint256"
        }
      ],
      "name": "changeMinStakingTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "changeOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IRNG",
          "name": "_rng",
          "type": "address"
        }
      ],
      "name": "changeRandomNumberGenerator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "core",
      "outputs": [
        {
          "internalType": "contract KlerosCore",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "createDisputeHook",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "createTree",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delayedStakeReadIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delayedStakeWriteIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "delayedStakes",
      "outputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "stake",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "disputesWithoutJurors",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "_coreDisputeID",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_nonce",
          "type": "uint256"
        }
      ],
      "name": "draw",
      "outputs": [
        {
          "internalType": "address",
          "name": "drawnAddress",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "fromSubcourtID",
          "type": "uint96"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_iterations",
          "type": "uint256"
        }
      ],
      "name": "executeDelayedStakes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        }
      ],
      "name": "forcedUnstake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "forcedUnstakeAllCourts",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_juror",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        }
      ],
      "name": "getJurorBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalStakedPnk",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalLocked",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stakedInCourt",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "nbCourts",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_juror",
          "type": "address"
        }
      ],
      "name": "getJurorCourtIDs",
      "outputs": [
        {
          "internalType": "uint96[]",
          "name": "",
          "type": "uint96[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_juror",
          "type": "address"
        }
      ],
      "name": "getJurorLeftoverPNK",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "contract KlerosCore",
          "name": "_core",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_minStakingTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxDrawingTime",
          "type": "uint256"
        },
        {
          "internalType": "contract IRNG",
          "name": "_rng",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_maxStakePerJuror",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxTotalStaked",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_juror",
          "type": "address"
        }
      ],
      "name": "isJurorStaked",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "jurors",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "stakedPnk",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lockedPnk",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastPhaseChange",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_relativeAmount",
          "type": "uint256"
        }
      ],
      "name": "lockStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxDrawingTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxStakePerJuror",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxTotalStaked",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minStakingTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "passPhase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "phase",
      "outputs": [
        {
          "internalType": "enum ISortitionModule.Phase",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "postDrawHook",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "randomNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rng",
      "outputs": [
        {
          "internalType": "contract IRNG",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "_pnkDeposit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_pnkWithdrawal",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_newStake",
          "type": "uint256"
        }
      ],
      "name": "setStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "_penalty",
          "type": "uint256"
        }
      ],
      "name": "setStakePenalty",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "pnkBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newCourtStake",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "availablePenalty",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "_reward",
          "type": "uint256"
        }
      ],
      "name": "setStakeReward",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalStaked",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_relativeAmount",
          "type": "uint256"
        }
      ],
      "name": "unlockStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "_newStake",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_noDelay",
          "type": "bool"
        }
      ],
      "name": "validateStake",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "pnkDeposit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pnkWithdrawal",
          "type": "uint256"
        },
        {
          "internalType": "enum StakingResult",
          "name": "stakingResult",
          "type": "uint8"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "withdrawLeftoverPNK",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x5884d2e6ecb6d9a3c8c4a7caa096b51639c2cc8c1b35a075d27d8f8b76330c31",
  "receipt": {
    "to": null,
    "from": "0xf1C7c037891525E360C59f708739Ac09A7670c59",
    "contractAddress": "0xd15138319C9589d85aC94e8587a832df3895a48C",
    "transactionIndex": 3,
    "gasUsed": "2671982",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000080000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x62db7b5494f320fb58653bdccf1b49938c729b1c60a74f76f6083470d163f301",
    "transactionHash": "0x5884d2e6ecb6d9a3c8c4a7caa096b51639c2cc8c1b35a075d27d8f8b76330c31",
    "logs": [
      {
        "transactionIndex": 3,
        "blockNumber": 212135290,
        "transactionHash": "0x5884d2e6ecb6d9a3c8c4a7caa096b51639c2cc8c1b35a075d27d8f8b76330c31",
        "address": "0xd15138319C9589d85aC94e8587a832df3895a48C",
        "topics": [
          "0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2"
        ],
        "data": "0x000000000000000000000000000000000000000000000000ffffffffffffffff",
        "logIndex": 4,
        "blockHash": "0x62db7b5494f320fb58653bdccf1b49938c729b1c60a74f76f6083470d163f301"
      }
    ],
    "blockNumber": 212135290,
    "cumulativeGasUsed": "2866754",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7120e939c323b678aae40a88db815cc2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DisputesWithoutJurorsAndMaxDrawingTimeNotPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedDelegateCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KMustBeGreaterThanOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KlerosCoreOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinStakingTimeNotPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoDelayedStakeToExecute\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoDisputesThatNeedJurors\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotDrawingPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEligibleForWithdrawal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStakingPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RandomNumberNotReady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TreeAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"UUPSUnsupportedProxiableUUID\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LeftoverPNK\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LeftoverPNKWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum ISortitionModule.Phase\",\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"NewPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakeDelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakeDelayedExecutionFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_relativeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_unlock\",\"type\":\"bool\"}],\"name\":\"StakeLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_courtID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountAllCourts\",\"type\":\"uint256\"}],\"name\":\"StakeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDrawingTime\",\"type\":\"uint256\"}],\"name\":\"changeMaxDrawingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxStakePerJuror\",\"type\":\"uint256\"}],\"name\":\"changeMaxStakePerJuror\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTotalStaked\",\"type\":\"uint256\"}],\"name\":\"changeMaxTotalStaked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakingTime\",\"type\":\"uint256\"}],\"name\":\"changeMinStakingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRNG\",\"name\":\"_rng\",\"type\":\"address\"}],\"name\":\"changeRandomNumberGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"contract KlerosCore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createDisputeHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"createTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedStakeReadIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedStakeWriteIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedStakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputesWithoutJurors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_coreDisputeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"draw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"drawnAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"fromSubcourtID\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_iterations\",\"type\":\"uint256\"}],\"name\":\"executeDelayedStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"}],\"name\":\"forcedUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"forcedUnstakeAllCourts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_juror\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"}],\"name\":\"getJurorBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakedPnk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedInCourt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nbCourts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_juror\",\"type\":\"address\"}],\"name\":\"getJurorCourtIDs\",\"outputs\":[{\"internalType\":\"uint96[]\",\"name\":\"\",\"type\":\"uint96[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_juror\",\"type\":\"address\"}],\"name\":\"getJurorLeftoverPNK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract KlerosCore\",\"name\":\"_core\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minStakingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDrawingTime\",\"type\":\"uint256\"},{\"internalType\":\"contract IRNG\",\"name\":\"_rng\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxStakePerJuror\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTotalStaked\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_juror\",\"type\":\"address\"}],\"name\":\"isJurorStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"jurors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedPnk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedPnk\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPhaseChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_relativeAmount\",\"type\":\"uint256\"}],\"name\":\"lockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDrawingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakePerJuror\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"internalType\":\"enum ISortitionModule.Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"postDrawHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rng\",\"outputs\":[{\"internalType\":\"contract IRNG\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_pnkDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pnkWithdrawal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newStake\",\"type\":\"uint256\"}],\"name\":\"setStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"}],\"name\":\"setStakePenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pnkBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCourtStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availablePenalty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"setStakeReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_relativeAmount\",\"type\":\"uint256\"}],\"name\":\"unlockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_newStake\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_noDelay\",\"type\":\"bool\"}],\"name\":\"validateStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pnkDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pnkWithdrawal\",\"type\":\"uint256\"},{\"internalType\":\"enum StakingResult\",\"name\":\"stakingResult\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"withdrawLeftoverPNK\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AlreadyInitialized()\":[{\"details\":\"The contract is already initialized.\"}],\"NotInitializing()\":[{\"details\":\"The contract is not initializing.\"}]},\"events\":{\"Initialized(uint64)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"LeftoverPNK(address,uint256)\":{\"params\":{\"_account\":\"The account of the juror.\",\"_amount\":\"The amount of PNK available.\"}},\"LeftoverPNKWithdrawn(address,uint256)\":{\"params\":{\"_account\":\"The account of the juror withdrawing PNK.\",\"_amount\":\"The amount of PNK withdrawn.\"}},\"NewPhase(uint8)\":{\"params\":{\"_phase\":\"The new phase.\"}},\"StakeDelayed(address,uint96,uint256)\":{\"params\":{\"_address\":\"The address of the juror.\",\"_amount\":\"The amount of tokens staked in the court.\",\"_courtID\":\"The ID of the court.\"}},\"StakeDelayedExecutionFailed(address,uint96,uint256)\":{\"params\":{\"_address\":\"The address of the juror.\",\"_amount\":\"The amount of tokens staked in the court.\",\"_courtID\":\"The ID of the court.\"}},\"StakeLocked(address,uint256,bool)\":{\"params\":{\"_address\":\"The address of the juror.\",\"_relativeAmount\":\"The amount of tokens locked.\",\"_unlock\":\"Whether the stake is locked or unlocked.\"}},\"StakeSet(address,uint256,uint256,uint256)\":{\"params\":{\"_address\":\"The address of the juror.\",\"_amount\":\"The amount of tokens staked in the court.\",\"_amountAllCourts\":\"The amount of tokens staked in all courts.\",\"_courtID\":\"The ID of the court.\"}},\"Upgraded(address)\":{\"params\":{\"newImplementation\":\"Address of the new implementation the proxy is now forwarding calls to.\"}}},\"kind\":\"dev\",\"methods\":{\"changeMaxDrawingTime(uint256)\":{\"params\":{\"_maxDrawingTime\":\"The new value for the `maxDrawingTime` storage variable.\"}},\"changeMaxStakePerJuror(uint256)\":{\"params\":{\"_maxStakePerJuror\":\"The new `maxStakePerJuror` storage variable.\"}},\"changeMaxTotalStaked(uint256)\":{\"params\":{\"_maxTotalStaked\":\"The new `maxTotalStaked` storage variable.\"}},\"changeMinStakingTime(uint256)\":{\"params\":{\"_minStakingTime\":\"The new value for the `minStakingTime` storage variable.\"}},\"changeOwner(address)\":{\"params\":{\"_owner\":\"The new owner.\"}},\"changeRandomNumberGenerator(address)\":{\"params\":{\"_rng\":\"The new random number generator.\"}},\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\"},\"createDisputeHook(uint256,uint256)\":{\"params\":{\"_disputeID\":\"The ID of the dispute.\",\"_roundID\":\"The ID of the round.\"}},\"createTree(uint96,bytes)\":{\"params\":{\"_courtID\":\"The ID of the court.\",\"_extraData\":\"Extra data that contains the number of children each node in the tree should have.\"}},\"draw(uint96,uint256,uint256)\":{\"details\":\"that this function reverts if the sum of all values in the tree is 0. `O(k * log_k(n))` where `k` is the maximum number of children per node in the tree,  and `n` is the maximum number of nodes ever appended.\",\"params\":{\"_coreDisputeID\":\"Index of the dispute in Kleros Core.\",\"_courtID\":\"The ID of the court.\",\"_nonce\":\"Nonce to hash with random number.\"},\"returns\":{\"drawnAddress\":\"The drawn address.\"}},\"executeDelayedStakes(uint256)\":{\"params\":{\"_iterations\":\"The number of delayed stakes to execute.\"}},\"forcedUnstake(address,uint96)\":{\"details\":\"`O(n * (p * log_k(j)) )` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\",\"params\":{\"_account\":\"The juror to unstake.\",\"_courtID\":\"The ID of the court.\"}},\"forcedUnstakeAllCourts(address)\":{\"details\":\"`O(n * (p * log_k(j)) )` where `O(n * (p * log_k(j)) )` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\",\"params\":{\"_account\":\"The juror to unstake.\"}},\"getJurorBalance(address,uint96)\":{\"params\":{\"_courtID\":\"The ID of the court.\",\"_juror\":\"The address of the juror.\"},\"returns\":{\"nbCourts\":\"The number of courts the juror has directly staked in.\",\"stakedInCourt\":\"The amount of tokens staked in the specified court including locked tokens and penalty deductions.\",\"totalLocked\":\"The total amount of tokens locked in disputes.\",\"totalStakedPnk\":\"The total amount of tokens staked including locked tokens and penalty deductions. Equivalent to the effective stake in the General court.\"}},\"getJurorCourtIDs(address)\":{\"params\":{\"_juror\":\"The address of the juror.\"}},\"getJurorLeftoverPNK(address)\":{\"params\":{\"_juror\":\"The address of the juror.\"},\"returns\":{\"_0\":\"Whether the juror has leftover PNK.\"}},\"initialize(address,address,uint256,uint256,address,uint256,uint256)\":{\"params\":{\"_core\":\"The KlerosCore.\",\"_maxDrawingTime\":\"Time after which the drawing phase can be switched\",\"_maxStakePerJuror\":\"The maximum amount of PNK a juror can stake across the courts.\",\"_maxTotalStaked\":\"The maximum amount of PNK that all the jurors can stake across the courts.\",\"_minStakingTime\":\"Minimal time to stake\",\"_owner\":\"The owner.\",\"_rng\":\"The random number generator.\"}},\"isJurorStaked(address)\":{\"params\":{\"_juror\":\"The address of the juror.\"},\"returns\":{\"_0\":\"Whether the juror is staked or not.\"}},\"lockStake(address,uint256)\":{\"params\":{\"_account\":\"The address of the juror.\",\"_relativeAmount\":\"The amount to lock.\"}},\"postDrawHook(uint256,uint256)\":{\"params\":{\"_disputeID\":\"The ID of the dispute.\",\"_roundID\":\"The ID of the round.\"}},\"proxiableUUID()\":{\"details\":\"IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the if statement.\"},\"setStake(address,uint96,uint256,uint256,uint256)\":{\"details\":\"`O(n + p * log_k(j))` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\",\"params\":{\"_account\":\"The address of the juror.\",\"_courtID\":\"The ID of the court.\",\"_newStake\":\"The new stake.\",\"_pnkDeposit\":\"The amount of PNK to be deposited.\",\"_pnkWithdrawal\":\"The amount of PNK to be withdrawn.\"}},\"setStakePenalty(address,uint96,uint256)\":{\"details\":\"`O(n + p * log_k(j))` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\",\"params\":{\"_account\":\"The address of the juror.\",\"_courtID\":\"The ID of the court.\",\"_penalty\":\"The amount of PNK to be deducted.\"},\"returns\":{\"availablePenalty\":\"The amount of PNK that was actually deducted.\",\"newCourtStake\":\"The updated stake of the juror in the court.\",\"pnkBalance\":\"The updated total PNK balance of the juror, including the penalty.\"}},\"setStakeReward(address,uint96,uint256)\":{\"details\":\"`O(n + p * log_k(j))` where `O(n + p * log_k(j))` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\",\"params\":{\"_account\":\"The address of the juror.\",\"_courtID\":\"The ID of the court.\",\"_reward\":\"The amount of PNK to be deposited as a reward.\"},\"returns\":{\"success\":\"True if the reward was added successfully.\"}},\"unlockStake(address,uint256)\":{\"params\":{\"_account\":\"The address of the juror.\",\"_relativeAmount\":\"The amount to unlock.\"}},\"upgradeToAndCall(address,bytes)\":{\"details\":\"Reverts if the execution is not performed via delegatecall or the execution context is not of a proxy with an ERC1967-compliant implementation pointing to self.\",\"params\":{\"data\":\"Data used in a delegate call to `newImplementation` if non-empty. This will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\",\"newImplementation\":\"Address of the new implementation contract.\"}},\"validateStake(address,uint96,uint256,bool)\":{\"details\":\"No state changes should be made when returning stakingResult != Successful, otherwise delayed stakes might break invariants.\",\"params\":{\"_account\":\"The address of the juror.\",\"_courtID\":\"The ID of the court.\",\"_newStake\":\"The new stake.\",\"_noDelay\":\"True if the stake change should not be delayed.\"},\"returns\":{\"pnkDeposit\":\"The amount of PNK to be deposited.\",\"pnkWithdrawal\":\"The amount of PNK to be withdrawn.\",\"stakingResult\":\"The result of the staking operation.\"}},\"withdrawLeftoverPNK(address)\":{\"details\":\"that since locked and staked PNK are async it is possible for the juror to have positive staked PNK balance while having 0 stake in courts and 0 locked tokens (eg. when the juror fully unstaked during dispute and later got his tokens unlocked). In this case the juror can use this function to withdraw the leftover tokens. Also note that if the juror has some leftover PNK while not fully unstaked he'll have to manually unstake from all courts to trigger this function.\",\"params\":{\"_account\":\"The juror whose PNK to withdraw.\"}}},\"stateVariables\":{\"version\":{\"return\":\"Version string.\",\"returns\":{\"_0\":\"Version string.\"}}},\"title\":\"SortitionModule\",\"version\":1},\"userdoc\":{\"errors\":{\"FailedDelegateCall()\":[{\"notice\":\"Failed Delegated call\"}],\"InvalidImplementation(address)\":[{\"notice\":\"The `implementation` is not UUPS-compliant\"}],\"UUPSUnauthorizedCallContext()\":[{\"notice\":\"The call is from an unauthorized context.\"}],\"UUPSUnsupportedProxiableUUID(bytes32)\":[{\"notice\":\"The storage `slot` is unsupported as a UUID.\"}]},\"events\":{\"LeftoverPNK(address,uint256)\":{\"notice\":\"Emitted when leftover PNK is available.\"},\"LeftoverPNKWithdrawn(address,uint256)\":{\"notice\":\"Emitted when leftover PNK is withdrawn.\"},\"NewPhase(uint8)\":{\"notice\":\"Emitted when the phase is changed.\"},\"StakeDelayed(address,uint96,uint256)\":{\"notice\":\"Emitted when a juror's stake is delayed.\"},\"StakeDelayedExecutionFailed(address,uint96,uint256)\":{\"notice\":\"Emitted when a juror's stake is delayed execution fails.\"},\"StakeLocked(address,uint256,bool)\":{\"notice\":\"Emitted when a juror's stake is locked.\"},\"StakeSet(address,uint256,uint256,uint256)\":{\"notice\":\"Emitted when a juror stakes in a court.\"},\"Upgraded(address)\":{\"notice\":\"Emitted when the `implementation` has been successfully upgraded.\"}},\"kind\":\"user\",\"methods\":{\"changeMaxDrawingTime(uint256)\":{\"notice\":\"Changes the `maxDrawingTime` storage variable.\"},\"changeMaxStakePerJuror(uint256)\":{\"notice\":\"Changes the `maxStakePerJuror` storage variable.\"},\"changeMaxTotalStaked(uint256)\":{\"notice\":\"Changes the `maxTotalStaked` storage variable.\"},\"changeMinStakingTime(uint256)\":{\"notice\":\"Changes the `minStakingTime` storage variable.\"},\"changeOwner(address)\":{\"notice\":\"Changes the owner of the contract.\"},\"changeRandomNumberGenerator(address)\":{\"notice\":\"Changes the `rng` storage variable.\"},\"createDisputeHook(uint256,uint256)\":{\"notice\":\"Triggers the state changes after dispute creation.\"},\"createTree(uint96,bytes)\":{\"notice\":\"Create a sortition sum tree at the specified key.\"},\"draw(uint96,uint256,uint256)\":{\"notice\":\"Draw an ID from a tree using a number.\"},\"executeDelayedStakes(uint256)\":{\"notice\":\"Executes the next delayed stakes.\"},\"forcedUnstake(address,uint96)\":{\"notice\":\"Unstakes the inactive juror from a specific court.\"},\"forcedUnstakeAllCourts(address)\":{\"notice\":\"Unstakes the inactive juror from all courts.\"},\"getJurorBalance(address,uint96)\":{\"notice\":\"Gets the balance of a juror in a court.\"},\"getJurorCourtIDs(address)\":{\"notice\":\"Gets the court identifiers where a specific `_juror` has staked.\"},\"getJurorLeftoverPNK(address)\":{\"notice\":\"Checks if the juror has any leftover PNK in the contract.\"},\"initialize(address,address,uint256,uint256,address,uint256,uint256)\":{\"notice\":\"Initializer (constructor equivalent for upgradable contracts).\"},\"isJurorStaked(address)\":{\"notice\":\"Checks if the juror is staked in any court.\"},\"lockStake(address,uint256)\":{\"notice\":\"Locks the tokens of the drawn juror.\"},\"passPhase()\":{\"notice\":\"Passes the phase.\"},\"postDrawHook(uint256,uint256)\":{\"notice\":\"Triggers the state changes after drawing.\"},\"proxiableUUID()\":{\"notice\":\"Implementation of the ERC1822 `proxiableUUID` function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade.\"},\"setStake(address,uint96,uint256,uint256,uint256)\":{\"notice\":\"Update the state of the stakes, called by KC at the end of setStake flow.\"},\"setStakePenalty(address,uint96,uint256)\":{\"notice\":\"Update the state of the stakes with a PNK penalty, called by KC during rewards execution.\"},\"setStakeReward(address,uint96,uint256)\":{\"notice\":\"Update the state of the stakes with a PNK reward deposit, called by KC during rewards execution.\"},\"unlockStake(address,uint256)\":{\"notice\":\"Unlocks the tokens of the drawn juror.\"},\"upgradeToAndCall(address,bytes)\":{\"notice\":\"Upgrade mechanism including access control and UUPS-compliance.\"},\"validateStake(address,uint96,uint256,bool)\":{\"notice\":\"Validate the specified juror's new stake for a court.\"},\"version()\":{\"notice\":\"Returns the version of the implementation.\"},\"withdrawLeftoverPNK(address)\":{\"notice\":\"Gives back the locked PNKs in case the juror fully unstaked earlier.\"}},\"notice\":\"A factory of trees that keeps track of staked values for sortition.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/arbitration/SortitionModule.sol\":\"SortitionModule\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":850},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0x74ed01eb66b923d0d0cfe3be84604ac04b76482a55f9dd655e1ef4d367f95bc2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf78f05f3b8c9f75570e85300d7b4600d7f6f6a198449273f31d44c1641adb46f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x8891738ffe910f0cf2da09566928589bf5d63f4524dd734fd9cedbac3274dd5c\",\"license\":\"MIT\"},\"src/arbitration/KlerosCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\nimport {IArbitrableV2} from \\\"./interfaces/IArbitrableV2.sol\\\";\\nimport {IArbitratorV2} from \\\"./interfaces/IArbitratorV2.sol\\\";\\nimport {IDisputeKit} from \\\"./interfaces/IDisputeKit.sol\\\";\\nimport {ISortitionModule} from \\\"./interfaces/ISortitionModule.sol\\\";\\nimport {Initializable} from \\\"../proxy/Initializable.sol\\\";\\nimport {UUPSProxiable} from \\\"../proxy/UUPSProxiable.sol\\\";\\nimport {SafeERC20} from \\\"../libraries/SafeERC20.sol\\\";\\nimport {SafeSend} from \\\"../libraries/SafeSend.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"../libraries/Constants.sol\\\";\\n\\n/// @title KlerosCore\\n/// @notice Core arbitrator contract for Kleros v2.\\n/// @dev This contract trusts the PNK token, the dispute kits and the sortition module contracts.\\ncontract KlerosCore is IArbitratorV2, Initializable, UUPSProxiable {\\n    using SafeERC20 for IERC20;\\n    using SafeSend for address payable;\\n\\n    string public constant override version = \\\"2.0.0\\\";\\n\\n    // ************************************* //\\n    // *         Enums / Structs           * //\\n    // ************************************* //\\n\\n    enum Period {\\n        evidence, // Evidence can be submitted. This is also when drawing has to take place.\\n        commit, // Jurors commit a hashed vote. This is skipped for courts without hidden votes.\\n        vote, // Jurors reveal/cast their vote depending on whether the court has hidden votes or not.\\n        appeal, // The dispute can be appealed.\\n        execution // Tokens are redistributed and the ruling is executed.\\n    }\\n\\n    struct Court {\\n        uint96 parent; // The parent court.\\n        bool hiddenVotes; // Whether to use commit and reveal or not.\\n        uint256[] children; // List of child courts.\\n        uint256 minStake; // Minimum PNKs needed to stake in the court.\\n        uint256 alpha; // Basis point of PNKs that are lost when incoherent.\\n        uint256 feeForJuror; // Arbitration fee paid per juror.\\n        uint256 jurorsForCourtJump; // The appeal after the one that reaches this number of jurors will go to the parent court if any.\\n        uint256[4] timesPerPeriod; // The time allotted to each dispute period in the form `timesPerPeriod[period]`.\\n        mapping(uint256 disputeKitId => bool) supportedDisputeKits; // True if DK with this ID is supported by the court. Note that each court must support classic dispute kit.\\n        uint256[10] __gap; // Reserved slots for future upgrades.\\n    }\\n\\n    struct Dispute {\\n        uint96 courtID; // The ID of the court the dispute is in.\\n        IArbitrableV2 arbitrated; // The arbitrable contract.\\n        Period period; // The current period of the dispute.\\n        bool ruled; // True if the ruling has been executed, false otherwise.\\n        uint256 lastPeriodChange; // The last time the period was changed.\\n        Round[] rounds; // Rounds of the dispute.\\n        uint256[10] __gap; // Reserved slots for future upgrades.\\n    }\\n\\n    struct Round {\\n        uint256 disputeKitID; // Index of the dispute kit in the array.\\n        uint256 pnkAtStakePerJuror; // The amount of PNKs at stake for each juror in this round.\\n        uint256 totalFeesForJurors; // The total juror fees paid in this round.\\n        uint256 nbVotes; // The total number of votes the dispute can possibly have in the current round. Former votes[_round].length.\\n        uint256 repartitions; // A counter of reward repartitions made in this round.\\n        uint256 pnkPenalties; // The amount of PNKs collected from penalties in this round.\\n        address[] drawnJurors; // Addresses of the jurors that were drawn in this round.\\n        uint96[] drawnJurorFromCourtIDs; // The courtIDs where the juror was drawn from, possibly their stake in a subcourt.\\n        uint256 sumFeeRewardPaid; // Total sum of arbitration fees paid to coherent jurors as a reward in this round.\\n        uint256 sumPnkRewardPaid; // Total sum of PNK paid to coherent jurors as a reward in this round.\\n        IERC20 feeToken; // The token used for paying fees in this round.\\n        uint256 drawIterations; // The number of iterations passed drawing the jurors for this round.\\n        uint256[10] __gap; // Reserved slots for future upgrades.\\n    }\\n\\n    // Workaround \\\"stack too deep\\\" errors\\n    struct ExecuteParams {\\n        uint256 disputeID; // The ID of the dispute to execute.\\n        uint256 round; // The round to execute.\\n        uint256 coherentCount; // The number of coherent votes in the round.\\n        uint256 numberOfVotesInRound; // The number of votes in the round.\\n        uint256 feePerJurorInRound; // The fee per juror in the round.\\n        uint256 pnkAtStakePerJurorInRound; // The amount of PNKs at stake for each juror in the round.\\n        uint256 pnkPenaltiesInRound; // The amount of PNKs collected from penalties in the round.\\n        uint256 repartition; // The index of the repartition to execute.\\n    }\\n\\n    struct CurrencyRate {\\n        bool feePaymentAccepted; // True if this token is supported as payment method.\\n        uint64 rateInEth; // Rate of the fee token in ETH.\\n        uint8 rateDecimals; // Decimals of the fee token rate.\\n    }\\n\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    uint256 private constant NON_PAYABLE_AMOUNT = (2 ** 256 - 2) / 2; // An amount higher than the supply of ETH.\\n\\n    address public owner; // The owner of the contract.\\n    address public guardian; // The guardian able to pause asset withdrawals.\\n    IERC20 public pinakion; // The Pinakion token contract.\\n    address public jurorProsecutionModule; // The module for juror's prosecution.\\n    ISortitionModule public sortitionModule; // Sortition module for drawing.\\n    Court[] public courts; // The courts.\\n    IDisputeKit[] public disputeKits; // Array of dispute kits.\\n    Dispute[] public disputes; // The disputes.\\n    mapping(IERC20 => CurrencyRate) public currencyRates; // The price of each token in ETH.\\n    bool public paused; // Whether asset withdrawals are paused.\\n    address public wNative; // The wrapped native token for safeSend().\\n    mapping(address => bool) public arbitrableWhitelist; // Arbitrable whitelist.\\n    bool public arbitrableWhitelistEnabled; // Whether the arbitrable whitelist is enabled.\\n    IERC721 public jurorNft; // Eligible jurors NFT.\\n\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /// @notice Emitted when period is passed.\\n    /// @param _disputeID ID of the related dispute.\\n    /// @param _period The new period.\\n    event NewPeriod(uint256 indexed _disputeID, Period _period);\\n\\n    /// @notice Emitted when appeal period starts.\\n    /// @param _disputeID ID of the related dispute.\\n    /// @param _arbitrable The arbitrable contract.\\n    event AppealPossible(uint256 indexed _disputeID, IArbitrableV2 indexed _arbitrable);\\n\\n    /// @notice Emitted when the dispute is successfully appealed.\\n    /// @param _disputeID ID of the related dispute.\\n    /// @param _arbitrable The arbitrable contract.\\n    event AppealDecision(uint256 indexed _disputeID, IArbitrableV2 indexed _arbitrable);\\n\\n    /// @notice Emitted when an address is successfully drawn.\\n    /// @param _address The drawn address.\\n    /// @param _disputeID ID of the related dispute.\\n    /// @param _roundID ID of the related round.\\n    /// @param _voteID ID of the vote given to the drawn juror.\\n    event Draw(address indexed _address, uint256 indexed _disputeID, uint256 _roundID, uint256 _voteID);\\n\\n    /// @notice Emitted when a new court is created.\\n    /// @param _courtID ID of the new court.\\n    /// @param _parent ID of the parent court.\\n    /// @param _hiddenVotes Whether the court has hidden votes or not.\\n    /// @param _minStake The `minStake` property value of the court.\\n    /// @param _alpha The `alpha` property value of the court.\\n    /// @param _feeForJuror The `feeForJuror` property value of the court.\\n    /// @param _jurorsForCourtJump The `jurorsForCourtJump` property value of the court.\\n    /// @param _timesPerPeriod The `timesPerPeriod` property value of the court.\\n    /// @param _supportedDisputeKits Indexes of dispute kits that this court will support.\\n    event CourtCreated(\\n        uint96 indexed _courtID,\\n        uint96 indexed _parent,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] _timesPerPeriod,\\n        uint256[] _supportedDisputeKits\\n    );\\n\\n    /// @notice Emitted when court's parameters are changed.\\n    /// @param _courtID ID of the court.\\n    /// @param _hiddenVotes Whether the court has hidden votes or not.\\n    /// @param _minStake The `minStake` property value of the court.\\n    /// @param _alpha The `alpha` property value of the court.\\n    /// @param _feeForJuror The `feeForJuror` property value of the court.\\n    /// @param _jurorsForCourtJump The `jurorsForCourtJump` property value of the court.\\n    /// @param _timesPerPeriod The `timesPerPeriod` property value of the court.\\n    event CourtModified(\\n        uint96 indexed _courtID,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] _timesPerPeriod\\n    );\\n\\n    /// @notice Emitted when a dispute kit is created.\\n    /// @param _disputeKitID ID of the new dispute kit.\\n    /// @param _disputeKitAddress Address of the new dispute kit.\\n    event DisputeKitCreated(uint256 indexed _disputeKitID, IDisputeKit indexed _disputeKitAddress);\\n\\n    /// @notice Emitted when a dispute kit is enabled/disabled in a court.\\n    /// @param _courtID ID of the related court.\\n    /// @param _disputeKitID ID of the dispute kit.\\n    /// @param _enable Whether the dispute kit has been enabled or disabled.\\n    event DisputeKitEnabled(uint96 indexed _courtID, uint256 indexed _disputeKitID, bool indexed _enable);\\n\\n    /// @notice Emitted when a dispute jumps to a new court.\\n    /// @param _disputeID ID of the dispute.\\n    /// @param _roundID ID of the round.\\n    /// @param _fromCourtID ID of the previous court.\\n    /// @param _toCourtID ID of the new court.\\n    event CourtJump(\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint96 indexed _fromCourtID,\\n        uint96 _toCourtID\\n    );\\n\\n    /// @notice Emitted when a dispute jumps to a new dispute kit.\\n    /// @param _disputeID ID of the dispute.\\n    /// @param _roundID ID of the round.\\n    /// @param _fromDisputeKitID ID of the previous dispute kit.\\n    /// @param _toDisputeKitID ID of the new dispute kit.\\n    event DisputeKitJump(\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint256 indexed _fromDisputeKitID,\\n        uint256 _toDisputeKitID\\n    );\\n\\n    /// @notice Emitted when juror's balance shifts after penalties/rewards has been processed.\\n    /// @param _account Juror's address.\\n    /// @param _disputeID ID of the dispute.\\n    /// @param _roundID ID of the round.\\n    /// @param _degreeOfCoherencyPnk Juror's degree of coherency in this round applied to PNK.\\n    /// @param _degreeOfCoherencyFee Juror's degree of coherency in this round applied to the dispute fee.\\n    /// @param _amountPnk Amount of PNK shifted.\\n    /// @param _amountFee Amount of fee shifted.\\n    /// @param _feeToken Address of the fee token.\\n    event JurorRewardPenalty(\\n        address indexed _account,\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint256 _degreeOfCoherencyPnk,\\n        uint256 _degreeOfCoherencyFee,\\n        int256 _amountPnk,\\n        int256 _amountFee,\\n        IERC20 _feeToken\\n    );\\n\\n    /// @notice Emitted when leftover reward sent to owner.\\n    /// @param _disputeID ID of the dispute.\\n    /// @param _roundID ID of the round.\\n    /// @param _amountPnk Amount of PNK sent.\\n    /// @param _amountFee Amount of fee sent.\\n    /// @param _feeToken Address of the fee token.\\n    event LeftoverRewardSent(\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint256 _amountPnk,\\n        uint256 _amountFee,\\n        IERC20 _feeToken\\n    );\\n\\n    /// @notice Emitted when this contract is paused.\\n    event Paused();\\n\\n    /// @notice Emitted when this contract is unpaused.\\n    event Unpaused();\\n\\n    // ************************************* //\\n    // *        Function Modifiers         * //\\n    // ************************************* //\\n\\n    modifier onlyByOwner() {\\n        if (owner != msg.sender) revert OwnerOnly();\\n        _;\\n    }\\n\\n    modifier onlyByGuardianOrOwner() {\\n        if (guardian != msg.sender && owner != msg.sender) revert GuardianOrOwnerOnly();\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        if (!paused) revert WhenPausedOnly();\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        if (paused) revert WhenNotPausedOnly();\\n        _;\\n    }\\n\\n    // ************************************* //\\n    // *            Constructor            * //\\n    // ************************************* //\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializer (constructor equivalent for upgradable contracts).\\n    /// @param _owner The owner's address.\\n    /// @param _guardian The guardian's address.\\n    /// @param _pinakion The address of the token contract.\\n    /// @param _jurorProsecutionModule The address of the juror prosecution module.\\n    /// @param _disputeKit The address of the default dispute kit.\\n    /// @param _hiddenVotes The `hiddenVotes` property value of the general court.\\n    /// @param _courtParameters Numeric parameters of General court (minStake, alpha, feeForJuror and jurorsForCourtJump respectively).\\n    /// @param _timesPerPeriod The `timesPerPeriod` property value of the general court.\\n    /// @param _sortitionExtraData The extra data for sortition module.\\n    /// @param _sortitionModuleAddress The sortition module responsible for sortition of the jurors.\\n    /// @param _wNative The wrapped native token address, typically wETH.\\n    /// @param _jurorNft NFT contract to vet the jurors.\\n    function initialize(\\n        address _owner,\\n        address _guardian,\\n        IERC20 _pinakion,\\n        address _jurorProsecutionModule,\\n        IDisputeKit _disputeKit,\\n        bool _hiddenVotes,\\n        uint256[4] memory _courtParameters,\\n        uint256[4] memory _timesPerPeriod,\\n        bytes memory _sortitionExtraData,\\n        ISortitionModule _sortitionModuleAddress,\\n        address _wNative,\\n        IERC721 _jurorNft\\n    ) external initializer {\\n        owner = _owner;\\n        guardian = _guardian;\\n        pinakion = _pinakion;\\n        jurorProsecutionModule = _jurorProsecutionModule;\\n        sortitionModule = _sortitionModuleAddress;\\n        wNative = _wNative;\\n        jurorNft = _jurorNft;\\n\\n        // NULL_DISPUTE_KIT: an empty element at index 0 to indicate when a dispute kit is not supported.\\n        disputeKits.push();\\n\\n        // DISPUTE_KIT_CLASSIC\\n        disputeKits.push(_disputeKit);\\n\\n        emit DisputeKitCreated(DISPUTE_KIT_CLASSIC, _disputeKit);\\n\\n        // FORKING_COURT\\n        // TODO: Fill the properties for the Forking court, emit CourtCreated.\\n        courts.push();\\n        sortitionModule.createTree(FORKING_COURT, _sortitionExtraData);\\n\\n        // GENERAL_COURT\\n        Court storage court = courts.push();\\n        court.parent = FORKING_COURT;\\n        court.children = new uint256[](0);\\n        court.hiddenVotes = _hiddenVotes;\\n        court.minStake = _courtParameters[0];\\n        court.alpha = _courtParameters[1];\\n        court.feeForJuror = _courtParameters[2];\\n        court.jurorsForCourtJump = _courtParameters[3];\\n        court.timesPerPeriod = _timesPerPeriod;\\n\\n        sortitionModule.createTree(GENERAL_COURT, _sortitionExtraData);\\n\\n        uint256[] memory supportedDisputeKits = new uint256[](1);\\n        supportedDisputeKits[0] = DISPUTE_KIT_CLASSIC;\\n        emit CourtCreated(\\n            GENERAL_COURT,\\n            court.parent,\\n            _hiddenVotes,\\n            _courtParameters[0],\\n            _courtParameters[1],\\n            _courtParameters[2],\\n            _courtParameters[3],\\n            _timesPerPeriod,\\n            supportedDisputeKits\\n        );\\n        _enableDisputeKit(GENERAL_COURT, DISPUTE_KIT_CLASSIC, true);\\n    }\\n\\n    // ************************************* //\\n    // *             Governance            * //\\n    // ************************************* //\\n\\n    /// @dev Access Control to perform implementation upgrades (UUPS Proxiable)\\n    ///      Only the owner can perform upgrades (`onlyByOwner`)\\n    function _authorizeUpgrade(address) internal view override onlyByOwner {\\n        // NOP\\n    }\\n\\n    /// @notice Pause staking and reward execution. Can only be done by guardian or owner.\\n    function pause() external onlyByGuardianOrOwner whenNotPaused {\\n        paused = true;\\n        emit Paused();\\n    }\\n\\n    /// @notice Unpause staking and reward execution. Can only be done by owner.\\n    function unpause() external onlyByOwner whenPaused {\\n        paused = false;\\n        emit Unpaused();\\n    }\\n\\n    /// @notice Allows the owner to call anything on behalf of the contract.\\n    /// @param _destination The destination of the call.\\n    /// @param _amount The value sent with the call.\\n    /// @param _data The data sent with the call.\\n    function executeOwnerProposal(address _destination, uint256 _amount, bytes memory _data) external onlyByOwner {\\n        (bool success, ) = _destination.call{value: _amount}(_data);\\n        if (!success) revert UnsuccessfulCall();\\n    }\\n\\n    /// @notice Changes the `owner` storage variable.\\n    /// @param _owner The new value for the `owner` storage variable.\\n    function changeOwner(address payable _owner) external onlyByOwner {\\n        owner = _owner;\\n    }\\n\\n    /// @notice Changes the `guardian` storage variable.\\n    /// @param _guardian The new value for the `guardian` storage variable.\\n    function changeGuardian(address _guardian) external onlyByOwner {\\n        guardian = _guardian;\\n    }\\n\\n    /// @notice Changes the `pinakion` storage variable.\\n    /// @param _pinakion The new value for the `pinakion` storage variable.\\n    function changePinakion(IERC20 _pinakion) external onlyByOwner {\\n        pinakion = _pinakion;\\n    }\\n\\n    /// @notice Changes the `jurorProsecutionModule` storage variable.\\n    /// @param _jurorProsecutionModule The new value for the `jurorProsecutionModule` storage variable.\\n    function changeJurorProsecutionModule(address _jurorProsecutionModule) external onlyByOwner {\\n        jurorProsecutionModule = _jurorProsecutionModule;\\n    }\\n\\n    /// @notice Changes the `_sortitionModule` storage variable.\\n    /// Note that the new module should be initialized for all courts.\\n    /// @param _sortitionModule The new value for the `sortitionModule` storage variable.\\n    function changeSortitionModule(ISortitionModule _sortitionModule) external onlyByOwner {\\n        sortitionModule = _sortitionModule;\\n    }\\n\\n    /// @notice Add a new supported dispute kit, without enabling it.\\n    /// Use `enableDisputeKits()` to enable the dispute kit for a specific court.\\n    /// @param _disputeKitAddress The address of the dispute kit contract.\\n    function addNewDisputeKit(IDisputeKit _disputeKitAddress) external onlyByOwner {\\n        uint256 disputeKitID = disputeKits.length;\\n        disputeKits.push(_disputeKitAddress);\\n        emit DisputeKitCreated(disputeKitID, _disputeKitAddress);\\n    }\\n\\n    /// @notice Creates a court under a specified parent court.\\n    /// @param _parent The `parent` property value of the court.\\n    /// @param _hiddenVotes The `hiddenVotes` property value of the court.\\n    /// @param _minStake The `minStake` property value of the court.\\n    /// @param _alpha The `alpha` property value of the court.\\n    /// @param _feeForJuror The `feeForJuror` property value of the court.\\n    /// @param _jurorsForCourtJump The `jurorsForCourtJump` property value of the court.\\n    /// @param _timesPerPeriod The `timesPerPeriod` property value of the court.\\n    /// @param _sortitionExtraData Extra data for sortition module.\\n    /// @param _supportedDisputeKits Indexes of dispute kits that this court will support.\\n    function createCourt(\\n        uint96 _parent,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] memory _timesPerPeriod,\\n        bytes memory _sortitionExtraData,\\n        uint256[] memory _supportedDisputeKits\\n    ) external onlyByOwner {\\n        if (courts[_parent].minStake > _minStake) revert MinStakeLowerThanParentCourt();\\n        if (_supportedDisputeKits.length == 0) revert UnsupportedDisputeKit();\\n        if (_parent == FORKING_COURT) revert InvalidForkingCourtAsParent();\\n\\n        uint96 courtID = uint96(courts.length);\\n        Court storage court = courts.push();\\n\\n        for (uint256 i = 0; i < _supportedDisputeKits.length; i++) {\\n            if (_supportedDisputeKits[i] == NULL_DISPUTE_KIT || _supportedDisputeKits[i] >= disputeKits.length) {\\n                revert WrongDisputeKitIndex();\\n            }\\n            _enableDisputeKit(uint96(courtID), _supportedDisputeKits[i], true);\\n        }\\n        // Check that Classic DK support was added.\\n        if (!court.supportedDisputeKits[DISPUTE_KIT_CLASSIC]) revert MustSupportDisputeKitClassic();\\n\\n        court.parent = _parent;\\n        court.children = new uint256[](0);\\n        court.hiddenVotes = _hiddenVotes;\\n        court.minStake = _minStake;\\n        court.alpha = _alpha;\\n        court.feeForJuror = _feeForJuror;\\n        court.jurorsForCourtJump = _jurorsForCourtJump;\\n        court.timesPerPeriod = _timesPerPeriod;\\n\\n        sortitionModule.createTree(courtID, _sortitionExtraData);\\n\\n        // Update the parent.\\n        courts[_parent].children.push(courtID);\\n        emit CourtCreated(\\n            courtID,\\n            _parent,\\n            _hiddenVotes,\\n            _minStake,\\n            _alpha,\\n            _feeForJuror,\\n            _jurorsForCourtJump,\\n            _timesPerPeriod,\\n            _supportedDisputeKits\\n        );\\n    }\\n\\n    /// @notice Changes the parameters of the court.\\n    /// @param _courtID ID of the court.\\n    /// @param _hiddenVotes The `hiddenVotes` property value of the court.\\n    /// @param _minStake The `minStake` property value of the court.\\n    /// @param _alpha The `alpha` property value of the court.\\n    /// @param _feeForJuror The `feeForJuror` property value of the court.\\n    /// @param _jurorsForCourtJump The `jurorsForCourtJump` property value of the court.\\n    /// @param _timesPerPeriod The `timesPerPeriod` property value of the court.\\n    function changeCourtParameters(\\n        uint96 _courtID,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] memory _timesPerPeriod\\n    ) external onlyByOwner {\\n        Court storage court = courts[_courtID];\\n        if (_courtID != GENERAL_COURT && courts[court.parent].minStake > _minStake) {\\n            revert MinStakeLowerThanParentCourt();\\n        }\\n        for (uint256 i = 0; i < court.children.length; i++) {\\n            if (courts[court.children[i]].minStake < _minStake) {\\n                revert MinStakeHigherThanChildCourt(court.children[i]);\\n            }\\n        }\\n        court.minStake = _minStake;\\n        court.hiddenVotes = _hiddenVotes;\\n        court.alpha = _alpha;\\n        court.feeForJuror = _feeForJuror;\\n        court.jurorsForCourtJump = _jurorsForCourtJump;\\n        court.timesPerPeriod = _timesPerPeriod;\\n        emit CourtModified(\\n            _courtID,\\n            _hiddenVotes,\\n            _minStake,\\n            _alpha,\\n            _feeForJuror,\\n            _jurorsForCourtJump,\\n            _timesPerPeriod\\n        );\\n    }\\n\\n    /// @notice Adds/removes court's support for specified dispute kits.\\n    /// @param _courtID The ID of the court.\\n    /// @param _disputeKitIDs The IDs of dispute kits which support should be added/removed.\\n    /// @param _enable Whether add or remove the dispute kits from the court.\\n    function enableDisputeKits(uint96 _courtID, uint256[] memory _disputeKitIDs, bool _enable) external onlyByOwner {\\n        for (uint256 i = 0; i < _disputeKitIDs.length; i++) {\\n            if (_disputeKitIDs[i] == NULL_DISPUTE_KIT || _disputeKitIDs[i] >= disputeKits.length) {\\n                revert WrongDisputeKitIndex();\\n            }\\n            if (_enable) {\\n                _enableDisputeKit(_courtID, _disputeKitIDs[i], true);\\n            } else {\\n                // Classic dispute kit must be supported by all courts.\\n                if (_disputeKitIDs[i] == DISPUTE_KIT_CLASSIC) {\\n                    revert CannotDisableClassicDK();\\n                }\\n                _enableDisputeKit(_courtID, _disputeKitIDs[i], false);\\n            }\\n        }\\n    }\\n\\n    /// @notice Changes the supported fee tokens.\\n    /// @param _feeToken The fee token.\\n    /// @param _accepted Whether the token is supported or not as a method of fee payment.\\n    function changeAcceptedFeeTokens(IERC20 _feeToken, bool _accepted) external onlyByOwner {\\n        currencyRates[_feeToken].feePaymentAccepted = _accepted;\\n        emit AcceptedFeeToken(_feeToken, _accepted);\\n    }\\n\\n    /// @notice Changes the currency rate of a fee token.\\n    /// @param _feeToken The fee token.\\n    /// @param _rateInEth The new rate of the fee token in ETH.\\n    /// @param _rateDecimals The new decimals of the fee token rate.\\n    function changeCurrencyRates(IERC20 _feeToken, uint64 _rateInEth, uint8 _rateDecimals) external onlyByOwner {\\n        currencyRates[_feeToken].rateInEth = _rateInEth;\\n        currencyRates[_feeToken].rateDecimals = _rateDecimals;\\n        emit NewCurrencyRate(_feeToken, _rateInEth, _rateDecimals);\\n    }\\n\\n    /// @notice Changes the `jurorNft` storage variable.\\n    /// @param _jurorNft The new value for the `jurorNft` storage variable.\\n    function changeJurorNft(IERC721 _jurorNft) external onlyByOwner {\\n        jurorNft = _jurorNft;\\n    }\\n\\n    /// @notice Adds or removes an arbitrable from whitelist.\\n    /// @param _arbitrable Arbitrable address.\\n    /// @param _allowed Whether add or remove permission.\\n    function changeArbitrableWhitelist(address _arbitrable, bool _allowed) external onlyByOwner {\\n        arbitrableWhitelist[_arbitrable] = _allowed;\\n    }\\n\\n    /// @notice Enables or disables the arbitrable whitelist.\\n    function changeArbitrableWhitelistEnabled(bool _enabled) external onlyByOwner {\\n        arbitrableWhitelistEnabled = _enabled;\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Sets the caller's stake in a court.\\n    /// @param _courtID The ID of the court.\\n    /// @param _newStake The new stake.\\n    /// Note that the existing delayed stake will be nullified as non-relevant.\\n    function setStake(uint96 _courtID, uint256 _newStake) external whenNotPaused {\\n        if (address(jurorNft) != address(0) && jurorNft.balanceOf(msg.sender) == 0) revert NotEligibleForStaking();\\n        _setStake(msg.sender, _courtID, _newStake, false, OnError.Revert);\\n    }\\n\\n    /// @notice Sets the stake of a specified account in a court without delaying stake changes, typically to apply a delayed stake or unstake inactive jurors.\\n    /// @param _account The account whose stake is being set.\\n    /// @param _courtID The ID of the court.\\n    /// @param _newStake The new stake.\\n    /// @return True if the stake was set successfully.\\n    function setStakeBySortitionModule(address _account, uint96 _courtID, uint256 _newStake) external returns (bool) {\\n        if (msg.sender != address(sortitionModule)) revert SortitionModuleOnly();\\n        return _setStake(_account, _courtID, _newStake, true, OnError.Return);\\n    }\\n\\n    /// @notice Transfers PNK to the juror by SortitionModule.\\n    /// @param _account The account of the juror whose PNK to transfer.\\n    /// @param _amount The amount to transfer.\\n    function transferBySortitionModule(address _account, uint256 _amount) external {\\n        if (msg.sender != address(sortitionModule)) revert SortitionModuleOnly();\\n        // Note eligibility is checked in SortitionModule.\\n        pinakion.safeTransfer(_account, _amount);\\n    }\\n\\n    /// @inheritdoc IArbitratorV2\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes memory _extraData\\n    ) external payable override returns (uint256 disputeID) {\\n        if (msg.value < arbitrationCost(_extraData)) revert ArbitrationFeesNotEnough();\\n\\n        return _createDispute(_numberOfChoices, _extraData, NATIVE_CURRENCY, msg.value);\\n    }\\n\\n    /// @inheritdoc IArbitratorV2\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData,\\n        IERC20 _feeToken,\\n        uint256 _feeAmount\\n    ) external override returns (uint256 disputeID) {\\n        if (!currencyRates[_feeToken].feePaymentAccepted) revert TokenNotAccepted();\\n        if (_feeAmount < arbitrationCost(_extraData, _feeToken)) revert ArbitrationFeesNotEnough();\\n\\n        if (!_feeToken.safeTransferFrom(msg.sender, address(this), _feeAmount)) revert TransferFailed();\\n        return _createDispute(_numberOfChoices, _extraData, _feeToken, _feeAmount);\\n    }\\n\\n    function _createDispute(\\n        uint256 _numberOfChoices,\\n        bytes memory _extraData,\\n        IERC20 _feeToken,\\n        uint256 _feeAmount\\n    ) internal returns (uint256 disputeID) {\\n        if (arbitrableWhitelistEnabled && !arbitrableWhitelist[msg.sender]) revert ArbitrableNotWhitelisted();\\n        (uint96 courtID, , uint256 disputeKitID) = _extraDataToCourtIDMinJurorsDisputeKit(_extraData);\\n        if (!courts[courtID].supportedDisputeKits[disputeKitID]) revert DisputeKitNotSupportedByCourt();\\n\\n        disputeID = disputes.length;\\n        Dispute storage dispute = disputes.push();\\n        dispute.courtID = courtID;\\n        dispute.arbitrated = IArbitrableV2(msg.sender);\\n        dispute.lastPeriodChange = block.timestamp;\\n\\n        IDisputeKit disputeKit = disputeKits[disputeKitID];\\n        Court storage court = courts[courtID];\\n        Round storage round = dispute.rounds.push();\\n\\n        // Obtain the feeForJuror in the same currency as the _feeAmount\\n        uint256 feeForJuror = (_feeToken == NATIVE_CURRENCY)\\n            ? court.feeForJuror\\n            : convertEthToTokenAmount(_feeToken, court.feeForJuror);\\n        round.nbVotes = _feeAmount / feeForJuror;\\n        round.disputeKitID = disputeKitID;\\n        round.pnkAtStakePerJuror = _calculatePnkAtStake(court.minStake, court.alpha);\\n        round.totalFeesForJurors = _feeAmount;\\n        round.feeToken = IERC20(_feeToken);\\n\\n        sortitionModule.createDisputeHook(disputeID, 0); // Default round ID.\\n\\n        disputeKit.createDispute(disputeID, 0, _numberOfChoices, _extraData, round.nbVotes);\\n        emit DisputeCreation(disputeID, IArbitrableV2(msg.sender));\\n    }\\n\\n    /// @notice Passes the period of a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    function passPeriod(uint256 _disputeID) external {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Court storage court = courts[dispute.courtID];\\n\\n        uint256 currentRound = dispute.rounds.length - 1;\\n        Round storage round = dispute.rounds[currentRound];\\n        if (dispute.period == Period.evidence) {\\n            if (\\n                currentRound == 0 &&\\n                block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)]\\n            ) {\\n                revert EvidenceNotPassedAndNotAppeal();\\n            }\\n            if (round.drawnJurors.length != round.nbVotes) revert DisputeStillDrawing();\\n            dispute.period = court.hiddenVotes ? Period.commit : Period.vote;\\n        } else if (dispute.period == Period.commit) {\\n            if (\\n                block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)] &&\\n                !disputeKits[round.disputeKitID].areCommitsAllCast(_disputeID)\\n            ) {\\n                revert CommitPeriodNotPassed();\\n            }\\n            dispute.period = Period.vote;\\n        } else if (dispute.period == Period.vote) {\\n            if (\\n                block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)] &&\\n                !disputeKits[round.disputeKitID].areVotesAllCast(_disputeID)\\n            ) {\\n                revert VotePeriodNotPassed();\\n            }\\n            dispute.period = Period.appeal;\\n            emit AppealPossible(_disputeID, dispute.arbitrated);\\n        } else if (dispute.period == Period.appeal) {\\n            if (\\n                block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)] &&\\n                !disputeKits[round.disputeKitID].isAppealFunded(_disputeID)\\n            ) {\\n                revert AppealPeriodNotPassed();\\n            }\\n            dispute.period = Period.execution;\\n        } else if (dispute.period == Period.execution) {\\n            revert DisputePeriodIsFinal();\\n        }\\n\\n        dispute.lastPeriodChange = block.timestamp;\\n        emit NewPeriod(_disputeID, dispute.period);\\n    }\\n\\n    /// @notice Draws jurors for the dispute. Can be called in parts.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _iterations The number of iterations to run.\\n    /// @return nbDrawnJurors The total number of jurors drawn in the round.\\n    function draw(uint256 _disputeID, uint256 _iterations) external returns (uint256 nbDrawnJurors) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        uint256 currentRound = dispute.rounds.length - 1;\\n        Round storage round = dispute.rounds[currentRound];\\n        if (dispute.period != Period.evidence) revert NotEvidencePeriod();\\n\\n        IDisputeKit disputeKit = disputeKits[round.disputeKitID];\\n\\n        uint256 startIndex = round.drawIterations; // for gas: less storage reads\\n        uint256 i;\\n        while (i < _iterations && round.drawnJurors.length < round.nbVotes) {\\n            (address drawnAddress, uint96 fromSubcourtID) = disputeKit.draw(\\n                _disputeID,\\n                startIndex + i++,\\n                round.nbVotes\\n            );\\n            if (drawnAddress == address(0)) {\\n                continue;\\n            }\\n            sortitionModule.lockStake(drawnAddress, round.pnkAtStakePerJuror);\\n            emit Draw(drawnAddress, _disputeID, currentRound, round.drawnJurors.length);\\n            round.drawnJurors.push(drawnAddress);\\n            round.drawnJurorFromCourtIDs.push(fromSubcourtID != 0 ? fromSubcourtID : dispute.courtID);\\n            if (round.drawnJurors.length == round.nbVotes) {\\n                sortitionModule.postDrawHook(_disputeID, currentRound);\\n            }\\n        }\\n        round.drawIterations += i;\\n        return round.drawnJurors.length;\\n    }\\n\\n    /// @notice Appeals the ruling of a specified dispute.\\n    /// @dev Access restricted to the Dispute Kit for this `_disputeID`.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _numberOfChoices Number of choices for the dispute. Can be required during court jump.\\n    /// @param _extraData Extradata for the dispute. Can be required during court jump.\\n    function appeal(uint256 _disputeID, uint256 _numberOfChoices, bytes memory _extraData) external payable {\\n        if (msg.value < appealCost(_disputeID)) revert AppealFeesNotEnough();\\n\\n        Dispute storage dispute = disputes[_disputeID];\\n        if (dispute.period != Period.appeal) revert DisputeNotAppealable();\\n\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        if (msg.sender != address(disputeKits[round.disputeKitID])) revert DisputeKitOnly();\\n\\n        // Warning: the extra round must be created before calling disputeKit.createDispute()\\n        Round storage extraRound = dispute.rounds.push();\\n        uint256 extraRoundID = dispute.rounds.length - 1;\\n\\n        (uint96 newCourtID, uint256 newDisputeKitID, ) = _getCompatibleNextRoundSettings(\\n            dispute,\\n            round,\\n            courts[dispute.courtID],\\n            _disputeID\\n        );\\n        if (newCourtID != dispute.courtID) {\\n            emit CourtJump(_disputeID, extraRoundID, dispute.courtID, newCourtID);\\n        }\\n\\n        dispute.courtID = newCourtID;\\n        dispute.period = Period.evidence;\\n        dispute.lastPeriodChange = block.timestamp;\\n\\n        Court storage court = courts[newCourtID];\\n        extraRound.nbVotes = msg.value / court.feeForJuror; // As many votes that can be afforded by the provided funds.\\n        extraRound.pnkAtStakePerJuror = _calculatePnkAtStake(court.minStake, court.alpha);\\n        extraRound.totalFeesForJurors = msg.value;\\n        extraRound.disputeKitID = newDisputeKitID;\\n\\n        sortitionModule.createDisputeHook(_disputeID, extraRoundID);\\n\\n        // Dispute kit was changed, so create a dispute in the new DK contract.\\n        if (extraRound.disputeKitID != round.disputeKitID) {\\n            emit DisputeKitJump(_disputeID, dispute.rounds.length - 1, round.disputeKitID, extraRound.disputeKitID);\\n            disputeKits[extraRound.disputeKitID].createDispute(\\n                _disputeID,\\n                extraRoundID,\\n                _numberOfChoices,\\n                _extraData,\\n                extraRound.nbVotes\\n            );\\n        }\\n\\n        emit AppealDecision(_disputeID, dispute.arbitrated);\\n        emit NewPeriod(_disputeID, Period.evidence);\\n    }\\n\\n    /// @notice Distribute the PNKs at stake and the dispute fees for the specific round of the dispute. Can be called in parts.\\n    /// @dev Reward distributions are forbidden during pause.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _round The appeal round.\\n    /// @param _iterations The number of iterations to run.\\n    function execute(uint256 _disputeID, uint256 _round, uint256 _iterations) external whenNotPaused {\\n        Round storage round;\\n        {\\n            Dispute storage dispute = disputes[_disputeID];\\n            if (dispute.period != Period.execution) revert NotExecutionPeriod();\\n\\n            round = dispute.rounds[_round];\\n        } // stack too deep workaround\\n\\n        uint256 start = round.repartitions;\\n        uint256 end = round.repartitions + _iterations;\\n\\n        uint256 pnkPenaltiesInRound = round.pnkPenalties; // Keep in memory to save gas.\\n        uint256 numberOfVotesInRound = round.drawnJurors.length;\\n        uint256 feePerJurorInRound = round.totalFeesForJurors / numberOfVotesInRound;\\n        uint256 pnkAtStakePerJurorInRound = round.pnkAtStakePerJuror;\\n        uint256 coherentCount;\\n        {\\n            IDisputeKit disputeKit = disputeKits[round.disputeKitID];\\n            coherentCount = disputeKit.getCoherentCount(_disputeID, _round); // Total number of jurors that are eligible to a reward in this round.\\n        } // stack too deep workaround\\n\\n        if (coherentCount == 0) {\\n            // We loop over the votes once as there are no rewards because it is not a tie and no one in this round is coherent with the final outcome.\\n            if (end > numberOfVotesInRound) end = numberOfVotesInRound;\\n        } else {\\n            // We loop over the votes twice, first to collect the PNK penalties, and second to distribute them as rewards along with arbitration fees.\\n            if (end > numberOfVotesInRound * 2) end = numberOfVotesInRound * 2;\\n        }\\n        round.repartitions = end;\\n\\n        for (uint256 i = start; i < end; i++) {\\n            if (i < numberOfVotesInRound) {\\n                pnkPenaltiesInRound = _executePenalties(\\n                    ExecuteParams({\\n                        disputeID: _disputeID,\\n                        round: _round,\\n                        coherentCount: coherentCount,\\n                        numberOfVotesInRound: numberOfVotesInRound,\\n                        feePerJurorInRound: feePerJurorInRound,\\n                        pnkAtStakePerJurorInRound: pnkAtStakePerJurorInRound,\\n                        pnkPenaltiesInRound: pnkPenaltiesInRound,\\n                        repartition: i\\n                    })\\n                );\\n            } else {\\n                _executeRewards(\\n                    ExecuteParams({\\n                        disputeID: _disputeID,\\n                        round: _round,\\n                        coherentCount: coherentCount,\\n                        numberOfVotesInRound: numberOfVotesInRound,\\n                        feePerJurorInRound: feePerJurorInRound,\\n                        pnkAtStakePerJurorInRound: pnkAtStakePerJurorInRound,\\n                        pnkPenaltiesInRound: pnkPenaltiesInRound,\\n                        repartition: i\\n                    })\\n                );\\n            }\\n        }\\n        if (round.pnkPenalties != pnkPenaltiesInRound) {\\n            round.pnkPenalties = pnkPenaltiesInRound; // Note: Check-Effect-Interaction pattern is compromised here, but in the current state it doesn't cause any issues.\\n        }\\n    }\\n\\n    /// @notice Distribute the PNKs at stake and the dispute fees for the specific round of the dispute, penalties only.\\n    /// @param _params The parameters for the execution, see `ExecuteParams`.\\n    /// @return pnkPenaltiesInRoundCache The updated penalties in round cache.\\n    function _executePenalties(ExecuteParams memory _params) internal returns (uint256) {\\n        Dispute storage dispute = disputes[_params.disputeID];\\n        Round storage round = dispute.rounds[_params.round];\\n        IDisputeKit disputeKit = disputeKits[round.disputeKitID];\\n\\n        // [0, 1] value that determines how coherent the juror was in this round, in basis points.\\n        uint256 coherence = disputeKit.getDegreeOfCoherencePenalty(\\n            _params.disputeID,\\n            _params.round,\\n            _params.repartition,\\n            _params.feePerJurorInRound,\\n            _params.pnkAtStakePerJurorInRound\\n        );\\n\\n        // Extra check to guard against degree exceeding 1, though it should be ensured by the dispute kit.\\n        if (coherence > ONE_BASIS_POINT) {\\n            coherence = ONE_BASIS_POINT;\\n        }\\n\\n        // Fully coherent jurors won't be penalized.\\n        uint256 penalty = (round.pnkAtStakePerJuror * (ONE_BASIS_POINT - coherence)) / ONE_BASIS_POINT;\\n\\n        // Unlock the PNKs affected by the penalty\\n        address account = round.drawnJurors[_params.repartition];\\n        sortitionModule.unlockStake(account, penalty);\\n\\n        // Apply the penalty to the staked PNKs.\\n        uint96 penalizedInCourtID = round.drawnJurorFromCourtIDs[_params.repartition];\\n        (uint256 pnkBalance, uint256 newCourtStake, uint256 availablePenalty) = sortitionModule.setStakePenalty(\\n            account,\\n            penalizedInCourtID,\\n            penalty\\n        );\\n        if (availablePenalty != 0) {\\n            _params.pnkPenaltiesInRound += availablePenalty;\\n            emit JurorRewardPenalty(\\n                account,\\n                _params.disputeID,\\n                _params.round,\\n                coherence,\\n                0,\\n                -int256(availablePenalty),\\n                0,\\n                round.feeToken\\n            );\\n        }\\n\\n        if (pnkBalance == 0 || !disputeKit.isVoteActive(_params.disputeID, _params.round, _params.repartition)) {\\n            // The juror is inactive or their balance can't cover penalties anymore, unstake them from all courts.\\n            sortitionModule.forcedUnstakeAllCourts(account);\\n        } else if (newCourtStake < courts[penalizedInCourtID].minStake) {\\n            // The juror's balance fell below the court minStake, unstake them from the court.\\n            sortitionModule.forcedUnstake(account, penalizedInCourtID);\\n        }\\n\\n        if (_params.repartition == _params.numberOfVotesInRound - 1 && _params.coherentCount == 0) {\\n            // No one was coherent, send the rewards to the owner.\\n            _transferFeeToken(round.feeToken, payable(owner), round.totalFeesForJurors);\\n            pinakion.safeTransfer(owner, _params.pnkPenaltiesInRound);\\n            emit LeftoverRewardSent(\\n                _params.disputeID,\\n                _params.round,\\n                _params.pnkPenaltiesInRound,\\n                round.totalFeesForJurors,\\n                round.feeToken\\n            );\\n        }\\n        return _params.pnkPenaltiesInRound;\\n    }\\n\\n    /// @notice Distribute the PNKs at stake and the dispute fees for the specific round of the dispute, rewards only.\\n    /// @param _params The parameters for the execution, see `ExecuteParams`.\\n    function _executeRewards(ExecuteParams memory _params) internal {\\n        Dispute storage dispute = disputes[_params.disputeID];\\n        Round storage round = dispute.rounds[_params.round];\\n        IDisputeKit disputeKit = disputeKits[round.disputeKitID];\\n        uint256 repartition = _params.repartition % _params.numberOfVotesInRound;\\n\\n        // [0, 1] value that determines how coherent the juror was in this round, in basis points.\\n        (uint256 pnkCoherence, uint256 feeCoherence) = disputeKit.getDegreeOfCoherenceReward(\\n            _params.disputeID,\\n            _params.round,\\n            repartition,\\n            _params.feePerJurorInRound,\\n            _params.pnkAtStakePerJurorInRound\\n        );\\n\\n        // Extra check to guard against degree exceeding 1, though it should be ensured by the dispute kit.\\n        if (pnkCoherence > ONE_BASIS_POINT) {\\n            pnkCoherence = ONE_BASIS_POINT;\\n        }\\n        if (feeCoherence > ONE_BASIS_POINT) {\\n            feeCoherence = ONE_BASIS_POINT;\\n        }\\n\\n        address account = round.drawnJurors[repartition];\\n        uint256 pnkLocked = _applyCoherence(round.pnkAtStakePerJuror, pnkCoherence);\\n\\n        // Release the rest of the PNKs of the juror for this round.\\n        sortitionModule.unlockStake(account, pnkLocked);\\n\\n        // Compute the rewards\\n        uint256 pnkReward = _applyCoherence(_params.pnkPenaltiesInRound / _params.coherentCount, pnkCoherence);\\n        round.sumPnkRewardPaid += pnkReward;\\n        uint256 feeReward = _applyCoherence(round.totalFeesForJurors / _params.coherentCount, feeCoherence);\\n        round.sumFeeRewardPaid += feeReward;\\n\\n        if (feeReward != 0) {\\n            // Transfer the fee reward\\n            _transferFeeToken(round.feeToken, payable(account), feeReward);\\n        }\\n        if (pnkReward != 0) {\\n            uint96 rewardedInCourtID = round.drawnJurorFromCourtIDs[repartition];\\n\\n            // Stake the PNK reward if possible, bypasses delayed stakes and other checks done by validateStake()\\n            if (!sortitionModule.setStakeReward(account, rewardedInCourtID, pnkReward)) {\\n                pinakion.safeTransfer(account, pnkReward);\\n            }\\n        }\\n        if (pnkReward != 0 || feeReward != 0) {\\n            emit JurorRewardPenalty(\\n                account,\\n                _params.disputeID,\\n                _params.round,\\n                pnkCoherence,\\n                feeCoherence,\\n                int256(pnkReward),\\n                int256(feeReward),\\n                round.feeToken\\n            );\\n        }\\n\\n        // Transfer any residual rewards to the owner. It may happen due to partial coherence of the jurors.\\n        if (_params.repartition == _params.numberOfVotesInRound * 2 - 1) {\\n            uint256 leftoverPnkReward = _params.pnkPenaltiesInRound - round.sumPnkRewardPaid;\\n            uint256 leftoverFeeReward = round.totalFeesForJurors - round.sumFeeRewardPaid;\\n            if (leftoverPnkReward != 0 || leftoverFeeReward != 0) {\\n                if (leftoverPnkReward != 0) {\\n                    pinakion.safeTransfer(owner, leftoverPnkReward);\\n                }\\n                if (leftoverFeeReward != 0) {\\n                    _transferFeeToken(round.feeToken, payable(owner), leftoverFeeReward);\\n                }\\n                emit LeftoverRewardSent(\\n                    _params.disputeID,\\n                    _params.round,\\n                    leftoverPnkReward,\\n                    leftoverFeeReward,\\n                    round.feeToken\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Executes a specified dispute's ruling.\\n    /// @param _disputeID The ID of the dispute.\\n    function executeRuling(uint256 _disputeID) external {\\n        Dispute storage dispute = disputes[_disputeID];\\n        if (dispute.period != Period.execution) revert NotExecutionPeriod();\\n        if (dispute.ruled) revert RulingAlreadyExecuted();\\n\\n        (uint256 winningChoice, , ) = currentRuling(_disputeID);\\n        dispute.ruled = true;\\n        emit Ruling(dispute.arbitrated, _disputeID, winningChoice);\\n        dispute.arbitrated.rule(_disputeID, winningChoice);\\n    }\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @inheritdoc IArbitratorV2\\n    function arbitrationCost(bytes memory _extraData) public view override returns (uint256 cost) {\\n        (uint96 courtID, uint256 minJurors, ) = _extraDataToCourtIDMinJurorsDisputeKit(_extraData);\\n        cost = courts[courtID].feeForJuror * minJurors;\\n    }\\n\\n    /// @inheritdoc IArbitratorV2\\n    function arbitrationCost(bytes calldata _extraData, IERC20 _feeToken) public view override returns (uint256 cost) {\\n        cost = convertEthToTokenAmount(_feeToken, arbitrationCost(_extraData));\\n    }\\n\\n    /// @notice Gets the cost of appealing a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return The appeal cost.\\n    function appealCost(uint256 _disputeID) public view returns (uint256) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        Court storage court = courts[dispute.courtID];\\n        (uint96 newCourtID, , uint256 nbVotesAfterAppeal) = _getCompatibleNextRoundSettings(\\n            dispute,\\n            round,\\n            court,\\n            _disputeID\\n        );\\n        if (newCourtID == dispute.courtID) {\\n            // No court jump\\n            return court.feeForJuror * nbVotesAfterAppeal;\\n        }\\n        if (dispute.courtID != GENERAL_COURT && newCourtID != FORKING_COURT) {\\n            // Court jump but not to the Forking court\\n            return courts[newCourtID].feeForJuror * nbVotesAfterAppeal;\\n        }\\n        return NON_PAYABLE_AMOUNT; // Jumping to the Forking Court is not supported yet.\\n    }\\n\\n    /// @notice Gets the start and the end of a specified dispute's current appeal period.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return start The start of the appeal period.\\n    /// @return end The end of the appeal period.\\n    function appealPeriod(uint256 _disputeID) external view returns (uint256 start, uint256 end) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        if (dispute.period == Period.appeal) {\\n            start = dispute.lastPeriodChange;\\n            end = dispute.lastPeriodChange + courts[dispute.courtID].timesPerPeriod[uint256(Period.appeal)];\\n        } else {\\n            start = 0;\\n            end = 0;\\n        }\\n    }\\n\\n    /// @inheritdoc IArbitratorV2\\n    function currentRuling(uint256 _disputeID) public view returns (uint256 ruling, bool tied, bool overridden) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        IDisputeKit disputeKit = disputeKits[round.disputeKitID];\\n        (ruling, tied, overridden) = disputeKit.currentRuling(_disputeID);\\n    }\\n\\n    /// @notice Gets the round info for a specified dispute and round.\\n    /// @dev This function must not be called from a non-view function because it returns a dynamic array which might be very large, theoretically exceeding the block gas limit.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _round The round to get the info for.\\n    /// @return round The round info.\\n    function getRoundInfo(uint256 _disputeID, uint256 _round) external view returns (Round memory) {\\n        return disputes[_disputeID].rounds[_round];\\n    }\\n\\n    /// @notice Gets the PNK at stake per juror for a specified dispute and round.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _round The round to get the info for.\\n    /// @return pnkAtStakePerJuror The PNK at stake per juror.\\n    function getPnkAtStakePerJuror(uint256 _disputeID, uint256 _round) external view returns (uint256) {\\n        return disputes[_disputeID].rounds[_round].pnkAtStakePerJuror;\\n    }\\n\\n    /// @notice Gets the number of rounds for a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return The number of rounds.\\n    function getNumberOfRounds(uint256 _disputeID) external view returns (uint256) {\\n        return disputes[_disputeID].rounds.length;\\n    }\\n\\n    /// @notice Checks if a given dispute kit is supported by a given court.\\n    /// @param _courtID The ID of the court to check the support for.\\n    /// @param _disputeKitID The ID of the dispute kit to check the support for.\\n    /// @return Whether the dispute kit is supported or not.\\n    function isSupported(uint96 _courtID, uint256 _disputeKitID) external view returns (bool) {\\n        return courts[_courtID].supportedDisputeKits[_disputeKitID];\\n    }\\n\\n    /// @notice Gets the timesPerPeriod array for a given court.\\n    /// @param _courtID The ID of the court to get the times from.\\n    /// @return timesPerPeriod The timesPerPeriod array for the given court.\\n    function getTimesPerPeriod(uint96 _courtID) external view returns (uint256[4] memory timesPerPeriod) {\\n        timesPerPeriod = courts[_courtID].timesPerPeriod;\\n    }\\n\\n    // ************************************* //\\n    // *   Public Views for Dispute Kits   * //\\n    // ************************************* //\\n\\n    /// @notice Gets the number of votes permitted for the specified dispute in the latest round.\\n    /// @param _disputeID The ID of the dispute.\\n    function getNumberOfVotes(uint256 _disputeID) external view returns (uint256) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        return dispute.rounds[dispute.rounds.length - 1].nbVotes;\\n    }\\n\\n    /// @notice Checks whether a dispute will jump to new court/DK and enforces a compatibility check.\\n    /// @param _disputeID Dispute ID.\\n    /// @return newCourtID Court ID after jump.\\n    /// @return newDisputeKitID Dispute kit ID after jump.\\n    /// @return newRoundNbVotes The number of votes in the new round.\\n    /// @return courtJump Whether the dispute jumps to a new court or not.\\n    /// @return disputeKitJump Whether the dispute jumps to a new dispute kit or not.\\n    function getCourtAndDisputeKitJumps(\\n        uint256 _disputeID\\n    )\\n        external\\n        view\\n        returns (\\n            uint96 newCourtID,\\n            uint256 newDisputeKitID,\\n            uint256 newRoundNbVotes,\\n            bool courtJump,\\n            bool disputeKitJump\\n        )\\n    {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        Court storage court = courts[dispute.courtID];\\n\\n        (newCourtID, newDisputeKitID, newRoundNbVotes) = _getCompatibleNextRoundSettings(\\n            dispute,\\n            round,\\n            court,\\n            _disputeID\\n        );\\n        courtJump = (newCourtID != dispute.courtID);\\n        disputeKitJump = (newDisputeKitID != round.disputeKitID);\\n    }\\n\\n    /// @notice Returns the length of disputeKits array.\\n    /// @return disputeKits length.\\n    function getDisputeKitsLength() external view returns (uint256) {\\n        return disputeKits.length;\\n    }\\n\\n    /// @notice Converts ETH into tokens.\\n    /// @param _toToken The token to convert ETH into.\\n    /// @param _amountInEth ETH amount.\\n    /// @return Amount of tokens.\\n    function convertEthToTokenAmount(IERC20 _toToken, uint256 _amountInEth) public view returns (uint256) {\\n        return (_amountInEth * 10 ** currencyRates[_toToken].rateDecimals) / currencyRates[_toToken].rateInEth;\\n    }\\n\\n    // ************************************* //\\n    // *            Internal               * //\\n    // ************************************* //\\n\\n    /// @notice Get the next round settings for a given dispute\\n    /// @dev Enforces a compatibility check between the next round's court and dispute kit.\\n    /// @param _dispute Dispute data.\\n    /// @param _round Round ID.\\n    /// @param _court Current court ID.\\n    /// @param _disputeID Dispute ID.\\n    /// @return newCourtID Court ID after jump.\\n    /// @return newDisputeKitID Dispute kit ID after jump.\\n    /// @return newRoundNbVotes The number of votes in the new round.\\n    function _getCompatibleNextRoundSettings(\\n        Dispute storage _dispute,\\n        Round storage _round,\\n        Court storage _court,\\n        uint256 _disputeID\\n    ) internal view returns (uint96 newCourtID, uint256 newDisputeKitID, uint256 newRoundNbVotes) {\\n        uint256 disputeKitID = _round.disputeKitID;\\n        (newCourtID, newDisputeKitID, newRoundNbVotes) = disputeKits[disputeKitID].getNextRoundSettings(\\n            _disputeID,\\n            _dispute.courtID,\\n            _court.parent,\\n            _court.jurorsForCourtJump,\\n            disputeKitID,\\n            _round.nbVotes\\n        );\\n        if (\\n            newCourtID == FORKING_COURT ||\\n            newCourtID >= courts.length ||\\n            newDisputeKitID == NULL_DISPUTE_KIT ||\\n            newDisputeKitID >= disputeKits.length ||\\n            newRoundNbVotes == 0\\n        ) {\\n            // Falling back to the current court and dispute kit with default nbVotes increase.\\n            newCourtID = _dispute.courtID;\\n            newDisputeKitID = disputeKitID;\\n            newRoundNbVotes = (_round.nbVotes * 2) + 1;\\n        }\\n        // Ensure compatibility between the next round's court and dispute kit.\\n        if (!courts[newCourtID].supportedDisputeKits[newDisputeKitID]) {\\n            // Falling back to `DisputeKitClassic` which is always supported and with default nbVotes increase.\\n            newDisputeKitID = DISPUTE_KIT_CLASSIC;\\n            newRoundNbVotes = (_round.nbVotes * 2) + 1;\\n        }\\n    }\\n\\n    /// @notice Internal function to transfer fee tokens (ETH or ERC20)\\n    /// @param _feeToken The token to transfer (NATIVE_CURRENCY for ETH).\\n    /// @param _recipient The recipient address.\\n    /// @param _amount The amount to transfer.\\n    function _transferFeeToken(IERC20 _feeToken, address payable _recipient, uint256 _amount) internal {\\n        if (_feeToken == NATIVE_CURRENCY) {\\n            _recipient.safeSend(_amount, wNative);\\n        } else {\\n            _feeToken.safeTransfer(_recipient, _amount);\\n        }\\n    }\\n\\n    /// @notice Applies degree of coherence to an amount\\n    /// @param _amount The base amount to apply coherence to.\\n    /// @param _coherence The degree of coherence in basis points.\\n    /// @return The amount after applying the degree of coherence.\\n    function _applyCoherence(uint256 _amount, uint256 _coherence) internal pure returns (uint256) {\\n        return (_amount * _coherence) / ONE_BASIS_POINT;\\n    }\\n\\n    /// @notice Calculates PNK at stake per juror based on court parameters\\n    /// @param _minStake The minimum stake for the court.\\n    /// @param _alpha The alpha parameter for the court in basis points.\\n    /// @return The amount of PNK at stake per juror.\\n    function _calculatePnkAtStake(uint256 _minStake, uint256 _alpha) internal pure returns (uint256) {\\n        return (_minStake * _alpha) / ONE_BASIS_POINT;\\n    }\\n\\n    /// @notice Toggles the dispute kit support for a given court.\\n    /// @param _courtID The ID of the court to toggle the support for.\\n    /// @param _disputeKitID The ID of the dispute kit to toggle the support for.\\n    /// @param _enable Whether to enable or disable the support. Note that classic dispute kit should always be enabled.\\n    function _enableDisputeKit(uint96 _courtID, uint256 _disputeKitID, bool _enable) internal {\\n        courts[_courtID].supportedDisputeKits[_disputeKitID] = _enable;\\n        emit DisputeKitEnabled(_courtID, _disputeKitID, _enable);\\n    }\\n\\n    /// @notice If called only once then set _onError to Revert, otherwise set it to Return\\n    /// @param _account The account to set the stake for.\\n    /// @param _courtID The ID of the court to set the stake for.\\n    /// @param _newStake The new stake.\\n    /// @param _noDelay True if the stake change should not be delayed.\\n    /// @param _onError Whether to revert or return false on error.\\n    /// @return Whether the stake was successfully set or not.\\n    function _setStake(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _newStake,\\n        bool _noDelay,\\n        OnError _onError\\n    ) internal returns (bool) {\\n        if (_courtID == FORKING_COURT || _courtID >= courts.length) {\\n            _stakingFailed(_onError, StakingResult.CannotStakeInThisCourt); // Staking directly into the forking court is not allowed.\\n            return false;\\n        }\\n        if (_newStake != 0 && _newStake < courts[_courtID].minStake) {\\n            _stakingFailed(_onError, StakingResult.CannotStakeLessThanMinStake); // Staking less than the minimum stake is not allowed.\\n            return false;\\n        }\\n        (uint256 pnkDeposit, uint256 pnkWithdrawal, StakingResult stakingResult) = sortitionModule.validateStake(\\n            _account,\\n            _courtID,\\n            _newStake,\\n            _noDelay\\n        );\\n        if (stakingResult != StakingResult.Successful && stakingResult != StakingResult.Delayed) {\\n            _stakingFailed(_onError, stakingResult);\\n            return false;\\n        } else if (stakingResult == StakingResult.Delayed) {\\n            return true;\\n        }\\n        if (pnkDeposit > 0) {\\n            if (!pinakion.safeTransferFrom(_account, address(this), pnkDeposit)) {\\n                _stakingFailed(_onError, StakingResult.StakingTransferFailed);\\n                return false;\\n            }\\n        }\\n        if (pnkWithdrawal > 0) {\\n            if (!pinakion.safeTransfer(_account, pnkWithdrawal)) {\\n                _stakingFailed(_onError, StakingResult.UnstakingTransferFailed);\\n                return false;\\n            }\\n        }\\n        sortitionModule.setStake(_account, _courtID, pnkDeposit, pnkWithdrawal, _newStake);\\n\\n        return true;\\n    }\\n\\n    /// @notice It may revert depending on the _onError parameter.\\n    function _stakingFailed(OnError _onError, StakingResult _result) internal pure {\\n        if (_onError == OnError.Return) return;\\n        if (_result == StakingResult.StakingTransferFailed) revert StakingTransferFailed();\\n        if (_result == StakingResult.UnstakingTransferFailed) revert UnstakingTransferFailed();\\n        if (_result == StakingResult.CannotStakeInMoreCourts) revert StakingInTooManyCourts();\\n        if (_result == StakingResult.CannotStakeInThisCourt) revert StakingNotPossibleInThisCourt();\\n        if (_result == StakingResult.CannotStakeLessThanMinStake) revert StakingLessThanCourtMinStake();\\n        if (_result == StakingResult.CannotStakeZeroWhenNoStake) revert StakingZeroWhenNoStake();\\n        if (_result == StakingResult.CannotStakeMoreThanMaxStakePerJuror) revert StakingMoreThanMaxStakePerJuror();\\n        if (_result == StakingResult.CannotStakeMoreThanMaxTotalStaked) revert StakingMoreThanMaxTotalStaked();\\n    }\\n\\n    /// @notice Gets a court ID, the minimum number of jurors and an ID of a dispute kit from a specified extra data bytes array.\\n    /// @dev If `_extraData` contains an incorrect value then this value will be switched to default.\\n    /// @param _extraData The extra data bytes array. The first 32 bytes are the court ID, the next are the minimum number of jurors and the last are the dispute kit ID.\\n    /// @return courtID The court ID.\\n    /// @return minJurors The minimum number of jurors required.\\n    /// @return disputeKitID The ID of the dispute kit.\\n    function _extraDataToCourtIDMinJurorsDisputeKit(\\n        bytes memory _extraData\\n    ) internal view returns (uint96 courtID, uint256 minJurors, uint256 disputeKitID) {\\n        // Note that if the _extraData doesn't contain 32 bytes, default values are used.\\n        if (_extraData.length >= 64) {\\n            assembly {\\n                // solium-disable-line security/no-inline-assembly\\n                courtID := mload(add(_extraData, 0x20))\\n                minJurors := mload(add(_extraData, 0x40))\\n                disputeKitID := mload(add(_extraData, 0x60))\\n            }\\n            if (courtID == FORKING_COURT || courtID >= courts.length) {\\n                courtID = GENERAL_COURT;\\n            }\\n            if (minJurors == 0) {\\n                minJurors = DEFAULT_NB_OF_JURORS;\\n            }\\n            if (disputeKitID == NULL_DISPUTE_KIT || disputeKitID >= disputeKits.length) {\\n                disputeKitID = DISPUTE_KIT_CLASSIC;\\n            }\\n        } else {\\n            courtID = GENERAL_COURT;\\n            minJurors = DEFAULT_NB_OF_JURORS;\\n            disputeKitID = DISPUTE_KIT_CLASSIC;\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *              Errors               * //\\n    // ************************************* //\\n\\n    error OwnerOnly();\\n    error GuardianOrOwnerOnly();\\n    error DisputeKitOnly();\\n    error SortitionModuleOnly();\\n    error UnsuccessfulCall();\\n    error InvalidDisputeKitParent();\\n    error MinStakeLowerThanParentCourt();\\n    error MinStakeHigherThanChildCourt(uint256 _childCourtID);\\n    error UnsupportedDisputeKit();\\n    error InvalidForkingCourtAsParent();\\n    error WrongDisputeKitIndex();\\n    error CannotDisableClassicDK();\\n    error NotEligibleForStaking();\\n    error StakingMoreThanMaxStakePerJuror();\\n    error StakingMoreThanMaxTotalStaked();\\n    error StakingInTooManyCourts();\\n    error StakingNotPossibleInThisCourt();\\n    error StakingLessThanCourtMinStake();\\n    error StakingTransferFailed();\\n    error UnstakingTransferFailed();\\n    error ArbitrableNotWhitelisted();\\n    error ArbitrationFeesNotEnough();\\n    error DisputeKitNotSupportedByCourt();\\n    error MustSupportDisputeKitClassic();\\n    error TokenNotAccepted();\\n    error EvidenceNotPassedAndNotAppeal();\\n    error DisputeStillDrawing();\\n    error CommitPeriodNotPassed();\\n    error VotePeriodNotPassed();\\n    error AppealPeriodNotPassed();\\n    error NotEvidencePeriod();\\n    error AppealFeesNotEnough();\\n    error DisputeNotAppealable();\\n    error NotExecutionPeriod();\\n    error RulingAlreadyExecuted();\\n    error DisputePeriodIsFinal();\\n    error TransferFailed();\\n    error WhenNotPausedOnly();\\n    error WhenPausedOnly();\\n    error StakingZeroWhenNoStake();\\n}\\n\",\"keccak256\":\"0x8e02b1ab61d24378f89865c1d252963346bb709c1b6a88175a9e3cc1d92d5775\",\"license\":\"MIT\"},\"src/arbitration/SortitionModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\nimport {KlerosCore} from \\\"./KlerosCore.sol\\\";\\nimport {ISortitionModule} from \\\"./interfaces/ISortitionModule.sol\\\";\\nimport {Initializable} from \\\"../proxy/Initializable.sol\\\";\\nimport {UUPSProxiable} from \\\"../proxy/UUPSProxiable.sol\\\";\\nimport {SortitionTrees, TreeKey, CourtID} from \\\"../libraries/SortitionTrees.sol\\\";\\nimport {IRNG} from \\\"../rng/IRNG.sol\\\";\\nimport \\\"../libraries/Constants.sol\\\";\\n\\n/// @title SortitionModule\\n/// @notice A factory of trees that keeps track of staked values for sortition.\\ncontract SortitionModule is ISortitionModule, Initializable, UUPSProxiable {\\n    using SortitionTrees for SortitionTrees.Tree;\\n    using SortitionTrees for mapping(TreeKey key => SortitionTrees.Tree);\\n\\n    string public constant override version = \\\"2.0.0\\\";\\n\\n    // ************************************* //\\n    // *         Enums / Structs           * //\\n    // ************************************* //\\n\\n    struct DelayedStake {\\n        address account; // The address of the juror.\\n        uint96 courtID; // The ID of the court.\\n        uint256 stake; // The new stake.\\n    }\\n\\n    struct Juror {\\n        uint96[] courtIDs; // The IDs of courts where the juror's stake path ends. A stake path is a path from the general court to a court the juror directly staked in using `_setStake`.\\n        uint256 stakedPnk; // The juror's total amount of tokens staked in subcourts. PNK balance including locked PNK and penalty deductions.\\n        uint256 lockedPnk; // The juror's total amount of tokens locked in disputes.\\n    }\\n\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    address public owner; // The owner of the contract.\\n    KlerosCore public core; // The core arbitrator contract.\\n    Phase public phase; // The current phase.\\n    uint256 public minStakingTime; // The time after which the phase can be switched to Drawing if there are open disputes.\\n    uint256 public maxDrawingTime; // The time after which the phase can be switched back to Staking.\\n    uint256 public lastPhaseChange; // The last time the phase was changed.\\n    uint256 public disputesWithoutJurors; // The number of disputes that have not finished drawing jurors.\\n    IRNG public rng; // The random number generator.\\n    uint256 public randomNumber; // Random number returned by RNG.\\n    uint256 public delayedStakeWriteIndex; // The index of the last `delayedStake` item that was written to the array. 0 index is skipped.\\n    uint256 public delayedStakeReadIndex; // The index of the next `delayedStake` item that should be processed. Starts at 1 because 0 index is skipped.\\n    mapping(TreeKey key => SortitionTrees.Tree) sortitionSumTrees; // The mapping of sortition trees by keys.\\n    mapping(address account => Juror) public jurors; // The jurors.\\n    mapping(uint256 => DelayedStake) public delayedStakes; // Stores the stakes that were changed during Drawing phase, to update them when the phase is switched to Staking.\\n    uint256 public maxStakePerJuror; // The maximum amount of PNK that a juror can stake across the courts.\\n    uint256 public maxTotalStaked; // The maximum amount of PNK that all the jurors can stake across the courts.\\n    uint256 public totalStaked; // The amount of PNK that is currently staked across the courts.\\n\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /// @notice Emitted when a juror stakes in a court.\\n    /// @param _address The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _amount The amount of tokens staked in the court.\\n    /// @param _amountAllCourts The amount of tokens staked in all courts.\\n    event StakeSet(address indexed _address, uint256 _courtID, uint256 _amount, uint256 _amountAllCourts);\\n\\n    /// @notice Emitted when a juror's stake is delayed.\\n    /// @param _address The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _amount The amount of tokens staked in the court.\\n    event StakeDelayed(address indexed _address, uint96 indexed _courtID, uint256 _amount);\\n\\n    /// @notice Emitted when a juror's stake is delayed execution fails.\\n    /// @param _address The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _amount The amount of tokens staked in the court.\\n    event StakeDelayedExecutionFailed(address indexed _address, uint96 indexed _courtID, uint256 _amount);\\n\\n    /// @notice Emitted when a juror's stake is locked.\\n    /// @param _address The address of the juror.\\n    /// @param _relativeAmount The amount of tokens locked.\\n    /// @param _unlock Whether the stake is locked or unlocked.\\n    event StakeLocked(address indexed _address, uint256 _relativeAmount, bool _unlock);\\n\\n    /// @notice Emitted when leftover PNK is available.\\n    /// @param _account The account of the juror.\\n    /// @param _amount The amount of PNK available.\\n    event LeftoverPNK(address indexed _account, uint256 _amount);\\n\\n    /// @notice Emitted when leftover PNK is withdrawn.\\n    /// @param _account The account of the juror withdrawing PNK.\\n    /// @param _amount The amount of PNK withdrawn.\\n    event LeftoverPNKWithdrawn(address indexed _account, uint256 _amount);\\n\\n    // ************************************* //\\n    // *            Constructor            * //\\n    // ************************************* //\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice Initializer (constructor equivalent for upgradable contracts).\\n    /// @param _owner The owner.\\n    /// @param _core The KlerosCore.\\n    /// @param _minStakingTime Minimal time to stake\\n    /// @param _maxDrawingTime Time after which the drawing phase can be switched\\n    /// @param _rng The random number generator.\\n    /// @param _maxStakePerJuror The maximum amount of PNK a juror can stake across the courts.\\n    /// @param _maxTotalStaked The maximum amount of PNK that all the jurors can stake across the courts.\\n    function initialize(\\n        address _owner,\\n        KlerosCore _core,\\n        uint256 _minStakingTime,\\n        uint256 _maxDrawingTime,\\n        IRNG _rng,\\n        uint256 _maxStakePerJuror,\\n        uint256 _maxTotalStaked\\n    ) external initializer {\\n        owner = _owner;\\n        core = _core;\\n        minStakingTime = _minStakingTime;\\n        maxDrawingTime = _maxDrawingTime;\\n        lastPhaseChange = block.timestamp;\\n        rng = _rng;\\n        maxStakePerJuror = _maxStakePerJuror;\\n        maxTotalStaked = _maxTotalStaked;\\n        delayedStakeReadIndex = 1;\\n    }\\n\\n    // ************************************* //\\n    // *        Function Modifiers         * //\\n    // ************************************* //\\n\\n    modifier onlyByOwner() {\\n        if (owner != msg.sender) revert OwnerOnly();\\n        _;\\n    }\\n\\n    modifier onlyByCore() {\\n        if (address(core) != msg.sender) revert KlerosCoreOnly();\\n        _;\\n    }\\n\\n    // ************************************* //\\n    // *             Governance            * //\\n    // ************************************* //\\n\\n    /// @dev Access Control to perform implementation upgrades (UUPS Proxiable)\\n    ///      Only the owner can perform upgrades (`onlyByOwner`)\\n    function _authorizeUpgrade(address) internal view override onlyByOwner {\\n        // NOP\\n    }\\n\\n    /// @notice Changes the owner of the contract.\\n    /// @param _owner The new owner.\\n    function changeOwner(address _owner) external onlyByOwner {\\n        owner = _owner;\\n    }\\n\\n    /// @notice Changes the `minStakingTime` storage variable.\\n    /// @param _minStakingTime The new value for the `minStakingTime` storage variable.\\n    function changeMinStakingTime(uint256 _minStakingTime) external onlyByOwner {\\n        minStakingTime = _minStakingTime;\\n    }\\n\\n    /// @notice Changes the `maxDrawingTime` storage variable.\\n    /// @param _maxDrawingTime The new value for the `maxDrawingTime` storage variable.\\n    function changeMaxDrawingTime(uint256 _maxDrawingTime) external onlyByOwner {\\n        maxDrawingTime = _maxDrawingTime;\\n    }\\n\\n    /// @notice Changes the `rng` storage variable.\\n    /// @param _rng The new random number generator.\\n    function changeRandomNumberGenerator(IRNG _rng) external onlyByOwner {\\n        rng = _rng;\\n        if (phase == Phase.generating) {\\n            rng.requestRandomness();\\n        }\\n    }\\n\\n    /// @notice Changes the `maxStakePerJuror` storage variable.\\n    /// @param _maxStakePerJuror The new `maxStakePerJuror` storage variable.\\n    function changeMaxStakePerJuror(uint256 _maxStakePerJuror) external onlyByOwner {\\n        maxStakePerJuror = _maxStakePerJuror;\\n    }\\n\\n    /// @notice Changes the `maxTotalStaked` storage variable.\\n    /// @param _maxTotalStaked The new `maxTotalStaked` storage variable.\\n    function changeMaxTotalStaked(uint256 _maxTotalStaked) external onlyByOwner {\\n        maxTotalStaked = _maxTotalStaked;\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @inheritdoc ISortitionModule\\n    function passPhase() external override {\\n        if (phase == Phase.staking) {\\n            if (block.timestamp - lastPhaseChange < minStakingTime) revert MinStakingTimeNotPassed();\\n            if (disputesWithoutJurors == 0) revert NoDisputesThatNeedJurors();\\n            rng.requestRandomness();\\n            phase = Phase.generating;\\n        } else if (phase == Phase.generating) {\\n            randomNumber = rng.receiveRandomness();\\n            if (randomNumber == 0) revert RandomNumberNotReady();\\n            phase = Phase.drawing;\\n        } else if (phase == Phase.drawing) {\\n            if (disputesWithoutJurors > 0 && block.timestamp - lastPhaseChange < maxDrawingTime) {\\n                revert DisputesWithoutJurorsAndMaxDrawingTimeNotPassed();\\n            }\\n            phase = Phase.staking;\\n        }\\n\\n        lastPhaseChange = block.timestamp;\\n        emit NewPhase(phase);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function createTree(uint96 _courtID, bytes memory _extraData) external override onlyByCore {\\n        TreeKey key = CourtID.wrap(_courtID).toTreeKey();\\n        uint256 K = _extraDataToTreeK(_extraData);\\n        sortitionSumTrees.createTree(key, K);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function executeDelayedStakes(uint256 _iterations) external override {\\n        if (phase != Phase.staking) revert NotStakingPhase();\\n        if (delayedStakeWriteIndex < delayedStakeReadIndex) revert NoDelayedStakeToExecute();\\n\\n        uint256 actualIterations = (delayedStakeReadIndex + _iterations) - 1 > delayedStakeWriteIndex\\n            ? (delayedStakeWriteIndex - delayedStakeReadIndex) + 1\\n            : _iterations;\\n        uint256 newDelayedStakeReadIndex = delayedStakeReadIndex + actualIterations;\\n\\n        for (uint256 i = delayedStakeReadIndex; i < newDelayedStakeReadIndex; i++) {\\n            DelayedStake storage delayedStake = delayedStakes[i];\\n            if (!core.setStakeBySortitionModule(delayedStake.account, delayedStake.courtID, delayedStake.stake)) {\\n                emit StakeDelayedExecutionFailed(delayedStake.account, delayedStake.courtID, delayedStake.stake);\\n            }\\n            delete delayedStakes[i];\\n        }\\n        delayedStakeReadIndex = newDelayedStakeReadIndex;\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function createDisputeHook(uint256 /*_disputeID*/, uint256 /*_roundID*/) external override onlyByCore {\\n        disputesWithoutJurors++;\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function postDrawHook(uint256 /*_disputeID*/, uint256 /*_roundID*/) external override onlyByCore {\\n        disputesWithoutJurors--;\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function validateStake(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _newStake,\\n        bool _noDelay\\n    ) external override onlyByCore returns (uint256 pnkDeposit, uint256 pnkWithdrawal, StakingResult stakingResult) {\\n        (pnkDeposit, pnkWithdrawal, stakingResult) = _validateStake(_account, _courtID, _newStake, _noDelay);\\n    }\\n\\n    function _validateStake(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _newStake,\\n        bool _noDelay\\n    ) internal returns (uint256 pnkDeposit, uint256 pnkWithdrawal, StakingResult stakingResult) {\\n        Juror storage juror = jurors[_account];\\n        uint256 currentStake = _stakeOf(_account, _courtID);\\n        bool stakeIncrease = _newStake > currentStake;\\n        uint256 stakeChange = stakeIncrease ? _newStake - currentStake : currentStake - _newStake;\\n\\n        uint256 nbCourts = juror.courtIDs.length;\\n        if (currentStake == 0 && nbCourts >= MAX_STAKE_PATHS) {\\n            return (0, 0, StakingResult.CannotStakeInMoreCourts); // Prevent staking beyond MAX_STAKE_PATHS but unstaking is always allowed.\\n        }\\n\\n        if (currentStake == 0 && _newStake == 0) {\\n            return (0, 0, StakingResult.CannotStakeZeroWhenNoStake); // Forbid staking 0 amount when current stake is 0 to avoid flaky behaviour.\\n        }\\n\\n        if (stakeIncrease) {\\n            // Check if the stake increase is within the limits.\\n            if (juror.stakedPnk + stakeChange > maxStakePerJuror || currentStake + stakeChange > maxStakePerJuror) {\\n                return (0, 0, StakingResult.CannotStakeMoreThanMaxStakePerJuror);\\n            }\\n            if (totalStaked + stakeChange > maxTotalStaked) {\\n                return (0, 0, StakingResult.CannotStakeMoreThanMaxTotalStaked);\\n            }\\n        }\\n\\n        if (phase != Phase.staking && !_noDelay) {\\n            // Store the stake change as delayed, to be applied when the phase switches back to Staking.\\n            DelayedStake storage delayedStake = delayedStakes[++delayedStakeWriteIndex];\\n            delayedStake.account = _account;\\n            delayedStake.courtID = _courtID;\\n            delayedStake.stake = _newStake;\\n            emit StakeDelayed(_account, _courtID, _newStake);\\n            return (pnkDeposit, pnkWithdrawal, StakingResult.Delayed);\\n        }\\n\\n        // Current phase is Staking: set stakes.\\n        if (stakeIncrease) {\\n            pnkDeposit = stakeChange;\\n            totalStaked += stakeChange;\\n        } else {\\n            pnkWithdrawal = stakeChange;\\n            uint256 possibleWithdrawal = juror.stakedPnk > juror.lockedPnk ? juror.stakedPnk - juror.lockedPnk : 0;\\n            if (pnkWithdrawal > possibleWithdrawal) {\\n                // Ensure locked tokens remain in the contract. They can only be released during Execution.\\n                pnkWithdrawal = possibleWithdrawal;\\n            }\\n            totalStaked -= pnkWithdrawal;\\n        }\\n        return (pnkDeposit, pnkWithdrawal, StakingResult.Successful);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function setStake(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _pnkDeposit,\\n        uint256 _pnkWithdrawal,\\n        uint256 _newStake\\n    ) external override onlyByCore {\\n        _setStake(_account, _courtID, _pnkDeposit, _pnkWithdrawal, _newStake);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function setStakePenalty(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _penalty\\n    ) external override onlyByCore returns (uint256 pnkBalance, uint256 newCourtStake, uint256 availablePenalty) {\\n        Juror storage juror = jurors[_account];\\n        availablePenalty = _penalty;\\n        newCourtStake = _stakeOf(_account, _courtID);\\n        if (juror.stakedPnk < _penalty) {\\n            availablePenalty = juror.stakedPnk;\\n        }\\n\\n        if (availablePenalty == 0) return (juror.stakedPnk, newCourtStake, 0); // No penalty to apply.\\n\\n        uint256 currentStake = newCourtStake;\\n        uint256 newStake = 0;\\n        if (currentStake >= availablePenalty) {\\n            newStake = currentStake - availablePenalty;\\n        }\\n        _setStake(_account, _courtID, 0, availablePenalty, newStake);\\n        pnkBalance = juror.stakedPnk; // updated by _setStake()\\n        newCourtStake = newStake;\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function setStakeReward(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _reward\\n    ) external override onlyByCore returns (bool success) {\\n        if (_reward == 0) return true; // No reward to add.\\n\\n        uint256 currentStake = _stakeOf(_account, _courtID);\\n        if (currentStake == 0) return false; // Juror has been unstaked, don't increase their stake.\\n\\n        uint256 newStake = currentStake + _reward;\\n        _setStake(_account, _courtID, _reward, 0, newStake);\\n        return true;\\n    }\\n\\n    function _setStake(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _pnkDeposit,\\n        uint256 _pnkWithdrawal,\\n        uint256 _newStake\\n    ) internal {\\n        Juror storage juror = jurors[_account];\\n        if (_pnkDeposit > 0) {\\n            uint256 currentStake = _stakeOf(_account, _courtID);\\n            if (currentStake == 0) {\\n                juror.courtIDs.push(_courtID);\\n            }\\n            // Increase juror's balance by deposited amount.\\n            juror.stakedPnk += _pnkDeposit;\\n        } else {\\n            juror.stakedPnk -= _pnkWithdrawal;\\n            if (_newStake == 0) {\\n                // Cleanup\\n                for (uint256 i = juror.courtIDs.length; i > 0; i--) {\\n                    if (juror.courtIDs[i - 1] == _courtID) {\\n                        juror.courtIDs[i - 1] = juror.courtIDs[juror.courtIDs.length - 1];\\n                        juror.courtIDs.pop();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Update the sortition sum tree.\\n        bytes32 stakePathID = SortitionTrees.toStakePathID(_account, _courtID);\\n        bool finished = false;\\n        uint96 currentCourtID = _courtID;\\n        while (!finished) {\\n            // Tokens are also implicitly staked in parent courts through sortition module to increase the chance of being drawn.\\n            TreeKey key = CourtID.wrap(currentCourtID).toTreeKey();\\n            sortitionSumTrees[key].set(_newStake, stakePathID);\\n            if (currentCourtID == GENERAL_COURT) {\\n                finished = true;\\n            } else {\\n                (currentCourtID, , , , , ) = core.courts(currentCourtID); // Get the parent court.\\n            }\\n        }\\n        emit StakeSet(_account, _courtID, _newStake, juror.stakedPnk);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function lockStake(address _account, uint256 _relativeAmount) external override onlyByCore {\\n        jurors[_account].lockedPnk += _relativeAmount;\\n        emit StakeLocked(_account, _relativeAmount, false);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function unlockStake(address _account, uint256 _relativeAmount) external override onlyByCore {\\n        Juror storage juror = jurors[_account];\\n        juror.lockedPnk -= _relativeAmount;\\n        emit StakeLocked(_account, _relativeAmount, true);\\n\\n        uint256 amount = getJurorLeftoverPNK(_account);\\n        if (amount > 0) {\\n            emit LeftoverPNK(_account, amount);\\n        }\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function forcedUnstakeAllCourts(address _account) external override onlyByCore {\\n        uint96[] memory courtIDs = getJurorCourtIDs(_account);\\n        for (uint256 j = courtIDs.length; j > 0; j--) {\\n            core.setStakeBySortitionModule(_account, courtIDs[j - 1], 0);\\n        }\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function forcedUnstake(address _account, uint96 _courtID) external override onlyByCore {\\n        core.setStakeBySortitionModule(_account, _courtID, 0);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function withdrawLeftoverPNK(address _account) external override {\\n        // Can withdraw the leftover PNK if fully unstaked, has no tokens locked and has positive balance.\\n        // This withdrawal can't be triggered by calling setStake() in KlerosCore because current stake is technically 0, thus it is done via separate function.\\n        uint256 amount = getJurorLeftoverPNK(_account);\\n        if (amount == 0) revert NotEligibleForWithdrawal();\\n        jurors[_account].stakedPnk = 0;\\n        core.transferBySortitionModule(_account, amount);\\n        emit LeftoverPNKWithdrawn(_account, amount);\\n    }\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @inheritdoc ISortitionModule\\n    function draw(\\n        uint96 _courtID,\\n        uint256 _coreDisputeID,\\n        uint256 _nonce\\n    ) public view override returns (address drawnAddress, uint96 fromSubcourtID) {\\n        if (phase != Phase.drawing) revert NotDrawingPhase();\\n\\n        TreeKey key = CourtID.wrap(_courtID).toTreeKey();\\n        (drawnAddress, fromSubcourtID) = sortitionSumTrees[key].draw(_coreDisputeID, _nonce, randomNumber);\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function getJurorBalance(\\n        address _juror,\\n        uint96 _courtID\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 totalStakedPnk, uint256 totalLocked, uint256 stakedInCourt, uint256 nbCourts)\\n    {\\n        Juror storage juror = jurors[_juror];\\n        totalStakedPnk = juror.stakedPnk;\\n        totalLocked = juror.lockedPnk;\\n        stakedInCourt = _stakeOf(_juror, _courtID);\\n        nbCourts = juror.courtIDs.length;\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function getJurorCourtIDs(address _juror) public view override returns (uint96[] memory) {\\n        return jurors[_juror].courtIDs;\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function isJurorStaked(address _juror) external view override returns (bool) {\\n        return jurors[_juror].stakedPnk > 0;\\n    }\\n\\n    /// @inheritdoc ISortitionModule\\n    function getJurorLeftoverPNK(address _juror) public view override returns (uint256) {\\n        Juror storage juror = jurors[_juror];\\n        if (juror.courtIDs.length == 0 && juror.lockedPnk == 0) {\\n            return juror.stakedPnk;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *            Internal               * //\\n    // ************************************* //\\n\\n    /// @notice Get the stake of a juror in a court.\\n    /// @param _juror The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @return value The stake of the juror in the court.\\n    function _stakeOf(address _juror, uint96 _courtID) internal view returns (uint256) {\\n        bytes32 stakePathID = SortitionTrees.toStakePathID(_juror, _courtID);\\n        TreeKey key = CourtID.wrap(_courtID).toTreeKey();\\n        return sortitionSumTrees[key].stakeOf(stakePathID);\\n    }\\n\\n    /// @notice Converts sortition extradata into K value of sortition tree.\\n    /// @param _extraData Sortition extra data.\\n    /// @return K The value of K.\\n    function _extraDataToTreeK(bytes memory _extraData) internal pure returns (uint256 K) {\\n        if (_extraData.length >= 32) {\\n            assembly {\\n                // solium-disable-line security/no-inline-assembly\\n                K := mload(add(_extraData, 0x20))\\n            }\\n        } else {\\n            K = DEFAULT_K;\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *              Errors               * //\\n    // ************************************* //\\n\\n    error OwnerOnly();\\n    error KlerosCoreOnly();\\n    error MinStakingTimeNotPassed();\\n    error NoDisputesThatNeedJurors();\\n    error RandomNumberNotReady();\\n    error DisputesWithoutJurorsAndMaxDrawingTimeNotPassed();\\n    error NotStakingPhase();\\n    error NoDelayedStakeToExecute();\\n    error NotEligibleForWithdrawal();\\n    error NotDrawingPhase();\\n}\\n\",\"keccak256\":\"0x4811eedb6c858e891ba7f6b799de9427f02fc2c5b38671ff39ddec41c1720d45\",\"license\":\"MIT\"},\"src/arbitration/interfaces/IArbitrableV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IArbitratorV2} from \\\"./IArbitratorV2.sol\\\";\\n\\n/// @title IArbitrableV2\\n/// @notice Arbitrable interface.\\n/// @dev When developing arbitrable contracts, we need to:\\n/// - Define the action taken when a ruling is received by the contract.\\n/// - Allow dispute creation which calls `arbitrator.createDispute{value: _fee}(_choices,_extraData)`.\\ninterface IArbitrableV2 {\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /// @notice To be emitted when a dispute is created to link the correct template to the disputeID.\\n    /// @param _arbitrator The arbitrator of the contract.\\n    /// @param _arbitratorDisputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _templateId The identifier of the dispute template.\\n    event DisputeRequest(IArbitratorV2 indexed _arbitrator, uint256 indexed _arbitratorDisputeID, uint256 _templateId);\\n\\n    /// @notice To be raised when a ruling is given.\\n    /// @param _arbitrator The arbitrator giving the ruling.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling The ruling which was given.\\n    event Ruling(IArbitratorV2 indexed _arbitrator, uint256 indexed _disputeID, uint256 _ruling);\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Give a ruling for a dispute.\\n    ///\\n    /// @dev This is a callback function for the arbitrator to provide the ruling to this contract.\\n    /// Only the arbitrator must be allowed to call this function.\\n    /// Ruling 0 is reserved for \\\"Not able/wanting to make a decision\\\".\\n    ///\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling Ruling given by the arbitrator.\\n    function rule(uint256 _disputeID, uint256 _ruling) external;\\n}\\n\",\"keccak256\":\"0x97c6455e4b9f57e76f338f43eea612ea47ac933dda85c08ef29d418e34879a9b\",\"license\":\"MIT\"},\"src/arbitration/interfaces/IArbitratorV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IArbitrableV2} from \\\"./IArbitrableV2.sol\\\";\\n\\n/// @title Arbitrator\\n/// @notice Arbitrator interface for the Kleros V2 protocol.\\n/// @dev Unlike the ERC-792 this standard is not concerned with appeals, so each arbitrator can implement an appeal system that suits it the most.\\ninterface IArbitratorV2 {\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /// @notice To be emitted when a dispute is created.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _arbitrable The contract which created the dispute.\\n    event DisputeCreation(uint256 indexed _disputeID, IArbitrableV2 indexed _arbitrable);\\n\\n    /// @notice To be raised when a ruling is given.\\n    /// @param _arbitrable The arbitrable receiving the ruling.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling The ruling which was given.\\n    event Ruling(IArbitrableV2 indexed _arbitrable, uint256 indexed _disputeID, uint256 _ruling);\\n\\n    /// @notice To be emitted when an ERC20 token is added or removed as a method to pay fees.\\n    /// @param _token The ERC20 token.\\n    /// @param _accepted Whether the token is accepted or not.\\n    event AcceptedFeeToken(IERC20 indexed _token, bool indexed _accepted);\\n\\n    /// @notice To be emitted when the fee for a particular ERC20 token is updated.\\n    /// @param _feeToken The ERC20 token.\\n    /// @param _rateInEth The new rate of the fee token in ETH.\\n    /// @param _rateDecimals The new decimals of the fee token rate.\\n    event NewCurrencyRate(IERC20 indexed _feeToken, uint64 _rateInEth, uint8 _rateDecimals);\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Create a dispute and pay for the fees in the native currency, typically ETH.\\n    /// @dev Must be called by the arbitrable contract and pay at least `arbitrationCost(_extraData)` in ETH.\\n    /// @param _numberOfChoices The number of choices the arbitrator can choose from in this dispute.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @return disputeID The identifier of the dispute created.\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData\\n    ) external payable returns (uint256 disputeID);\\n\\n    /// @notice Create a dispute and pay for the fees in a supported ERC20 token.\\n    /// @dev Must be called by the arbitrable contract and pay at least `arbitrationCost(_extraData, _feeToken)` in the supported ERC20 token.\\n    /// @param _numberOfChoices The number of choices the arbitrator can choose from in this dispute.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @param _feeToken The ERC20 token used to pay fees.\\n    /// @param _feeAmount Amount of the ERC20 token used to pay fees.\\n    /// @return disputeID The identifier of the dispute created.\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData,\\n        IERC20 _feeToken,\\n        uint256 _feeAmount\\n    ) external returns (uint256 disputeID);\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @notice Compute the cost of arbitration denominated in the native currency, typically ETH.\\n    /// @dev It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @return cost The arbitration cost in ETH.\\n    function arbitrationCost(bytes calldata _extraData) external view returns (uint256 cost);\\n\\n    /// @notice Compute the cost of arbitration denominated in `_feeToken`.\\n    /// @dev It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @param _feeToken The ERC20 token used to pay fees.\\n    /// @return cost The arbitration cost in `_feeToken`.\\n    function arbitrationCost(bytes calldata _extraData, IERC20 _feeToken) external view returns (uint256 cost);\\n\\n    /// @notice Gets the current ruling of a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return ruling The current ruling.\\n    /// @return tied Whether it's a tie or not.\\n    /// @return overridden Whether the ruling was overridden by appeal funding or not.\\n    function currentRuling(uint256 _disputeID) external view returns (uint256 ruling, bool tied, bool overridden);\\n}\\n\",\"keccak256\":\"0x1f4e84e23034f3a291e305e8c69f283c9c97354a49a24f8c02ca366b3eaae00f\",\"license\":\"MIT\"},\"src/arbitration/interfaces/IDisputeKit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport {IArbitratorV2} from \\\"./IArbitratorV2.sol\\\";\\n\\n/// @title IDisputeKit\\n/// @notice An abstraction of the Dispute Kits intended for interfacing with KlerosCore.\\n/// @dev It does not intend to abstract the interactions with the user (such as voting or appeal funding) to allow for implementation-specific parameters.\\ninterface IDisputeKit {\\n    // ************************************ //\\n    // *             Events               * //\\n    // ************************************ //\\n\\n    /// @notice Emitted when casting a vote to provide the justification of juror's choice.\\n    /// @param _coreDisputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _juror Address of the juror.\\n    /// @param _voteIDs The identifiers of the votes in the dispute.\\n    /// @param _choice The choice juror voted for.\\n    /// @param _justification Justification of the choice.\\n    event VoteCast(\\n        uint256 indexed _coreDisputeID,\\n        address indexed _juror,\\n        uint256[] _voteIDs,\\n        uint256 indexed _choice,\\n        string _justification\\n    );\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Creates a local dispute and maps it to the dispute ID in the Core contract.\\n    /// @dev Access restricted to Kleros Core only.\\n    /// @dev The new `KlerosCore.Round` must be created before calling this function.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @param _numberOfChoices Number of choices of the dispute\\n    /// @param _extraData Additional info about the dispute, for possible use in future dispute kits.\\n    /// @param _nbVotes Maximal number of votes this dispute can get. Added for future-proofing.\\n    function createDispute(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData,\\n        uint256 _nbVotes\\n    ) external;\\n\\n    /// @notice Draws the juror from the sortition tree. The drawn address is picked up by Kleros Core.\\n    /// @dev Access restricted to Kleros Core only.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _nonce Nonce.\\n    /// @param _roundNbVotes The number of votes in the round, including already drawn and yet to be drawn.\\n    /// @return drawnAddress The drawn address.\\n    /// @return fromSubcourtID The subcourt ID from which the juror was drawn.\\n    function draw(\\n        uint256 _coreDisputeID,\\n        uint256 _nonce,\\n        uint256 _roundNbVotes\\n    ) external returns (address drawnAddress, uint96 fromSubcourtID);\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @notice Gets the current ruling of a specified dispute.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return ruling The current ruling.\\n    /// @return tied Whether it's a tie or not.\\n    /// @return overridden Whether the ruling was overridden by appeal funding or not.\\n    function currentRuling(uint256 _coreDisputeID) external view returns (uint256 ruling, bool tied, bool overridden);\\n\\n    /// @notice Gets the degree of coherence of a particular voter.\\n    /// @dev This function is called by Kleros Core in order to determine the amount of the reward.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @param _voteID The ID of the vote.\\n    /// @param _feePerJuror The fee per juror.\\n    /// @param _pnkAtStakePerJuror The PNK at stake per juror.\\n    /// @return pnkCoherence The degree of coherence in basis points for the dispute PNK reward.\\n    /// @return feeCoherence The degree of coherence in basis points for the dispute fee reward.\\n    function getDegreeOfCoherenceReward(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _voteID,\\n        uint256 _feePerJuror,\\n        uint256 _pnkAtStakePerJuror\\n    ) external view returns (uint256 pnkCoherence, uint256 feeCoherence);\\n\\n    /// @notice Gets the degree of coherence of a particular voter.\\n    /// @dev This function is called by Kleros Core in order to determine the amount of the penalty.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @param _voteID The ID of the vote.\\n    /// @param _feePerJuror The fee per juror.\\n    /// @param _pnkAtStakePerJuror The PNK at stake per juror.\\n    /// @return pnkCoherence The degree of coherence in basis points for the dispute PNK reward.\\n    function getDegreeOfCoherencePenalty(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _voteID,\\n        uint256 _feePerJuror,\\n        uint256 _pnkAtStakePerJuror\\n    ) external view returns (uint256 pnkCoherence);\\n\\n    /// @notice Gets the number of jurors who are eligible to a reward in this round.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @return The number of coherent jurors.\\n    function getCoherentCount(uint256 _coreDisputeID, uint256 _coreRoundID) external view returns (uint256);\\n\\n    /// @notice Returns true if all of the jurors have cast their commits for the last round.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return Whether all of the jurors have cast their commits for the last round.\\n    function areCommitsAllCast(uint256 _coreDisputeID) external view returns (bool);\\n\\n    /// @notice Returns true if all of the jurors have cast their votes for the last round.\\n    /// @dev This function is to be called directly by the core contract and is not for off-chain usage.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return Whether all of the jurors have cast their votes for the last round.\\n    function areVotesAllCast(uint256 _coreDisputeID) external view returns (bool);\\n\\n    /// @notice Returns true if the appeal funding is finished prematurely (e.g. when losing side didn't fund).\\n    /// @dev This function is to be called directly by the core contract and is not for off-chain usage.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return Whether the appeal funding is finished.\\n    function isAppealFunded(uint256 _coreDisputeID) external view returns (bool);\\n\\n    /// @notice Returns the next round settings for a given dispute.\\n    /// @dev This function does not check for compatibility between `newDisputeKitID` and `newCourtID`, this is the Core's responsibility.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _currentCourtID The ID of the current court.\\n    /// @param _parentCourtID The ID of the parent court.\\n    /// @param _currentCourtJurorsForJump The court jump threshold defined by the current court.\\n    /// @param _currentDisputeKitID The ID of the current dispute kit.\\n    /// @param _currentRoundNbVotes The number of votes in the current round.\\n    /// @return newCourtID Court ID after jump.\\n    /// @return newDisputeKitID Dispute kit ID after jump.\\n    /// @return newRoundNbVotes The number of votes in the new round.\\n    function getNextRoundSettings(\\n        uint256 _coreDisputeID,\\n        uint96 _currentCourtID,\\n        uint96 _parentCourtID,\\n        uint256 _currentCourtJurorsForJump,\\n        uint256 _currentDisputeKitID,\\n        uint256 _currentRoundNbVotes\\n    ) external view returns (uint96 newCourtID, uint256 newDisputeKitID, uint256 newRoundNbVotes);\\n\\n    /// @notice Returns true if the specified voter was active in this round.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @param _voteID The ID of the voter.\\n    /// @return Whether the voter was active or not.\\n    function isVoteActive(uint256 _coreDisputeID, uint256 _coreRoundID, uint256 _voteID) external view returns (bool);\\n\\n    /// @notice Returns the info of the specified round in the core contract.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @param _choice The choice to query.\\n    /// @return winningChoice The winning choice of this round.\\n    /// @return tied Whether it's a tie or not.\\n    /// @return totalVoted Number of jurors who cast the vote already.\\n    /// @return totalCommited Number of jurors who cast the commit already (only relevant for hidden votes).\\n    /// @return nbVoters Total number of voters in this round.\\n    /// @return choiceCount Number of votes cast for the queried choice.\\n    function getRoundInfo(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _choice\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 winningChoice,\\n            bool tied,\\n            uint256 totalVoted,\\n            uint256 totalCommited,\\n            uint256 nbVoters,\\n            uint256 choiceCount\\n        );\\n\\n    /// @notice Returns the vote information for a given vote ID.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core.\\n    /// @param _coreRoundID The ID of the round in Kleros Core.\\n    /// @param _voteID The ID of the vote.\\n    /// @return account The address of the juror who cast the vote.\\n    /// @return commit The commit of the vote.\\n    /// @return choice The choice that got the vote.\\n    /// @return voted Whether the vote was cast or not.\\n    function getVoteInfo(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _voteID\\n    ) external view returns (address account, bytes32 commit, uint256 choice, bool voted);\\n}\\n\",\"keccak256\":\"0xc98a440fb9cb5ca84a5239ec74da11f7ba35b92e96a7dc46364eba5159df087f\",\"license\":\"MIT\"},\"src/arbitration/interfaces/ISortitionModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"../../libraries/Constants.sol\\\";\\n\\n/// @title ISortitionModule\\n/// @notice Interface for the SortitionModule contract.\\ninterface ISortitionModule {\\n    // ************************************* //\\n    // *              Enums                * //\\n    // ************************************* //\\n\\n    enum Phase {\\n        staking, // Stake sum trees can be updated. Pass after `minStakingTime` passes and there is at least one dispute without jurors.\\n        generating, // Waiting for a random number. Pass as soon as it is ready.\\n        drawing // Jurors can be drawn. Pass after all disputes have jurors or `maxDrawingTime` passes.\\n    }\\n\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /// @notice Emitted when the phase is changed.\\n    /// @param _phase The new phase.\\n    event NewPhase(Phase _phase);\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Passes the phase.\\n    function passPhase() external;\\n\\n    /// @notice Executes the next delayed stakes.\\n    /// @param _iterations The number of delayed stakes to execute.\\n    function executeDelayedStakes(uint256 _iterations) external;\\n\\n    /// @notice Create a sortition sum tree at the specified key.\\n    /// @param _courtID The ID of the court.\\n    /// @param _extraData Extra data that contains the number of children each node in the tree should have.\\n    function createTree(uint96 _courtID, bytes memory _extraData) external;\\n\\n    /// @notice Validate the specified juror's new stake for a court.\\n    /// @dev No state changes should be made when returning stakingResult != Successful, otherwise delayed stakes might break invariants.\\n    /// @param _account The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _newStake The new stake.\\n    /// @param _noDelay True if the stake change should not be delayed.\\n    /// @return pnkDeposit The amount of PNK to be deposited.\\n    /// @return pnkWithdrawal The amount of PNK to be withdrawn.\\n    /// @return stakingResult The result of the staking operation.\\n    function validateStake(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _newStake,\\n        bool _noDelay\\n    ) external returns (uint256 pnkDeposit, uint256 pnkWithdrawal, StakingResult stakingResult);\\n\\n    /// @notice Update the state of the stakes, called by KC at the end of setStake flow.\\n    ///\\n    /// @dev `O(n + p * log_k(j))` where\\n    /// `n` is the number of courts the juror has staked in,\\n    /// `p` is the depth of the court tree,\\n    /// `k` is the minimum number of children per node of one of these courts' sortition sum tree,\\n    /// and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\\n    ///\\n    /// @param _account The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _pnkDeposit The amount of PNK to be deposited.\\n    /// @param _pnkWithdrawal The amount of PNK to be withdrawn.\\n    /// @param _newStake The new stake.\\n    function setStake(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _pnkDeposit,\\n        uint256 _pnkWithdrawal,\\n        uint256 _newStake\\n    ) external;\\n\\n    /// @notice Update the state of the stakes with a PNK penalty, called by KC during rewards execution.\\n    ///\\n    /// @dev `O(n + p * log_k(j))` where\\n    /// `n` is the number of courts the juror has staked in,\\n    /// `p` is the depth of the court tree,\\n    /// `k` is the minimum number of children per node of one of these courts' sortition sum tree,\\n    /// and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\\n    ///\\n    /// @param _account The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _penalty The amount of PNK to be deducted.\\n    /// @return pnkBalance The updated total PNK balance of the juror, including the penalty.\\n    /// @return newCourtStake The updated stake of the juror in the court.\\n    /// @return availablePenalty The amount of PNK that was actually deducted.\\n    function setStakePenalty(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _penalty\\n    ) external returns (uint256 pnkBalance, uint256 newCourtStake, uint256 availablePenalty);\\n\\n    /// @notice Update the state of the stakes with a PNK reward deposit, called by KC during rewards execution.\\n    ///\\n    /// @dev `O(n + p * log_k(j))` where\\n    /// `O(n + p * log_k(j))` where\\n    /// `n` is the number of courts the juror has staked in,\\n    /// `p` is the depth of the court tree,\\n    /// `k` is the minimum number of children per node of one of these courts' sortition sum tree,\\n    /// and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\\n    ///\\n    /// @param _account The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _reward The amount of PNK to be deposited as a reward.\\n    /// @return success True if the reward was added successfully.\\n    function setStakeReward(address _account, uint96 _courtID, uint256 _reward) external returns (bool success);\\n\\n    /// @notice Unstakes the inactive juror from all courts.\\n    ///\\n    /// @dev `O(n * (p * log_k(j)) )` where\\n    /// `O(n * (p * log_k(j)) )` where\\n    /// `n` is the number of courts the juror has staked in,\\n    /// `p` is the depth of the court tree,\\n    /// `k` is the minimum number of children per node of one of these courts' sortition sum tree,\\n    /// and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\\n    ///\\n    /// @param _account The juror to unstake.\\n    function forcedUnstakeAllCourts(address _account) external;\\n\\n    /// @notice Unstakes the inactive juror from a specific court.\\n    ///\\n    /// @dev `O(n * (p * log_k(j)) )` where\\n    /// `n` is the number of courts the juror has staked in,\\n    /// `p` is the depth of the court tree,\\n    /// `k` is the minimum number of children per node of one of these courts' sortition sum tree,\\n    /// and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\\n    ///\\n    /// @param _account The juror to unstake.\\n    /// @param _courtID The ID of the court.\\n    function forcedUnstake(address _account, uint96 _courtID) external;\\n\\n    /// @notice Locks the tokens of the drawn juror.\\n    /// @param _account The address of the juror.\\n    /// @param _relativeAmount The amount to lock.\\n    function lockStake(address _account, uint256 _relativeAmount) external;\\n\\n    /// @notice Unlocks the tokens of the drawn juror.\\n    /// @param _account The address of the juror.\\n    /// @param _relativeAmount The amount to unlock.\\n    function unlockStake(address _account, uint256 _relativeAmount) external;\\n\\n    /// @notice Triggers the state changes after dispute creation.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _roundID The ID of the round.\\n    function createDisputeHook(uint256 _disputeID, uint256 _roundID) external;\\n\\n    /// @notice Triggers the state changes after drawing.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _roundID The ID of the round.\\n    function postDrawHook(uint256 _disputeID, uint256 _roundID) external;\\n\\n    /// @notice Gives back the locked PNKs in case the juror fully unstaked earlier.\\n    ///\\n    /// @dev that since locked and staked PNK are async it is possible for the juror to have positive staked PNK balance\\n    /// while having 0 stake in courts and 0 locked tokens (eg. when the juror fully unstaked during dispute and later got his tokens unlocked).\\n    /// In this case the juror can use this function to withdraw the leftover tokens.\\n    /// Also note that if the juror has some leftover PNK while not fully unstaked he'll have to manually unstake from all courts to trigger this function.\\n    ///\\n    /// @param _account The juror whose PNK to withdraw.\\n    function withdrawLeftoverPNK(address _account) external;\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @notice Draw an ID from a tree using a number.\\n    ///\\n    /// @dev that this function reverts if the sum of all values in the tree is 0.\\n    /// `O(k * log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    ///\\n    /// @param _courtID The ID of the court.\\n    /// @param _coreDisputeID Index of the dispute in Kleros Core.\\n    /// @param _nonce Nonce to hash with random number.\\n    /// @return drawnAddress The drawn address.\\n    function draw(\\n        uint96 _courtID,\\n        uint256 _coreDisputeID,\\n        uint256 _nonce\\n    ) external view returns (address drawnAddress, uint96 fromSubcourtID);\\n\\n    /// @notice Gets the balance of a juror in a court.\\n    /// @param _juror The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @return totalStakedPnk The total amount of tokens staked including locked tokens and penalty deductions. Equivalent to the effective stake in the General court.\\n    /// @return totalLocked The total amount of tokens locked in disputes.\\n    /// @return stakedInCourt The amount of tokens staked in the specified court including locked tokens and penalty deductions.\\n    /// @return nbCourts The number of courts the juror has directly staked in.\\n    function getJurorBalance(\\n        address _juror,\\n        uint96 _courtID\\n    ) external view returns (uint256 totalStakedPnk, uint256 totalLocked, uint256 stakedInCourt, uint256 nbCourts);\\n\\n    /// @notice Gets the court identifiers where a specific `_juror` has staked.\\n    /// @param _juror The address of the juror.\\n    function getJurorCourtIDs(address _juror) external view returns (uint96[] memory);\\n\\n    /// @notice Checks if the juror is staked in any court.\\n    /// @param _juror The address of the juror.\\n    /// @return Whether the juror is staked or not.\\n    function isJurorStaked(address _juror) external view returns (bool);\\n\\n    /// @notice Checks if the juror has any leftover PNK in the contract.\\n    /// @param _juror The address of the juror.\\n    /// @return Whether the juror has leftover PNK.\\n    function getJurorLeftoverPNK(address _juror) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x8c496356cb0e45d2b9dd634502f3cba566b45f73ee4836e3cf14523f36d509de\",\"license\":\"MIT\"},\"src/libraries/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// Courts\\nuint96 constant FORKING_COURT = 0; // Index of the forking court.\\nuint96 constant GENERAL_COURT = 1; // Index of the default (general) court.\\n\\n// Dispute Kits\\nuint256 constant NULL_DISPUTE_KIT = 0; // Null pattern to indicate a top-level DK which has no parent.\\nuint256 constant DISPUTE_KIT_CLASSIC = 1; // Index of the default DK. 0 index is skipped.\\n\\n// Sortition Module\\nuint256 constant MAX_STAKE_PATHS = 4; // The maximum number of stake paths a juror can have.\\nuint256 constant DEFAULT_K = 6; // Default number of children per node.\\n\\n// Defaults\\nuint256 constant DEFAULT_NB_OF_JURORS = 3; // The default number of jurors in a dispute.\\nIERC20 constant NATIVE_CURRENCY = IERC20(address(0)); // The native currency, such as ETH on Arbitrum, Optimism and Ethereum L1.\\n\\n// Units\\nuint256 constant ONE_BASIS_POINT = 10000;\\n\\nenum OnError {\\n    Revert,\\n    Return\\n}\\n\\nenum StakingResult {\\n    Successful,\\n    Delayed,\\n    StakingTransferFailed,\\n    UnstakingTransferFailed,\\n    CannotStakeInMoreCourts,\\n    CannotStakeInThisCourt,\\n    CannotStakeLessThanMinStake,\\n    CannotStakeMoreThanMaxStakePerJuror,\\n    CannotStakeMoreThanMaxTotalStaked,\\n    CannotStakeZeroWhenNoStake\\n}\\n\",\"keccak256\":\"0xf68cd60ac5c0eeeec229cd1b5170eedd61ada49a6d1a8d5abefa89d8a0beea6f\",\"license\":\"MIT\"},\"src/libraries/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a7a94c77463acea95d979aae1580fb0ddc3b6a1e/contracts/token/ERC20/utils/SafeERC20.sol\\n\\npragma solidity ^0.8.24;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title SafeERC20\\n///\\n/// @notice Wrappers around ERC20 operations\\n///\\n/// @dev Throws on failure (when the token contract returns false).\\n/// Tokens that return no value (and instead revert or throw on failure) are also supported.\\n/// Non-reverting calls are assumed to be successful.\\n/// To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n/// which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\nlibrary SafeERC20 {\\n    /// @notice Increases the allowance granted to `spender` by the caller.\\n    /// @param _token Token to transfer.\\n    /// @param _spender The address which will spend the funds.\\n    /// @param _addedValue The amount of tokens to increase the allowance by.\\n    function increaseAllowance(IERC20 _token, address _spender, uint256 _addedValue) internal returns (bool) {\\n        _token.approve(_spender, _token.allowance(address(this), _spender) + _addedValue);\\n        return true;\\n    }\\n\\n    /// @notice Calls transfer() without reverting.\\n    /// @param _token Token to transfer.\\n    /// @param _to Recipient address.\\n    /// @param _value Amount transferred.\\n    /// @return Whether transfer succeeded or not.\\n    function safeTransfer(IERC20 _token, address _to, uint256 _value) internal returns (bool) {\\n        (bool success, bytes memory data) = address(_token).call(abi.encodeCall(IERC20.transfer, (_to, _value)));\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    /// @notice Calls transferFrom() without reverting.\\n    /// @param _token Token to transfer.\\n    /// @param _from Sender address.\\n    /// @param _to Recipient address.\\n    /// @param _value Amount transferred.\\n    /// @return Whether transfer succeeded or not.\\n    function safeTransferFrom(IERC20 _token, address _from, address _to, uint256 _value) internal returns (bool) {\\n        (bool success, bytes memory data) = address(_token).call(\\n            abi.encodeCall(IERC20.transferFrom, (_from, _to, _value))\\n        );\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\",\"keccak256\":\"0xdabca82ba0da72fae8244ed17d2b36ecadceb803e295a687425e55b9f970cd43\",\"license\":\"MIT\"},\"src/libraries/SafeSend.sol\":{\"content\":\"/**\\n * @custom:authors: [@andreimvp]\\n * @custom:reviewers: [@divyangchauhan, @wadader, @fcanela, @unknownunknown1]\\n * @custom:auditors: []\\n * @custom:bounties: []\\n * SPDX-License-Identifier: MIT\\n */\\n\\npragma solidity ^0.8.24;\\n\\ninterface WethLike {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external;\\n}\\n\\nlibrary SafeSend {\\n    function safeSend(address payable _to, uint256 _value, address _wethLike) internal {\\n        if (_to.send(_value)) return;\\n\\n        WethLike(_wethLike).deposit{value: _value}();\\n        WethLike(_wethLike).transfer(_to, _value); /// forge-lint: disable-line(erc20-unchecked-transfer)\\n    }\\n}\\n\",\"keccak256\":\"0x70dd026ee58f3b095095e9cf20f6e01cc31c1165f3ec28d18ed90921c5ef7355\",\"license\":\"MIT\"},\"src/libraries/SortitionTrees.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\ntype TreeKey is bytes32;\\ntype CourtID is uint96;\\n\\nusing {SortitionTrees.toTreeKey} for CourtID global;\\n\\nlibrary SortitionTrees {\\n    // ************************************* //\\n    // *         Enums / Structs           * //\\n    // ************************************* //\\n\\n    struct Tree {\\n        uint256 K; // The maximum number of children per node.\\n        uint256[] stack; // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\\n        uint256[] nodes; // The tree nodes.\\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\\n        mapping(bytes32 stakePathID => uint256 nodeIndex) IDsToNodeIndexes;\\n        mapping(uint256 nodeIndex => bytes32 stakePathID) nodeIndexesToIDs;\\n    }\\n\\n    function toTreeKey(CourtID _courtID) internal pure returns (TreeKey) {\\n        return TreeKey.wrap(bytes32(uint256(CourtID.unwrap(_courtID))));\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Create a sortition sum tree at the specified key.\\n    /// @param _trees The mapping of sortition sum trees.\\n    /// @param _key The key of the new tree.\\n    /// @param _k The maximum number of children per node.\\n    function createTree(mapping(TreeKey key => Tree) storage _trees, TreeKey _key, uint256 _k) internal {\\n        Tree storage tree = _trees[_key];\\n        if (tree.K != 0) revert TreeAlreadyExists();\\n        if (_k <= 1) revert KMustBeGreaterThanOne();\\n        tree.K = _k;\\n        tree.nodes.push(0);\\n    }\\n\\n    /// @notice Draw an ID from a tree using a number.\\n    ///\\n    /// @dev `O(k * log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    ///\\n    /// @param _tree The sortition sum tree.\\n    /// @param _coreDisputeID Index of the dispute in Kleros Core.\\n    /// @param _nonce Nonce to hash with random number.\\n    /// @return drawnAddress The drawn address.\\n    function draw(\\n        Tree storage _tree,\\n        uint256 _coreDisputeID,\\n        uint256 _nonce,\\n        uint256 _randomNumber\\n    ) internal view returns (address drawnAddress, uint96 fromSubcourtID) {\\n        if (_tree.nodes[0] == 0) {\\n            return (address(0), 0); // No jurors staked.\\n        }\\n\\n        uint256 currentDrawnNumber = uint256(keccak256(abi.encodePacked(_randomNumber, _coreDisputeID, _nonce))) %\\n            _tree.nodes[0];\\n\\n        // While it still has children\\n        uint256 treeIndex = 0;\\n        while ((_tree.K * treeIndex) + 1 < _tree.nodes.length) {\\n            for (uint256 i = 1; i <= _tree.K; i++) {\\n                // Loop over children.\\n                uint256 nodeIndex = (_tree.K * treeIndex) + i;\\n                uint256 nodeValue = _tree.nodes[nodeIndex];\\n\\n                if (currentDrawnNumber >= nodeValue) {\\n                    // Go to the next child.\\n                    currentDrawnNumber -= nodeValue;\\n                } else {\\n                    // Pick this child.\\n                    treeIndex = nodeIndex;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        bytes32 stakePathID = _tree.nodeIndexesToIDs[treeIndex];\\n        (drawnAddress, fromSubcourtID) = toAccountAndCourtID(stakePathID);\\n    }\\n\\n    /// @notice Set a value in a tree.\\n    ///\\n    /// @dev `O(log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    ///\\n    /// @param _tree The sortition sum tree.\\n    /// @param _value The new value.\\n    /// @param _stakePathID The ID of the value.\\n    function set(Tree storage _tree, uint256 _value, bytes32 _stakePathID) internal {\\n        uint256 treeIndex = _tree.IDsToNodeIndexes[_stakePathID];\\n\\n        if (treeIndex == 0) {\\n            // No existing node.\\n            if (_value != 0) {\\n                // Non zero value.\\n                // Append.\\n                // Add node.\\n                if (_tree.stack.length == 0) {\\n                    // No vacant spots.\\n                    // Get the index and append the value.\\n                    treeIndex = _tree.nodes.length;\\n                    _tree.nodes.push(_value);\\n\\n                    // Potentially append a new node and make the parent a sum node.\\n                    if (treeIndex != 1 && (treeIndex - 1) % _tree.K == 0) {\\n                        // Is first child.\\n                        uint256 parentIndex = treeIndex / _tree.K;\\n                        bytes32 parentID = _tree.nodeIndexesToIDs[parentIndex];\\n                        uint256 newIndex = treeIndex + 1;\\n                        _tree.nodes.push(_tree.nodes[parentIndex]);\\n                        delete _tree.nodeIndexesToIDs[parentIndex];\\n                        _tree.IDsToNodeIndexes[parentID] = newIndex;\\n                        _tree.nodeIndexesToIDs[newIndex] = parentID;\\n                    }\\n                } else {\\n                    // Some vacant spot.\\n                    // Pop the stack and append the value.\\n                    treeIndex = _tree.stack[_tree.stack.length - 1];\\n                    _tree.stack.pop();\\n                    _tree.nodes[treeIndex] = _value;\\n                }\\n\\n                // Add label.\\n                _tree.IDsToNodeIndexes[_stakePathID] = treeIndex;\\n                _tree.nodeIndexesToIDs[treeIndex] = _stakePathID;\\n\\n                updateParents(_tree, treeIndex, true, _value);\\n            }\\n        } else {\\n            // Existing node.\\n            if (_value == 0) {\\n                // Zero value.\\n                // Remove.\\n                // Remember value and set to 0.\\n                uint256 value = _tree.nodes[treeIndex];\\n                _tree.nodes[treeIndex] = 0;\\n\\n                // Push to stack.\\n                _tree.stack.push(treeIndex);\\n\\n                // Clear label.\\n                delete _tree.IDsToNodeIndexes[_stakePathID];\\n                delete _tree.nodeIndexesToIDs[treeIndex];\\n\\n                updateParents(_tree, treeIndex, false, value);\\n            } else if (_value != _tree.nodes[treeIndex]) {\\n                // New, non zero value.\\n                // Set.\\n                bool plusOrMinus = _tree.nodes[treeIndex] <= _value;\\n                uint256 plusOrMinusValue = plusOrMinus\\n                    ? _value - _tree.nodes[treeIndex]\\n                    : _tree.nodes[treeIndex] - _value;\\n                _tree.nodes[treeIndex] = _value;\\n\\n                updateParents(_tree, treeIndex, plusOrMinus, plusOrMinusValue);\\n            }\\n        }\\n    }\\n\\n    /// @notice Update all the parents of a node.\\n    ///\\n    /// @dev `O(log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    ///\\n    /// @param _tree The sortition sum tree.\\n    /// @param _treeIndex The index of the node to start from.\\n    /// @param _plusOrMinus Whether to add (true) or substract (false).\\n    /// @param _value The value to add or substract.\\n    function updateParents(Tree storage _tree, uint256 _treeIndex, bool _plusOrMinus, uint256 _value) private {\\n        uint256 parentIndex = _treeIndex;\\n        while (parentIndex != 0) {\\n            parentIndex = (parentIndex - 1) / _tree.K;\\n            _tree.nodes[parentIndex] = _plusOrMinus\\n                ? _tree.nodes[parentIndex] + _value\\n                : _tree.nodes[parentIndex] - _value;\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @notice Get the stake of a juror in a court.\\n    /// @param _tree The sortition sum tree.\\n    /// @param _stakePathID The stake path ID, corresponding to a juror.\\n    /// @return The stake of the juror in the court.\\n    function stakeOf(Tree storage _tree, bytes32 _stakePathID) internal view returns (uint256) {\\n        uint256 treeIndex = _tree.IDsToNodeIndexes[_stakePathID];\\n        if (treeIndex == 0) {\\n            return 0;\\n        }\\n        return _tree.nodes[treeIndex];\\n    }\\n\\n    /// @notice Packs an account and a court ID into a stake path ID\\n    /// @dev [20 bytes of address][12 bytes of courtID] = 32 bytes total.\\n    /// @param _account The address of the juror to pack.\\n    /// @param _courtID The court ID to pack.\\n    /// @return stakePathID The stake path ID.\\n    function toStakePathID(address _account, uint96 _courtID) internal pure returns (bytes32 stakePathID) {\\n        assembly {\\n            // solium-disable-line security/no-inline-assembly\\n            // Pack address (20 bytes) and courtID (12 bytes) into a single bytes32\\n            stakePathID := or(shl(96, _account), _courtID)\\n        }\\n    }\\n\\n    /// @notice Retrieves both juror's address and court ID from the stake path ID.\\n    /// @param _stakePathID The stake path ID to unpack.\\n    /// @return account The account.\\n    /// @return courtID The court ID.\\n    function toAccountAndCourtID(bytes32 _stakePathID) internal pure returns (address account, uint96 courtID) {\\n        assembly {\\n            // solium-disable-line security/no-inline-assembly\\n            // Unpack address (first 20 bytes) and courtID (last 12 bytes) from the stake path ID\\n            account := shr(96, _stakePathID) // Right shift by 96 bits to get the address\\n            courtID := and(_stakePathID, 0xffffffffffffffffffffffff) // Mask the lower 96 bits to get the court ID\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *              Errors               * //\\n    // ************************************* //\\n\\n    error TreeAlreadyExists();\\n    error KMustBeGreaterThanOne();\\n}\\n\",\"keccak256\":\"0x11333c19487ea42660d21c31b998865aab370883484fdd411324b88d9d6c32f8\",\"license\":\"MIT\"},\"src/proxy/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol) <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/proxy/utils/Initializable.sol>\\n\\npragma solidity ^0.8.24;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to the proxy constructor\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1))\\n    bytes32 private constant _INITIALIZABLE_STORAGE =\\n        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error AlreadyInitialized();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `initializer()`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n        if (!(isTopLevelCall && initialized < 1) && !(address(this).code.length == 0 && initialized == 1)) {\\n            revert AlreadyInitialized();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert AlreadyInitialized();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert AlreadyInitialized();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := _INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdad09e5f773fa6940dbd8c28480f602a7eaa3c70d3da9d06df140187cbf5dad4\",\"license\":\"MIT\"},\"src/proxy/UUPSProxiable.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.24;\\n\\n/// @title UUPS Proxiable\\n/// @author Simon Malatrait <simon.malatrait@grenoble-inp.org>\\n/// @notice This contract implements an upgradeability mechanism designed for UUPS proxies.\\n///\\n/// @dev Adapted from <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.0/contracts/proxy/utils/UUPSUpgradeable.sol>\\n/// The functions included here can perform an upgrade of an UUPS Proxy, when this contract is set as the implementation behind such a proxy.\\n///\\n/// IMPORTANT: A UUPS proxy requires its upgradeability functions to be in the implementation as opposed to the transparent proxy.\\n/// This means that if the proxy is upgraded to an implementation that does not support this interface, it will no longer be upgradeable.\\n///\\n/// A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n/// reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n/// `UUPSProxiable` with a custom implementation of upgrades.\\n///\\n/// The `_authorizeUpgrade` function must be overridden to include access restriction to the upgrade mechanism.\\nabstract contract UUPSProxiable {\\n    // ************************************* //\\n    // *             Event                 * //\\n    // ************************************* //\\n\\n    /// @notice Emitted when the `implementation` has been successfully upgraded.\\n    /// @param newImplementation Address of the new implementation the proxy is now forwarding calls to.\\n    event Upgraded(address indexed newImplementation);\\n\\n    // ************************************* //\\n    // *             Error                 * //\\n    // ************************************* //\\n\\n    /// @notice The call is from an unauthorized context.\\n    error UUPSUnauthorizedCallContext();\\n\\n    /// @notice The storage `slot` is unsupported as a UUID.\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /// @notice The `implementation` is not UUPS-compliant\\n    error InvalidImplementation(address implementation);\\n\\n    /// Failed Delegated call\\n    error FailedDelegateCall();\\n\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    /// @dev Storage slot with the address of the current implementation.\\n    /// @dev This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n    /// @dev validated in the constructor.\\n    /// @dev NOTE: bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @dev Storage variable of the proxiable contract address.\\n    /// @dev It is used to check whether or not the current call is from the proxy.\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    // ************************************* //\\n    // *             Governance            * //\\n    // ************************************* //\\n\\n    /// @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract.\\n    /// @dev Called by {upgradeToAndCall}.\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Upgrade mechanism including access control and UUPS-compliance.\\n    /// @param newImplementation Address of the new implementation contract.\\n    /// @param data Data used in a delegate call to `newImplementation` if non-empty. This will typically be an encoded\\n    /// function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n    /// @dev Reverts if the execution is not performed via delegatecall or the execution\\n    /// context is not of a proxy with an ERC1967-compliant implementation pointing to self.\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual {\\n        _authorizeUpgrade(newImplementation);\\n\\n        // Check that the execution is being performed through a delegatecall call and that the execution context is\\n        // a proxy contract with an implementation (as defined in ERC1967) pointing to self.\\n        if (address(this) == __self || _getImplementation() != __self) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n\\n        try UUPSProxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            // Store the new implementation address to the implementation storage slot.\\n            assembly {\\n                sstore(IMPLEMENTATION_SLOT, newImplementation)\\n            }\\n            emit Upgraded(newImplementation);\\n\\n            if (data.length != 0) {\\n                // The return data is not checked (checking, in case of success, that the newImplementation code is non-empty if the return data is empty) because the authorized callee is trusted.\\n                /// @custom:oz-upgrades-unsafe-allow delegatecall\\n                (bool success, ) = newImplementation.delegatecall(data);\\n                if (!success) {\\n                    revert FailedDelegateCall();\\n                }\\n            }\\n        } catch {\\n            revert InvalidImplementation(newImplementation);\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @notice Implementation of the ERC1822 `proxiableUUID` function. This returns the storage slot used by the\\n    /// implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n    ///\\n    /// @dev IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n    /// bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n    /// function revert if invoked through a proxy. This is guaranteed by the if statement.\\n    function proxiableUUID() external view virtual returns (bytes32) {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n        return IMPLEMENTATION_SLOT;\\n    }\\n\\n    /// @notice Returns the version of the implementation.\\n    /// @return Version string.\\n    function version() external view virtual returns (string memory);\\n\\n    // ************************************* //\\n    // *           Internal Views          * //\\n    // ************************************* //\\n\\n    function _getImplementation() internal view returns (address implementation) {\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_SLOT)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa369061748e8a7b02873d597d4c78a2a09328111f04a97428b1c209e82cf5414\",\"license\":\"MIT\"},\"src/rng/IRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/// @title Random Number Generator interface\\ninterface IRNG {\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @notice Request a random number.\\n    function requestRandomness() external;\\n\\n    /// @notice Receive the random number.\\n    /// @return randomNumber Random number or 0 if not available\\n    function receiveRandomness() external returns (uint256 randomNumber);\\n\\n    // ************************************* //\\n    // *              Errors               * //\\n    // ************************************* //\\n\\n    error OwnerOnly();\\n    error ConsumerOnly();\\n}\\n\",\"keccak256\":\"0x92fdca3f55b0e0d013a13f94e3d8b94d7ee93d84aaad83eaeca49b08c7e37e9c\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a080604052346100c157306080525f516020612fbf5f395f51905f525460ff8160401c166100b3576002600160401b03196001600160401b03821601610060575b604051612ef990816100c68239608051818181610a770152610ca50152f35b6001600160401b0319166001600160401b039081175f516020612fbf5f395f51905f525581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80610041565b62dc149f60e41b5f5260045ffd5b5f80fdfe60806040526004361015610011575f80fd5b5f3560e01c806303432744146102e457806306dfc967146102df5780630b274f2e146102da5780630e083ec9146102d55780631b92bbbe146102d057806321e1625e146102cb57806323f61de4146102c657806335975f4a146102c15780634f1ef286146102bc57806352d1902d146102b7578063543f8a36146102b257806354fd4d50146102ad57806356acb050146102a85780635a68c154146102a35780635d2d78461461029e5780636624192f14610299578063664bffc31461029457806369f458771461028f578063771a27cb1461028a5780637eab309e14610285578063817b1cd214610280578063823cfd701461027b5780638d3771bb146102765780638da5cb5b14610271578063965af6c71461026c5780639d560867146102675780639fbb56f114610262578063a6f9dae11461025d578063aa9ebfb714610258578063aac03ad214610253578063b1c9fe6e1461024e578063b4ebe83814610249578063b888adfa14610244578063c057eca71461023f578063c41bda611461023a578063c70ba3b914610235578063ccbac9f514610230578063d045e0021461022b578063d09f392d14610226578063d1c1df4814610221578063d605787b1461021c578063dca5f6b014610217578063dd5e5cb514610212578063f2f4eb261461020d5763f6b4d82d14610208575f80fd5b611f9d565b611f6a565b611f40565b611ef8565b611ed2565b611e7e565b611e50565b611da4565b611d87565b611d0d565b611c4e565b611c31565b611c14565b611b22565b611afa565b6117ef565b6116d6565b61168c565b61165d565b6115d4565b6114dd565b6114b8565b61148e565b611464565b611447565b61115a565b611118565b610fdd565b610fa4565b610f26565b610ef3565b610ed6565b610eb9565b610e43565b610d37565b610c8b565b610a2d565b610750565b610733565b610693565b610665565b610648565b610366565b610314565b6102f7565b5f9103126102f357565b5f80fd5b346102f3575f3660031901126102f3576020600554604051908152f35b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600d55005b7f596dcdb8000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102f3575f3660031901126102f35760015460a01c60ff1661038881611ad8565b806104dc575061039a60045442612026565b600254116104b4576005541561048c576103cb6103bf6006546001600160a01b031690565b6001600160a01b031690565b803b156102f3575f809160046040518094819363f8413b0760e01b83525af180156104875761046d575b5061041f7401000000000000000000000000000000000000000060ff60a01b196001541617600155565b61042842600455565b7f31f72b44f546d9e7eaec13f65636997665e15f134a81c82924f568f5c0d07b9361046861045c60015460ff9060a01c1690565b60405191829182611ae7565b0390a1005b8061047b5f610481936109a4565b806102e9565b5f6103f5565b612042565b7f1a937bfc000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fbc26f968000000000000000000000000000000000000000000000000000000005f5260045ffd5b6104e581611ad8565b600181036105d857505f60206105066103bf6006546001600160a01b031690565b6004604051809481937f910f03a60000000000000000000000000000000000000000000000000000000083525af180156104875761054b915f916105a9575b50600755565b600754156105815761057c7402000000000000000000000000000000000000000060ff60a01b196001541617600155565b61041f565b7fcba65b92000000000000000000000000000000000000000000000000000000005f5260045ffd5b6105cb915060203d6020116105d1575b6105c381836109a4565b810190612033565b5f610545565b503d6105b9565b806105e4600292611ad8565b0361041f57600554151580610632575b61060a5761057c60ff60a01b1960015416600155565b7f6b249f2f000000000000000000000000000000000000000000000000000000005f5260045ffd5b5061063f60045442612026565b600354116105f4565b346102f3575f3660031901126102f3576020600854604051908152f35b346102f3575f3660031901126102f3576020600354604051908152f35b6001600160a01b038116036102f357565b346102f35760403660031901126102f3576004356106b081610682565b602435906001600160a01b03600154163303610725576001600160a01b031690815f52600b602052600260405f2001805491808301809311610720577f7a81a4ef419d50dbb5deb116fb983bf6ca7716bcbc84cd1cd2be81ccea9078b0926040925581519081525f6020820152a2005b612004565b628448c760e31b5f5260045ffd5b346102f3575f3660031901126102f3576020600d54604051908152f35b346102f35760203660031901126102f35760043560015460a01c60ff1661077681611ad8565b61096857600854600954918282106109405781816107c0936107a161079c87958661205b565b612018565b111561093857506107ba916107b591612026565b61204d565b8261205b565b905b8181106107d4576107d282600955565b005b806107ea610868925f52600c60205260405f2090565b6107ff6103bf6001546001600160a01b031690565b906020815461081e610817826001600160a01b031690565b9160a01c90565b9360018401945f865493604051998a9586948593630761c14d60e01b8552600485016001600160601b036040929594936001600160a01b0360608401971683521660208201520152565b03925af18015610487576001945f9161090a575b50156108ab575b50506108a561089a825f52600c60205260405f2090565b60015f918281550155565b016107c2565b54907fb588834590b84623e5ca8f8a3a808b981214a1f0cba52ddd7fd3bbb6d10c7fe46001600160601b036108ea6001600160a01b0385169460a01c90565b92546040519081529216926001600160a01b031691602090a35f80610883565b61092b915060203d8111610931575b61092381836109a4565b810190612068565b5f61087c565b503d610919565b9150506107ba565b7f3a946f67000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4d269093000000000000000000000000000000000000000000000000000000005f5260045ffd5b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176109c657604052565b610990565b67ffffffffffffffff81116109c657601f01601f191660200190565b81601f820112156102f3578035906109fe826109cb565b92610a0c60405194856109a4565b828452602083830101116102f357815f926020809301838601378301015290565b60403660031901126102f357600435610a4581610682565b60243567ffffffffffffffff81116102f357610a659036906004016109e7565b610a6d612593565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016803014908115610c50575b50610c28576001600160a01b0382166040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481855afa5f9181610c07575b50610b22577f0c760937000000000000000000000000000000000000000000000000000000005f526001600160a01b03841660045260245ffd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8103610bdc5750827f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a2805180610b9a57005b5f926020849301905af4610bac61209a565b5015610bb457005b7f736436ba000000000000000000000000000000000000000000000000000000005f5260045ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b610c2191925060203d6020116105d1576105c381836109a4565b905f610ae8565b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b9050610c837f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b14155f610aa2565b346102f3575f3660031901126102f3576001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610c285760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b60206040818301928281528451809452019201905f5b818110610d185750505090565b82516001600160601b0316845260209384019390920191600101610d0b565b346102f35760203660031901126102f3576001600160a01b03600435610d5c81610682565b165f52600b60205260405f20604051908190610d8b610d818254809560209181520190565b915f5260205f2090565b925f935b816001860110610dfd5791610dc8948492610dbc945491818110610de3575b10610dcc575b5003826109a4565b60405191829182610cf5565b0390f35b60601c6001600160601b031681526020015f610db4565b6001600160601b0383168452926001906020019301610dae565b9160016040600292610e388654610e25836001600160601b0383166001600160601b03169052565b60601c6001600160601b03166020830152565b019301940193610d8f565b346102f3575f3660031901126102f3576040805190610e6281836109a4565b6005825260208201917f322e302e3000000000000000000000000000000000000000000000000000000083528151928391602083525180918160208501528484015e5f828201840152601f01601f19168101030190f35b346102f3575f3660031901126102f3576020600954604051908152f35b346102f3575f3660031901126102f3576020600e54604051908152f35b346102f35760403660031901126102f3576001600160a01b0360015416330361072557610f21600554612178565b600555005b346102f35760203660031901126102f3576001600160a01b03600435610f4b81610682565b165f52600b6020526020600160405f2001541515604051908152f35b6001600160601b038116036102f357565b60609060031901126102f357600435610f9081610682565b90602435610f9d81610f67565b9060443590565b346102f357610fb236610f78565b6001600160a01b0360019392935416330361072557602092610fd392612184565b6040519015158152f35b346102f35760203660031901126102f357600435610ffa81610682565b6110038161251e565b9081156110f0575f6001611028836001600160a01b03165f52600b60205260405f2090565b015561103f6103bf6001546001600160a01b031690565b90813b156102f3576040517f42c37fa30000000000000000000000000000000000000000000000000000000081526001600160a01b038216600482015260248101849052915f908390604490829084905af1908115610487577f71bb1b604559acc3db697ccf2aa4228d727cd5b133d6ffa419518d51c117c95c926001600160a01b03926110dc575b50604051938452169180602081015b0390a2005b8061047b5f6110ea936109a4565b5f6110c8565b7fdc604fd1000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102f35761112636610f78565b6001600160a01b0360019392935416330361072557606092611147926122f7565b9060405192835260208301526040820152f35b346102f35760e03660031901126102f35760043561117781610682565b6024359061118482610682565b60443560643560843561119681610682565b60a4359160c435937ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e54966111e76111d96111d58a60ff9060401c1690565b1590565b9867ffffffffffffffff1690565b8880611433575b15908161140b575b506113fd576112b59688611257600167ffffffffffffffff197ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e5416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e55565b611343576001600160a01b0394939291858092166001600160a01b03195f5416175f55166001600160a01b0319600154161760015560025560035542600455166001600160a01b03196006541617600655600d55600e556001600955565b6112bb57005b61131068ff0000000000000000197ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e54167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e55565b604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2908060208101610468565b6113a36801000000000000000068ff0000000000000000197ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e5416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e55565b6001600160a01b0394939291858092166001600160a01b03195f5416175f55166001600160a01b0319600154161760015560025560035542600455166001600160a01b03196006541617600655600d55600e556001600955565b62dc149f60e41b5f5260045ffd5b303b1591508161141e575b50155f6111f6565b6001915067ffffffffffffffff16145f611416565b50600167ffffffffffffffff8216106111ee565b346102f3575f3660031901126102f3576020600f54604051908152f35b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600255005b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600e55005b346102f3575f3660031901126102f35760206001600160a01b035f5416604051908152f35b346102f35760403660031901126102f3576004356114fa81610682565b6024356001600160a01b03600154163303610725576001600160a01b03821691825f52600b602052600260405f200191825481810390811161072057604085927f7a81a4ef419d50dbb5deb116fb983bf6ca7716bcbc84cd1cd2be81ccea9078b0926115739655815190815260016020820152a261251e565b8061157a57005b6040519081527f819a3744490c627e221b71743857691f9c23bf56a1ecc5351f886cfd4c3187d99080602081016110d7565b60409060031901126102f3576004356115c481610682565b906024356115d181610f67565b90565b346102f3576115e2366115ac565b906001600160a01b03600154169133830361072557604051630761c14d60e01b81526001600160a01b039290921660048301526001600160601b031660248201525f604482018190529091602091839160649183915af180156104875761164557005b6107d29060203d6020116109315761092381836109a4565b346102f35760203660031901126102f357602061168460043561167f81610682565b61251e565b604051908152f35b346102f35760203660031901126102f3576004356116a981610682565b6001600160a01b035f5416330361033e576001600160a01b03166001600160a01b03195f5416175f555f80f35b346102f35760203660031901126102f3576004356116f381610682565b6001600160a01b0360015416330361072557611728611723826001600160a01b03165f52600b60205260405f2090565b6120c9565b8051805b61173257005b5f9060206117b161174e6103bf6001546001600160a01b031690565b61177061176361175d86612018565b8861256c565b516001600160601b031690565b604051958680948193630761c14d60e01b83528b600484016040906001600160601b035f9395946001600160a01b0360608401971683521660208201520152565b03925af1918215610487576117cb926117d1575b50612178565b8061172c565b6117e89060203d81116109315761092381836109a4565b505f6117c5565b346102f35760a03660031901126102f35760043561180c81610682565b6024359061181982610f67565b604435606435608435916001600160a01b0360015416330361072557611850846001600160a01b03165f52600b60205260405f2090565b9181156119e4575061186285856125a6565b156119d5575b6118776001830191825461205b565b90555b83606084901b81175f5b80156118e4576001840154604080516001600160601b038a16815260208101889052908101919091526001600160a01b038716907f70ca4ec64687bf265f39041896f3dbf10b9f650503cb38f2b3569fdce7489c369080606081016110d7565b60016001600160601b03841661191c8488611917611909855b6001600160601b031690565b5f52600a60205260405f2090565b612b54565b0361192957506001611884565b9160c0611989916119456103bf6001546001600160a01b031690565b60405180809581947f1f5a0dd2000000000000000000000000000000000000000000000000000000008352600483019190916001600160601b036020820193169052565b03915afa908115610487575f916119a2575b5091611884565b6119c3915060c03d81116119ce575b6119bb81836109a4565b810190612656565b50505050505f61199b565b503d6119b1565b6119df858361262e565b611868565b90506119f560018301918254612026565b90558161187a579190825492836001600160601b038616945b611a1d575b509091925061187a565b846001600160601b03611a4e611a3b611a3585612018565b866125c9565b90546001600160601b039160031b1c1690565b1614611a6357611a5d90612178565b80611a0e565b8192939450611a93611a8d611a87611a3b611a81611ab29654612018565b876125c9565b92612018565b846125c9565b9091906001600160601b038084549260031b9316831b921b1916179055565b611abb816125fd565b9082915f611a13565b634e487b7160e01b5f52602160045260245ffd5b60031115611ae257565b611ac4565b919060208301926003821015611ae25752565b346102f3575f3660031901126102f357610dc860ff60015460a01c1660405191829182611ae7565b346102f35760403660031901126102f357600435611b3f81610f67565b60243567ffffffffffffffff81116102f357611b5f9036906004016109e7565b6001600160a01b03600154163303610725578051602011611c035760206001600160601b03910151915b165f52600a60205260405f20908154611bdb576001811115611bb35781556107d2906002016126bd565b7f081fb0a9000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fdb73328b000000000000000000000000000000000000000000000000000000005f5260045ffd5b506001600160601b03600691611b89565b346102f3575f3660031901126102f3576020600454604051908152f35b346102f3575f3660031901126102f3576020600254604051908152f35b346102f35760203660031901126102f357600435611c6b81610682565b6001600160a01b035f5416330361033e576001600160a01b03166001600160a01b03196006541617806006556001611ca8815460ff9060a01c1690565b611cb181611ad8565b14611cb857005b611cca906001600160a01b03166103bf565b803b156102f3575f809160046040518094819363f8413b0760e01b83525af1801561048757611cf557005b8061047b5f6107d2936109a4565b801515036102f357565b346102f35760803660031901126102f357600435611d2a81610682565b602435611d3681610f67565b60443560643591611d4683611d03565b6001600160a01b0360015416330361072557611d619361272c565b909160405192606084019184526020840152600a821015611ae257829160408301520390f35b346102f3575f3660031901126102f3576020600754604051908152f35b346102f35760603660031901126102f357600435611dc181610f67565b60243560443560ff60015460a01c166003811015611ae257600203611e28576001600160601b03611e0293165f52600a60205260405f2091600754926129c0565b604080516001600160a01b039390931683526001600160601b0391909116602083015290f35b7f0c3d002f000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102f35760403660031901126102f3576001600160a01b0360015416330361072557610f21600554612585565b346102f3576080611e8e366115ac565b906001600160a01b0381165f52600b60205260405f20611eb86001820154936002830154936125a6565b905491604051938452602084015260408301526060820152f35b346102f3575f3660031901126102f35760206001600160a01b0360065416604051908152f35b346102f35760203660031901126102f3576001600160a01b03600435611f1d81610682565b165f52600b6020526040805f206002600182015491015482519182526020820152f35b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600355005b346102f3575f3660031901126102f35760206001600160a01b0360015416604051908152f35b905f5260205260405f2090565b346102f35760203660031901126102f3576004355f52600c60205260405f206001815491015490610dc860405192826001600160a01b03859460a01c9116846001600160601b036040929594936001600160a01b0360608401971683521660208201520152565b634e487b7160e01b5f52601160045260245ffd5b5f1981019190821161072057565b9190820391821161072057565b908160209103126102f3575190565b6040513d5f823e3d90fd5b906001820180921161072057565b9190820180921161072057565b908160209103126102f357516115d181611d03565b916120969183549060031b91821b915f19901b19161790565b9055565b3d156120c4573d906120ab826109cb565b916120b960405193846109a4565b82523d5f602084013e565b606090565b604051815480825290929183906120e260208301610d81565b925f905b80600183011061213f5761210c945491818110612125575b1061210e575b5003836109a4565b565b60601c6001600160601b031681526020015f612104565b6001600160601b03831684529260019060200193016120fe565b916002919350604060019161216a8754610e25836001600160601b0383166001600160601b03169052565b0194019201859293916120e6565b8015610720575f190190565b909180156122ef5761219683836125a6565b9081156122e757808201809211610720576121e060016121c7856001600160a01b03165f52600b60205260405f2090565b6121d187876125a6565b156122d8575b0191825461205b565b815583606084901b81175f5b8015612256575050509161224e6001600160a01b03927f70ca4ec64687bf265f39041896f3dbf10b9f650503cb38f2b3569fdce7489c369454906040519485941696846040919493926001600160601b03606083019616825260208201520152565b0390a2600190565b60016001600160601b0384166122738488611917611909856118fd565b03612280575060016121ec565b9160c061229c916119456103bf6001546001600160a01b031690565b03915afa908115610487575f916122b5575b50916121ec565b6122cd915060c03d81116119ce576119bb81836109a4565b50505050505f6122ae565b6122e2878261262e565b6121d7565b505050505f90565b505050600190565b9192906001600160a01b03831693845f52600b60205260405f20948192600161232082886125a6565b9701928354908110612516575b841561250a57505f96848110156124f6575b5061235b866001600160a01b03165f52600b60205260405f2090565b600181019061236b868354612026565b82558815612471575b50818892939495969760601b175f9084915b80156123e457505050916123dc7f70ca4ec64687bf265f39041896f3dbf10b9f650503cb38f2b3569fdce7489c369354604051938493846040919493926001600160601b03606083019616825260208201520152565b0390a2549291565b929350909160016001600160601b038416612406848d611917611909856118fd565b03612419575060015b9089939291612386565b9160c0612435916119456103bf6001546001600160a01b031690565b03915afa908115610487575f9161244e575b509161240f565b612466915060c03d81116119ce576119bb81836109a4565b50505050505f612447565b96875497886001600160601b038516995b61248f575b505096612374565b896001600160601b036124a7611a3b611a3585612018565b16146124bc576124b690612178565b80612482565b84959697989950906124e46124e992611a93611a8d611a87611a3b611a81879b9a9b54612018565b6125fd565b879695949392915f612487565b90965083810390811161072057955f61233f565b9695505f949350505050565b93508361232d565b6001600160a01b03165f52600b60205260405f208054158061254c575b15612547576001015490565b505f90565b5060028101541561253b565b634e487b7160e01b5f52603260045260245ffd5b80518210156125805760209160051b010190565b612558565b5f1981146107205760010190565b6001600160a01b035f5416330361033e57565b906115d1916001600160601b0382165f52600a60205260601b1760405f20612afc565b9190918054831015612580575f52600c600160205f2084821c0193160290565b634e487b7160e01b5f52603160045260245ffd5b80548015612629575f19019061261382826125c9565b6001600160601b0382549160031b1b1916905555565b6125e9565b90815491680100000000000000008310156109c65782611a9391600161210c950181556125c9565b91908260c09103126102f357815161266d81610f67565b91602081015161267c81611d03565b9160408201519160608101519160a0608083015192015190565b805415612580575f5260205f20905f90565b8054821015612580575f5260205f2001905f90565b8054680100000000000000008110156109c6576126df916001820181556126a8565b8154905f199060031b1b19169055565b805490680100000000000000008210156109c65781612716916001612096940181556126a8565b819391549060031b91821b915f19901b19161790565b93929190915f905f95612750816001600160a01b03165f52600b60205260405f2090565b9361275b86836125a6565b9586821193841561297a576127708884612026565b975b875481158091819261296e575b506129595780612951575b61293d57856128c5575b5060015460a01c60ff166127a781611ad8565b151590816128bc575b5061282c575050505f146127da5750506127d46127cf82600f5461205b565b600f55565b91905f90565b918091945093600260018201549101548082115f14612822576127fc91612026565b80915b1161281a575b506128156127cf84600f54612026565b6127d4565b92505f612805565b50505f80916127ff565b90809496506001600160601b039295507fa59837f9df3fb816613d84e8fefe31ec8d6e67ff43df6533e3f793a3f53aade99350600161288661286f600854612585565b61287881600855565b5f52600c60205260405f2090565b60a084901b6001600160a01b0319166001600160a01b039890981697881781550155604051938452169291602090a39190600190565b9050155f6127b0565b6128d38960018a015461205b565b89600d54809211928315612929575b505050612916576128f588600f5461205b565b600e5410612903575f612794565b505050505050505090505f905f90600890565b505050505050505090505f905f90600790565b61293492935061205b565b115f89816128e2565b50505050505050505090505f905f90600990565b50831561278a565b5050505050505050505090505f905f90600490565b6004915010155f61277f565b6129848389612026565b97612772565b634e487b7160e01b5f52601260045260245ffd5b81156129a8570690565b61298a565b8181029291811591840414171561072057565b919392909360028301946129e06129d687612696565b90549060031b1c90565b15612af05790612a20612a359392612a1260405193849260208401968791606093918352602083015260408201520190565b03601f1981018352826109a4565b519020612a2f6129d686612696565b9061299e565b905f928454915b805483612a4c6107b588846129ad565b1015612aba576001905b80821115612a66575b5050612a3c565b9094612a7b86612a7689856129ad565b61205b565b90612a896129d6838b6126a8565b91828210612aab5750612aa591612a9f91612026565b95612585565b90612a56565b93975095505050935f80612a5f565b506004919550612ad99350612aec94925001905f5260205260405f2090565b54906001600160601b038260601c921690565b9091565b5050505090505f905f90565b905f526003810160205260405f20548015612b1d5760026129d692016126a8565b50505f90565b80548015612629575f190190612b3982826126a8565b8154905f199060031b1b1916905555565b81156129a8570490565b6003810190612b6b8483905f5260205260405f2090565b5480612cbf575082612b7e575b50505050565b612bdd9360018201805480155f14612c8357505060028201612bc78282549583612ba98989966126ef565b600185141580612c68575b612be6575b50905f5260205260405f2090565b555f838152600483016020526040902055612def565b5f808080612b78565b612c61612bf4885487612b4a565b91600489015f612c3f612c0f8684905f5260205260405f2090565b5495612c31612c1d8c61204d565b95612c2b6129d684836126a8565b906126ef565b83905f5260205260405f2090565b5581612c538587905f5260205260405f2090565b55905f5260205260405f2090565b555f612bb9565b50612c7d612c7586612018565b88549061299e565b15612bb4565b82612ca895612ca06129d6612c9a612bc795612018565b866126a8565b968794612b23565b611f9088612cb98660028a016126a8565b9061207d565b919280949194155f14612d185750925f612d0261210c956002840195612cf56126df87612cef6129d6828c6126a8565b996126a8565b611f9086600187016126ef565b555f828152600482016020526040812055612d97565b919250506002830191612d2e6129d682856126a8565b8203612d3a5750505050565b612bdd93612d7883612d4f6129d685886126a8565b1180159490612d7d57612cb984612d72612d6c6129d6838b6126a8565b84612026565b976126a8565b612e47565b612cb984612d7283612d926129d6848c6126a8565b612026565b90805b612da357505050565b5f1981019081116107205781549081156129a85704612dc581600284016126a8565b90549060031b1c838103908111610720578190612de861271683600287016126a8565b9055612d9a565b90805b612dfb57505050565b5f1981019081116107205781549081156129a85704612e1d81600284016126a8565b90549060031b1c838101809111610720578190612e4061271683600287016126a8565b9055612df2565b919290805b612e565750505050565b5f1981019081116107205782549081156129a857048315612e9b5780612e96612e8984612a766129d68560028a016126a8565b612cb983600288016126a8565b612e4c565b612ea881600285016126a8565b90549060031b1c82810390811161072057612e968291612e8956fea26469706673582212208562e9e79f11663fdc9822346c2e7b88efbf452848b2ae21b5632abe13d17a2864736f6c634300081e0033f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e",
  "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c806303432744146102e457806306dfc967146102df5780630b274f2e146102da5780630e083ec9146102d55780631b92bbbe146102d057806321e1625e146102cb57806323f61de4146102c657806335975f4a146102c15780634f1ef286146102bc57806352d1902d146102b7578063543f8a36146102b257806354fd4d50146102ad57806356acb050146102a85780635a68c154146102a35780635d2d78461461029e5780636624192f14610299578063664bffc31461029457806369f458771461028f578063771a27cb1461028a5780637eab309e14610285578063817b1cd214610280578063823cfd701461027b5780638d3771bb146102765780638da5cb5b14610271578063965af6c71461026c5780639d560867146102675780639fbb56f114610262578063a6f9dae11461025d578063aa9ebfb714610258578063aac03ad214610253578063b1c9fe6e1461024e578063b4ebe83814610249578063b888adfa14610244578063c057eca71461023f578063c41bda611461023a578063c70ba3b914610235578063ccbac9f514610230578063d045e0021461022b578063d09f392d14610226578063d1c1df4814610221578063d605787b1461021c578063dca5f6b014610217578063dd5e5cb514610212578063f2f4eb261461020d5763f6b4d82d14610208575f80fd5b611f9d565b611f6a565b611f40565b611ef8565b611ed2565b611e7e565b611e50565b611da4565b611d87565b611d0d565b611c4e565b611c31565b611c14565b611b22565b611afa565b6117ef565b6116d6565b61168c565b61165d565b6115d4565b6114dd565b6114b8565b61148e565b611464565b611447565b61115a565b611118565b610fdd565b610fa4565b610f26565b610ef3565b610ed6565b610eb9565b610e43565b610d37565b610c8b565b610a2d565b610750565b610733565b610693565b610665565b610648565b610366565b610314565b6102f7565b5f9103126102f357565b5f80fd5b346102f3575f3660031901126102f3576020600554604051908152f35b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600d55005b7f596dcdb8000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102f3575f3660031901126102f35760015460a01c60ff1661038881611ad8565b806104dc575061039a60045442612026565b600254116104b4576005541561048c576103cb6103bf6006546001600160a01b031690565b6001600160a01b031690565b803b156102f3575f809160046040518094819363f8413b0760e01b83525af180156104875761046d575b5061041f7401000000000000000000000000000000000000000060ff60a01b196001541617600155565b61042842600455565b7f31f72b44f546d9e7eaec13f65636997665e15f134a81c82924f568f5c0d07b9361046861045c60015460ff9060a01c1690565b60405191829182611ae7565b0390a1005b8061047b5f610481936109a4565b806102e9565b5f6103f5565b612042565b7f1a937bfc000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fbc26f968000000000000000000000000000000000000000000000000000000005f5260045ffd5b6104e581611ad8565b600181036105d857505f60206105066103bf6006546001600160a01b031690565b6004604051809481937f910f03a60000000000000000000000000000000000000000000000000000000083525af180156104875761054b915f916105a9575b50600755565b600754156105815761057c7402000000000000000000000000000000000000000060ff60a01b196001541617600155565b61041f565b7fcba65b92000000000000000000000000000000000000000000000000000000005f5260045ffd5b6105cb915060203d6020116105d1575b6105c381836109a4565b810190612033565b5f610545565b503d6105b9565b806105e4600292611ad8565b0361041f57600554151580610632575b61060a5761057c60ff60a01b1960015416600155565b7f6b249f2f000000000000000000000000000000000000000000000000000000005f5260045ffd5b5061063f60045442612026565b600354116105f4565b346102f3575f3660031901126102f3576020600854604051908152f35b346102f3575f3660031901126102f3576020600354604051908152f35b6001600160a01b038116036102f357565b346102f35760403660031901126102f3576004356106b081610682565b602435906001600160a01b03600154163303610725576001600160a01b031690815f52600b602052600260405f2001805491808301809311610720577f7a81a4ef419d50dbb5deb116fb983bf6ca7716bcbc84cd1cd2be81ccea9078b0926040925581519081525f6020820152a2005b612004565b628448c760e31b5f5260045ffd5b346102f3575f3660031901126102f3576020600d54604051908152f35b346102f35760203660031901126102f35760043560015460a01c60ff1661077681611ad8565b61096857600854600954918282106109405781816107c0936107a161079c87958661205b565b612018565b111561093857506107ba916107b591612026565b61204d565b8261205b565b905b8181106107d4576107d282600955565b005b806107ea610868925f52600c60205260405f2090565b6107ff6103bf6001546001600160a01b031690565b906020815461081e610817826001600160a01b031690565b9160a01c90565b9360018401945f865493604051998a9586948593630761c14d60e01b8552600485016001600160601b036040929594936001600160a01b0360608401971683521660208201520152565b03925af18015610487576001945f9161090a575b50156108ab575b50506108a561089a825f52600c60205260405f2090565b60015f918281550155565b016107c2565b54907fb588834590b84623e5ca8f8a3a808b981214a1f0cba52ddd7fd3bbb6d10c7fe46001600160601b036108ea6001600160a01b0385169460a01c90565b92546040519081529216926001600160a01b031691602090a35f80610883565b61092b915060203d8111610931575b61092381836109a4565b810190612068565b5f61087c565b503d610919565b9150506107ba565b7f3a946f67000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4d269093000000000000000000000000000000000000000000000000000000005f5260045ffd5b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176109c657604052565b610990565b67ffffffffffffffff81116109c657601f01601f191660200190565b81601f820112156102f3578035906109fe826109cb565b92610a0c60405194856109a4565b828452602083830101116102f357815f926020809301838601378301015290565b60403660031901126102f357600435610a4581610682565b60243567ffffffffffffffff81116102f357610a659036906004016109e7565b610a6d612593565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016803014908115610c50575b50610c28576001600160a01b0382166040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481855afa5f9181610c07575b50610b22577f0c760937000000000000000000000000000000000000000000000000000000005f526001600160a01b03841660045260245ffd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8103610bdc5750827f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a2805180610b9a57005b5f926020849301905af4610bac61209a565b5015610bb457005b7f736436ba000000000000000000000000000000000000000000000000000000005f5260045ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b610c2191925060203d6020116105d1576105c381836109a4565b905f610ae8565b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b9050610c837f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b14155f610aa2565b346102f3575f3660031901126102f3576001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610c285760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b60206040818301928281528451809452019201905f5b818110610d185750505090565b82516001600160601b0316845260209384019390920191600101610d0b565b346102f35760203660031901126102f3576001600160a01b03600435610d5c81610682565b165f52600b60205260405f20604051908190610d8b610d818254809560209181520190565b915f5260205f2090565b925f935b816001860110610dfd5791610dc8948492610dbc945491818110610de3575b10610dcc575b5003826109a4565b60405191829182610cf5565b0390f35b60601c6001600160601b031681526020015f610db4565b6001600160601b0383168452926001906020019301610dae565b9160016040600292610e388654610e25836001600160601b0383166001600160601b03169052565b60601c6001600160601b03166020830152565b019301940193610d8f565b346102f3575f3660031901126102f3576040805190610e6281836109a4565b6005825260208201917f322e302e3000000000000000000000000000000000000000000000000000000083528151928391602083525180918160208501528484015e5f828201840152601f01601f19168101030190f35b346102f3575f3660031901126102f3576020600954604051908152f35b346102f3575f3660031901126102f3576020600e54604051908152f35b346102f35760403660031901126102f3576001600160a01b0360015416330361072557610f21600554612178565b600555005b346102f35760203660031901126102f3576001600160a01b03600435610f4b81610682565b165f52600b6020526020600160405f2001541515604051908152f35b6001600160601b038116036102f357565b60609060031901126102f357600435610f9081610682565b90602435610f9d81610f67565b9060443590565b346102f357610fb236610f78565b6001600160a01b0360019392935416330361072557602092610fd392612184565b6040519015158152f35b346102f35760203660031901126102f357600435610ffa81610682565b6110038161251e565b9081156110f0575f6001611028836001600160a01b03165f52600b60205260405f2090565b015561103f6103bf6001546001600160a01b031690565b90813b156102f3576040517f42c37fa30000000000000000000000000000000000000000000000000000000081526001600160a01b038216600482015260248101849052915f908390604490829084905af1908115610487577f71bb1b604559acc3db697ccf2aa4228d727cd5b133d6ffa419518d51c117c95c926001600160a01b03926110dc575b50604051938452169180602081015b0390a2005b8061047b5f6110ea936109a4565b5f6110c8565b7fdc604fd1000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102f35761112636610f78565b6001600160a01b0360019392935416330361072557606092611147926122f7565b9060405192835260208301526040820152f35b346102f35760e03660031901126102f35760043561117781610682565b6024359061118482610682565b60443560643560843561119681610682565b60a4359160c435937ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e54966111e76111d96111d58a60ff9060401c1690565b1590565b9867ffffffffffffffff1690565b8880611433575b15908161140b575b506113fd576112b59688611257600167ffffffffffffffff197ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e5416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e55565b611343576001600160a01b0394939291858092166001600160a01b03195f5416175f55166001600160a01b0319600154161760015560025560035542600455166001600160a01b03196006541617600655600d55600e556001600955565b6112bb57005b61131068ff0000000000000000197ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e54167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e55565b604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2908060208101610468565b6113a36801000000000000000068ff0000000000000000197ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e5416177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e55565b6001600160a01b0394939291858092166001600160a01b03195f5416175f55166001600160a01b0319600154161760015560025560035542600455166001600160a01b03196006541617600655600d55600e556001600955565b62dc149f60e41b5f5260045ffd5b303b1591508161141e575b50155f6111f6565b6001915067ffffffffffffffff16145f611416565b50600167ffffffffffffffff8216106111ee565b346102f3575f3660031901126102f3576020600f54604051908152f35b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600255005b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600e55005b346102f3575f3660031901126102f35760206001600160a01b035f5416604051908152f35b346102f35760403660031901126102f3576004356114fa81610682565b6024356001600160a01b03600154163303610725576001600160a01b03821691825f52600b602052600260405f200191825481810390811161072057604085927f7a81a4ef419d50dbb5deb116fb983bf6ca7716bcbc84cd1cd2be81ccea9078b0926115739655815190815260016020820152a261251e565b8061157a57005b6040519081527f819a3744490c627e221b71743857691f9c23bf56a1ecc5351f886cfd4c3187d99080602081016110d7565b60409060031901126102f3576004356115c481610682565b906024356115d181610f67565b90565b346102f3576115e2366115ac565b906001600160a01b03600154169133830361072557604051630761c14d60e01b81526001600160a01b039290921660048301526001600160601b031660248201525f604482018190529091602091839160649183915af180156104875761164557005b6107d29060203d6020116109315761092381836109a4565b346102f35760203660031901126102f357602061168460043561167f81610682565b61251e565b604051908152f35b346102f35760203660031901126102f3576004356116a981610682565b6001600160a01b035f5416330361033e576001600160a01b03166001600160a01b03195f5416175f555f80f35b346102f35760203660031901126102f3576004356116f381610682565b6001600160a01b0360015416330361072557611728611723826001600160a01b03165f52600b60205260405f2090565b6120c9565b8051805b61173257005b5f9060206117b161174e6103bf6001546001600160a01b031690565b61177061176361175d86612018565b8861256c565b516001600160601b031690565b604051958680948193630761c14d60e01b83528b600484016040906001600160601b035f9395946001600160a01b0360608401971683521660208201520152565b03925af1918215610487576117cb926117d1575b50612178565b8061172c565b6117e89060203d81116109315761092381836109a4565b505f6117c5565b346102f35760a03660031901126102f35760043561180c81610682565b6024359061181982610f67565b604435606435608435916001600160a01b0360015416330361072557611850846001600160a01b03165f52600b60205260405f2090565b9181156119e4575061186285856125a6565b156119d5575b6118776001830191825461205b565b90555b83606084901b81175f5b80156118e4576001840154604080516001600160601b038a16815260208101889052908101919091526001600160a01b038716907f70ca4ec64687bf265f39041896f3dbf10b9f650503cb38f2b3569fdce7489c369080606081016110d7565b60016001600160601b03841661191c8488611917611909855b6001600160601b031690565b5f52600a60205260405f2090565b612b54565b0361192957506001611884565b9160c0611989916119456103bf6001546001600160a01b031690565b60405180809581947f1f5a0dd2000000000000000000000000000000000000000000000000000000008352600483019190916001600160601b036020820193169052565b03915afa908115610487575f916119a2575b5091611884565b6119c3915060c03d81116119ce575b6119bb81836109a4565b810190612656565b50505050505f61199b565b503d6119b1565b6119df858361262e565b611868565b90506119f560018301918254612026565b90558161187a579190825492836001600160601b038616945b611a1d575b509091925061187a565b846001600160601b03611a4e611a3b611a3585612018565b866125c9565b90546001600160601b039160031b1c1690565b1614611a6357611a5d90612178565b80611a0e565b8192939450611a93611a8d611a87611a3b611a81611ab29654612018565b876125c9565b92612018565b846125c9565b9091906001600160601b038084549260031b9316831b921b1916179055565b611abb816125fd565b9082915f611a13565b634e487b7160e01b5f52602160045260245ffd5b60031115611ae257565b611ac4565b919060208301926003821015611ae25752565b346102f3575f3660031901126102f357610dc860ff60015460a01c1660405191829182611ae7565b346102f35760403660031901126102f357600435611b3f81610f67565b60243567ffffffffffffffff81116102f357611b5f9036906004016109e7565b6001600160a01b03600154163303610725578051602011611c035760206001600160601b03910151915b165f52600a60205260405f20908154611bdb576001811115611bb35781556107d2906002016126bd565b7f081fb0a9000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fdb73328b000000000000000000000000000000000000000000000000000000005f5260045ffd5b506001600160601b03600691611b89565b346102f3575f3660031901126102f3576020600454604051908152f35b346102f3575f3660031901126102f3576020600254604051908152f35b346102f35760203660031901126102f357600435611c6b81610682565b6001600160a01b035f5416330361033e576001600160a01b03166001600160a01b03196006541617806006556001611ca8815460ff9060a01c1690565b611cb181611ad8565b14611cb857005b611cca906001600160a01b03166103bf565b803b156102f3575f809160046040518094819363f8413b0760e01b83525af1801561048757611cf557005b8061047b5f6107d2936109a4565b801515036102f357565b346102f35760803660031901126102f357600435611d2a81610682565b602435611d3681610f67565b60443560643591611d4683611d03565b6001600160a01b0360015416330361072557611d619361272c565b909160405192606084019184526020840152600a821015611ae257829160408301520390f35b346102f3575f3660031901126102f3576020600754604051908152f35b346102f35760603660031901126102f357600435611dc181610f67565b60243560443560ff60015460a01c166003811015611ae257600203611e28576001600160601b03611e0293165f52600a60205260405f2091600754926129c0565b604080516001600160a01b039390931683526001600160601b0391909116602083015290f35b7f0c3d002f000000000000000000000000000000000000000000000000000000005f5260045ffd5b346102f35760403660031901126102f3576001600160a01b0360015416330361072557610f21600554612585565b346102f3576080611e8e366115ac565b906001600160a01b0381165f52600b60205260405f20611eb86001820154936002830154936125a6565b905491604051938452602084015260408301526060820152f35b346102f3575f3660031901126102f35760206001600160a01b0360065416604051908152f35b346102f35760203660031901126102f3576001600160a01b03600435611f1d81610682565b165f52600b6020526040805f206002600182015491015482519182526020820152f35b346102f35760203660031901126102f3576004356001600160a01b035f5416330361033e57600355005b346102f3575f3660031901126102f35760206001600160a01b0360015416604051908152f35b905f5260205260405f2090565b346102f35760203660031901126102f3576004355f52600c60205260405f206001815491015490610dc860405192826001600160a01b03859460a01c9116846001600160601b036040929594936001600160a01b0360608401971683521660208201520152565b634e487b7160e01b5f52601160045260245ffd5b5f1981019190821161072057565b9190820391821161072057565b908160209103126102f3575190565b6040513d5f823e3d90fd5b906001820180921161072057565b9190820180921161072057565b908160209103126102f357516115d181611d03565b916120969183549060031b91821b915f19901b19161790565b9055565b3d156120c4573d906120ab826109cb565b916120b960405193846109a4565b82523d5f602084013e565b606090565b604051815480825290929183906120e260208301610d81565b925f905b80600183011061213f5761210c945491818110612125575b1061210e575b5003836109a4565b565b60601c6001600160601b031681526020015f612104565b6001600160601b03831684529260019060200193016120fe565b916002919350604060019161216a8754610e25836001600160601b0383166001600160601b03169052565b0194019201859293916120e6565b8015610720575f190190565b909180156122ef5761219683836125a6565b9081156122e757808201809211610720576121e060016121c7856001600160a01b03165f52600b60205260405f2090565b6121d187876125a6565b156122d8575b0191825461205b565b815583606084901b81175f5b8015612256575050509161224e6001600160a01b03927f70ca4ec64687bf265f39041896f3dbf10b9f650503cb38f2b3569fdce7489c369454906040519485941696846040919493926001600160601b03606083019616825260208201520152565b0390a2600190565b60016001600160601b0384166122738488611917611909856118fd565b03612280575060016121ec565b9160c061229c916119456103bf6001546001600160a01b031690565b03915afa908115610487575f916122b5575b50916121ec565b6122cd915060c03d81116119ce576119bb81836109a4565b50505050505f6122ae565b6122e2878261262e565b6121d7565b505050505f90565b505050600190565b9192906001600160a01b03831693845f52600b60205260405f20948192600161232082886125a6565b9701928354908110612516575b841561250a57505f96848110156124f6575b5061235b866001600160a01b03165f52600b60205260405f2090565b600181019061236b868354612026565b82558815612471575b50818892939495969760601b175f9084915b80156123e457505050916123dc7f70ca4ec64687bf265f39041896f3dbf10b9f650503cb38f2b3569fdce7489c369354604051938493846040919493926001600160601b03606083019616825260208201520152565b0390a2549291565b929350909160016001600160601b038416612406848d611917611909856118fd565b03612419575060015b9089939291612386565b9160c0612435916119456103bf6001546001600160a01b031690565b03915afa908115610487575f9161244e575b509161240f565b612466915060c03d81116119ce576119bb81836109a4565b50505050505f612447565b96875497886001600160601b038516995b61248f575b505096612374565b896001600160601b036124a7611a3b611a3585612018565b16146124bc576124b690612178565b80612482565b84959697989950906124e46124e992611a93611a8d611a87611a3b611a81879b9a9b54612018565b6125fd565b879695949392915f612487565b90965083810390811161072057955f61233f565b9695505f949350505050565b93508361232d565b6001600160a01b03165f52600b60205260405f208054158061254c575b15612547576001015490565b505f90565b5060028101541561253b565b634e487b7160e01b5f52603260045260245ffd5b80518210156125805760209160051b010190565b612558565b5f1981146107205760010190565b6001600160a01b035f5416330361033e57565b906115d1916001600160601b0382165f52600a60205260601b1760405f20612afc565b9190918054831015612580575f52600c600160205f2084821c0193160290565b634e487b7160e01b5f52603160045260245ffd5b80548015612629575f19019061261382826125c9565b6001600160601b0382549160031b1b1916905555565b6125e9565b90815491680100000000000000008310156109c65782611a9391600161210c950181556125c9565b91908260c09103126102f357815161266d81610f67565b91602081015161267c81611d03565b9160408201519160608101519160a0608083015192015190565b805415612580575f5260205f20905f90565b8054821015612580575f5260205f2001905f90565b8054680100000000000000008110156109c6576126df916001820181556126a8565b8154905f199060031b1b19169055565b805490680100000000000000008210156109c65781612716916001612096940181556126a8565b819391549060031b91821b915f19901b19161790565b93929190915f905f95612750816001600160a01b03165f52600b60205260405f2090565b9361275b86836125a6565b9586821193841561297a576127708884612026565b975b875481158091819261296e575b506129595780612951575b61293d57856128c5575b5060015460a01c60ff166127a781611ad8565b151590816128bc575b5061282c575050505f146127da5750506127d46127cf82600f5461205b565b600f55565b91905f90565b918091945093600260018201549101548082115f14612822576127fc91612026565b80915b1161281a575b506128156127cf84600f54612026565b6127d4565b92505f612805565b50505f80916127ff565b90809496506001600160601b039295507fa59837f9df3fb816613d84e8fefe31ec8d6e67ff43df6533e3f793a3f53aade99350600161288661286f600854612585565b61287881600855565b5f52600c60205260405f2090565b60a084901b6001600160a01b0319166001600160a01b039890981697881781550155604051938452169291602090a39190600190565b9050155f6127b0565b6128d38960018a015461205b565b89600d54809211928315612929575b505050612916576128f588600f5461205b565b600e5410612903575f612794565b505050505050505090505f905f90600890565b505050505050505090505f905f90600790565b61293492935061205b565b115f89816128e2565b50505050505050505090505f905f90600990565b50831561278a565b5050505050505050505090505f905f90600490565b6004915010155f61277f565b6129848389612026565b97612772565b634e487b7160e01b5f52601260045260245ffd5b81156129a8570690565b61298a565b8181029291811591840414171561072057565b919392909360028301946129e06129d687612696565b90549060031b1c90565b15612af05790612a20612a359392612a1260405193849260208401968791606093918352602083015260408201520190565b03601f1981018352826109a4565b519020612a2f6129d686612696565b9061299e565b905f928454915b805483612a4c6107b588846129ad565b1015612aba576001905b80821115612a66575b5050612a3c565b9094612a7b86612a7689856129ad565b61205b565b90612a896129d6838b6126a8565b91828210612aab5750612aa591612a9f91612026565b95612585565b90612a56565b93975095505050935f80612a5f565b506004919550612ad99350612aec94925001905f5260205260405f2090565b54906001600160601b038260601c921690565b9091565b5050505090505f905f90565b905f526003810160205260405f20548015612b1d5760026129d692016126a8565b50505f90565b80548015612629575f190190612b3982826126a8565b8154905f199060031b1b1916905555565b81156129a8570490565b6003810190612b6b8483905f5260205260405f2090565b5480612cbf575082612b7e575b50505050565b612bdd9360018201805480155f14612c8357505060028201612bc78282549583612ba98989966126ef565b600185141580612c68575b612be6575b50905f5260205260405f2090565b555f838152600483016020526040902055612def565b5f808080612b78565b612c61612bf4885487612b4a565b91600489015f612c3f612c0f8684905f5260205260405f2090565b5495612c31612c1d8c61204d565b95612c2b6129d684836126a8565b906126ef565b83905f5260205260405f2090565b5581612c538587905f5260205260405f2090565b55905f5260205260405f2090565b555f612bb9565b50612c7d612c7586612018565b88549061299e565b15612bb4565b82612ca895612ca06129d6612c9a612bc795612018565b866126a8565b968794612b23565b611f9088612cb98660028a016126a8565b9061207d565b919280949194155f14612d185750925f612d0261210c956002840195612cf56126df87612cef6129d6828c6126a8565b996126a8565b611f9086600187016126ef565b555f828152600482016020526040812055612d97565b919250506002830191612d2e6129d682856126a8565b8203612d3a5750505050565b612bdd93612d7883612d4f6129d685886126a8565b1180159490612d7d57612cb984612d72612d6c6129d6838b6126a8565b84612026565b976126a8565b612e47565b612cb984612d7283612d926129d6848c6126a8565b612026565b90805b612da357505050565b5f1981019081116107205781549081156129a85704612dc581600284016126a8565b90549060031b1c838103908111610720578190612de861271683600287016126a8565b9055612d9a565b90805b612dfb57505050565b5f1981019081116107205781549081156129a85704612e1d81600284016126a8565b90549060031b1c838101809111610720578190612e4061271683600287016126a8565b9055612df2565b919290805b612e565750505050565b5f1981019081116107205782549081156129a857048315612e9b5780612e96612e8984612a766129d68560028a016126a8565b612cb983600288016126a8565b612e4c565b612ea881600285016126a8565b90549060031b1c82810390811161072057612e968291612e8956fea26469706673582212208562e9e79f11663fdc9822346c2e7b88efbf452848b2ae21b5632abe13d17a2864736f6c634300081e0033",
  "devdoc": {
    "errors": {
      "AlreadyInitialized()": [
        {
          "details": "The contract is already initialized."
        }
      ],
      "NotInitializing()": [
        {
          "details": "The contract is not initializing."
        }
      ]
    },
    "events": {
      "Initialized(uint64)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "LeftoverPNK(address,uint256)": {
        "params": {
          "_account": "The account of the juror.",
          "_amount": "The amount of PNK available."
        }
      },
      "LeftoverPNKWithdrawn(address,uint256)": {
        "params": {
          "_account": "The account of the juror withdrawing PNK.",
          "_amount": "The amount of PNK withdrawn."
        }
      },
      "NewPhase(uint8)": {
        "params": {
          "_phase": "The new phase."
        }
      },
      "StakeDelayed(address,uint96,uint256)": {
        "params": {
          "_address": "The address of the juror.",
          "_amount": "The amount of tokens staked in the court.",
          "_courtID": "The ID of the court."
        }
      },
      "StakeDelayedExecutionFailed(address,uint96,uint256)": {
        "params": {
          "_address": "The address of the juror.",
          "_amount": "The amount of tokens staked in the court.",
          "_courtID": "The ID of the court."
        }
      },
      "StakeLocked(address,uint256,bool)": {
        "params": {
          "_address": "The address of the juror.",
          "_relativeAmount": "The amount of tokens locked.",
          "_unlock": "Whether the stake is locked or unlocked."
        }
      },
      "StakeSet(address,uint256,uint256,uint256)": {
        "params": {
          "_address": "The address of the juror.",
          "_amount": "The amount of tokens staked in the court.",
          "_amountAllCourts": "The amount of tokens staked in all courts.",
          "_courtID": "The ID of the court."
        }
      },
      "Upgraded(address)": {
        "params": {
          "newImplementation": "Address of the new implementation the proxy is now forwarding calls to."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "changeMaxDrawingTime(uint256)": {
        "params": {
          "_maxDrawingTime": "The new value for the `maxDrawingTime` storage variable."
        }
      },
      "changeMaxStakePerJuror(uint256)": {
        "params": {
          "_maxStakePerJuror": "The new `maxStakePerJuror` storage variable."
        }
      },
      "changeMaxTotalStaked(uint256)": {
        "params": {
          "_maxTotalStaked": "The new `maxTotalStaked` storage variable."
        }
      },
      "changeMinStakingTime(uint256)": {
        "params": {
          "_minStakingTime": "The new value for the `minStakingTime` storage variable."
        }
      },
      "changeOwner(address)": {
        "params": {
          "_owner": "The new owner."
        }
      },
      "changeRandomNumberGenerator(address)": {
        "params": {
          "_rng": "The new random number generator."
        }
      },
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor"
      },
      "createDisputeHook(uint256,uint256)": {
        "params": {
          "_disputeID": "The ID of the dispute.",
          "_roundID": "The ID of the round."
        }
      },
      "createTree(uint96,bytes)": {
        "params": {
          "_courtID": "The ID of the court.",
          "_extraData": "Extra data that contains the number of children each node in the tree should have."
        }
      },
      "draw(uint96,uint256,uint256)": {
        "details": "that this function reverts if the sum of all values in the tree is 0. `O(k * log_k(n))` where `k` is the maximum number of children per node in the tree,  and `n` is the maximum number of nodes ever appended.",
        "params": {
          "_coreDisputeID": "Index of the dispute in Kleros Core.",
          "_courtID": "The ID of the court.",
          "_nonce": "Nonce to hash with random number."
        },
        "returns": {
          "drawnAddress": "The drawn address."
        }
      },
      "executeDelayedStakes(uint256)": {
        "params": {
          "_iterations": "The number of delayed stakes to execute."
        }
      },
      "forcedUnstake(address,uint96)": {
        "details": "`O(n * (p * log_k(j)) )` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.",
        "params": {
          "_account": "The juror to unstake.",
          "_courtID": "The ID of the court."
        }
      },
      "forcedUnstakeAllCourts(address)": {
        "details": "`O(n * (p * log_k(j)) )` where `O(n * (p * log_k(j)) )` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.",
        "params": {
          "_account": "The juror to unstake."
        }
      },
      "getJurorBalance(address,uint96)": {
        "params": {
          "_courtID": "The ID of the court.",
          "_juror": "The address of the juror."
        },
        "returns": {
          "nbCourts": "The number of courts the juror has directly staked in.",
          "stakedInCourt": "The amount of tokens staked in the specified court including locked tokens and penalty deductions.",
          "totalLocked": "The total amount of tokens locked in disputes.",
          "totalStakedPnk": "The total amount of tokens staked including locked tokens and penalty deductions. Equivalent to the effective stake in the General court."
        }
      },
      "getJurorCourtIDs(address)": {
        "params": {
          "_juror": "The address of the juror."
        }
      },
      "getJurorLeftoverPNK(address)": {
        "params": {
          "_juror": "The address of the juror."
        },
        "returns": {
          "_0": "Whether the juror has leftover PNK."
        }
      },
      "initialize(address,address,uint256,uint256,address,uint256,uint256)": {
        "params": {
          "_core": "The KlerosCore.",
          "_maxDrawingTime": "Time after which the drawing phase can be switched",
          "_maxStakePerJuror": "The maximum amount of PNK a juror can stake across the courts.",
          "_maxTotalStaked": "The maximum amount of PNK that all the jurors can stake across the courts.",
          "_minStakingTime": "Minimal time to stake",
          "_owner": "The owner.",
          "_rng": "The random number generator."
        }
      },
      "isJurorStaked(address)": {
        "params": {
          "_juror": "The address of the juror."
        },
        "returns": {
          "_0": "Whether the juror is staked or not."
        }
      },
      "lockStake(address,uint256)": {
        "params": {
          "_account": "The address of the juror.",
          "_relativeAmount": "The amount to lock."
        }
      },
      "postDrawHook(uint256,uint256)": {
        "params": {
          "_disputeID": "The ID of the dispute.",
          "_roundID": "The ID of the round."
        }
      },
      "proxiableUUID()": {
        "details": "IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the if statement."
      },
      "setStake(address,uint96,uint256,uint256,uint256)": {
        "details": "`O(n + p * log_k(j))` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.",
        "params": {
          "_account": "The address of the juror.",
          "_courtID": "The ID of the court.",
          "_newStake": "The new stake.",
          "_pnkDeposit": "The amount of PNK to be deposited.",
          "_pnkWithdrawal": "The amount of PNK to be withdrawn."
        }
      },
      "setStakePenalty(address,uint96,uint256)": {
        "details": "`O(n + p * log_k(j))` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.",
        "params": {
          "_account": "The address of the juror.",
          "_courtID": "The ID of the court.",
          "_penalty": "The amount of PNK to be deducted."
        },
        "returns": {
          "availablePenalty": "The amount of PNK that was actually deducted.",
          "newCourtStake": "The updated stake of the juror in the court.",
          "pnkBalance": "The updated total PNK balance of the juror, including the penalty."
        }
      },
      "setStakeReward(address,uint96,uint256)": {
        "details": "`O(n + p * log_k(j))` where `O(n + p * log_k(j))` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.",
        "params": {
          "_account": "The address of the juror.",
          "_courtID": "The ID of the court.",
          "_reward": "The amount of PNK to be deposited as a reward."
        },
        "returns": {
          "success": "True if the reward was added successfully."
        }
      },
      "unlockStake(address,uint256)": {
        "params": {
          "_account": "The address of the juror.",
          "_relativeAmount": "The amount to unlock."
        }
      },
      "upgradeToAndCall(address,bytes)": {
        "details": "Reverts if the execution is not performed via delegatecall or the execution context is not of a proxy with an ERC1967-compliant implementation pointing to self.",
        "params": {
          "data": "Data used in a delegate call to `newImplementation` if non-empty. This will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.",
          "newImplementation": "Address of the new implementation contract."
        }
      },
      "validateStake(address,uint96,uint256,bool)": {
        "details": "No state changes should be made when returning stakingResult != Successful, otherwise delayed stakes might break invariants.",
        "params": {
          "_account": "The address of the juror.",
          "_courtID": "The ID of the court.",
          "_newStake": "The new stake.",
          "_noDelay": "True if the stake change should not be delayed."
        },
        "returns": {
          "pnkDeposit": "The amount of PNK to be deposited.",
          "pnkWithdrawal": "The amount of PNK to be withdrawn.",
          "stakingResult": "The result of the staking operation."
        }
      },
      "withdrawLeftoverPNK(address)": {
        "details": "that since locked and staked PNK are async it is possible for the juror to have positive staked PNK balance while having 0 stake in courts and 0 locked tokens (eg. when the juror fully unstaked during dispute and later got his tokens unlocked). In this case the juror can use this function to withdraw the leftover tokens. Also note that if the juror has some leftover PNK while not fully unstaked he'll have to manually unstake from all courts to trigger this function.",
        "params": {
          "_account": "The juror whose PNK to withdraw."
        }
      }
    },
    "stateVariables": {
      "version": {
        "return": "Version string.",
        "returns": {
          "_0": "Version string."
        }
      }
    },
    "title": "SortitionModule",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "FailedDelegateCall()": [
        {
          "notice": "Failed Delegated call"
        }
      ],
      "InvalidImplementation(address)": [
        {
          "notice": "The `implementation` is not UUPS-compliant"
        }
      ],
      "UUPSUnauthorizedCallContext()": [
        {
          "notice": "The call is from an unauthorized context."
        }
      ],
      "UUPSUnsupportedProxiableUUID(bytes32)": [
        {
          "notice": "The storage `slot` is unsupported as a UUID."
        }
      ]
    },
    "events": {
      "LeftoverPNK(address,uint256)": {
        "notice": "Emitted when leftover PNK is available."
      },
      "LeftoverPNKWithdrawn(address,uint256)": {
        "notice": "Emitted when leftover PNK is withdrawn."
      },
      "NewPhase(uint8)": {
        "notice": "Emitted when the phase is changed."
      },
      "StakeDelayed(address,uint96,uint256)": {
        "notice": "Emitted when a juror's stake is delayed."
      },
      "StakeDelayedExecutionFailed(address,uint96,uint256)": {
        "notice": "Emitted when a juror's stake is delayed execution fails."
      },
      "StakeLocked(address,uint256,bool)": {
        "notice": "Emitted when a juror's stake is locked."
      },
      "StakeSet(address,uint256,uint256,uint256)": {
        "notice": "Emitted when a juror stakes in a court."
      },
      "Upgraded(address)": {
        "notice": "Emitted when the `implementation` has been successfully upgraded."
      }
    },
    "kind": "user",
    "methods": {
      "changeMaxDrawingTime(uint256)": {
        "notice": "Changes the `maxDrawingTime` storage variable."
      },
      "changeMaxStakePerJuror(uint256)": {
        "notice": "Changes the `maxStakePerJuror` storage variable."
      },
      "changeMaxTotalStaked(uint256)": {
        "notice": "Changes the `maxTotalStaked` storage variable."
      },
      "changeMinStakingTime(uint256)": {
        "notice": "Changes the `minStakingTime` storage variable."
      },
      "changeOwner(address)": {
        "notice": "Changes the owner of the contract."
      },
      "changeRandomNumberGenerator(address)": {
        "notice": "Changes the `rng` storage variable."
      },
      "createDisputeHook(uint256,uint256)": {
        "notice": "Triggers the state changes after dispute creation."
      },
      "createTree(uint96,bytes)": {
        "notice": "Create a sortition sum tree at the specified key."
      },
      "draw(uint96,uint256,uint256)": {
        "notice": "Draw an ID from a tree using a number."
      },
      "executeDelayedStakes(uint256)": {
        "notice": "Executes the next delayed stakes."
      },
      "forcedUnstake(address,uint96)": {
        "notice": "Unstakes the inactive juror from a specific court."
      },
      "forcedUnstakeAllCourts(address)": {
        "notice": "Unstakes the inactive juror from all courts."
      },
      "getJurorBalance(address,uint96)": {
        "notice": "Gets the balance of a juror in a court."
      },
      "getJurorCourtIDs(address)": {
        "notice": "Gets the court identifiers where a specific `_juror` has staked."
      },
      "getJurorLeftoverPNK(address)": {
        "notice": "Checks if the juror has any leftover PNK in the contract."
      },
      "initialize(address,address,uint256,uint256,address,uint256,uint256)": {
        "notice": "Initializer (constructor equivalent for upgradable contracts)."
      },
      "isJurorStaked(address)": {
        "notice": "Checks if the juror is staked in any court."
      },
      "lockStake(address,uint256)": {
        "notice": "Locks the tokens of the drawn juror."
      },
      "passPhase()": {
        "notice": "Passes the phase."
      },
      "postDrawHook(uint256,uint256)": {
        "notice": "Triggers the state changes after drawing."
      },
      "proxiableUUID()": {
        "notice": "Implementation of the ERC1822 `proxiableUUID` function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade."
      },
      "setStake(address,uint96,uint256,uint256,uint256)": {
        "notice": "Update the state of the stakes, called by KC at the end of setStake flow."
      },
      "setStakePenalty(address,uint96,uint256)": {
        "notice": "Update the state of the stakes with a PNK penalty, called by KC during rewards execution."
      },
      "setStakeReward(address,uint96,uint256)": {
        "notice": "Update the state of the stakes with a PNK reward deposit, called by KC during rewards execution."
      },
      "unlockStake(address,uint256)": {
        "notice": "Unlocks the tokens of the drawn juror."
      },
      "upgradeToAndCall(address,bytes)": {
        "notice": "Upgrade mechanism including access control and UUPS-compliance."
      },
      "validateStake(address,uint96,uint256,bool)": {
        "notice": "Validate the specified juror's new stake for a court."
      },
      "version()": {
        "notice": "Returns the version of the implementation."
      },
      "withdrawLeftoverPNK(address)": {
        "notice": "Gives back the locked PNKs in case the juror fully unstaked earlier."
      }
    },
    "notice": "A factory of trees that keeps track of staked values for sortition.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 16568,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 16571,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "core",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(KlerosCore)16395"
      },
      {
        "astId": 16574,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "phase",
        "offset": 20,
        "slot": "1",
        "type": "t_enum(Phase)26790"
      },
      {
        "astId": 16576,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "minStakingTime",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 16578,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "maxDrawingTime",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 16580,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "lastPhaseChange",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 16582,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "disputesWithoutJurors",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 16585,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "rng",
        "offset": 0,
        "slot": "6",
        "type": "t_contract(IRNG)40220"
      },
      {
        "astId": 16587,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "randomNumber",
        "offset": 0,
        "slot": "7",
        "type": "t_uint256"
      },
      {
        "astId": 16589,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "delayedStakeWriteIndex",
        "offset": 0,
        "slot": "8",
        "type": "t_uint256"
      },
      {
        "astId": 16591,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "delayedStakeReadIndex",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 16597,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "sortitionSumTrees",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_userDefinedValueType(TreeKey)37762,t_struct(Tree)37785_storage)"
      },
      {
        "astId": 16602,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "jurors",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_address,t_struct(Juror)16566_storage)"
      },
      {
        "astId": 16607,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "delayedStakes",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_uint256,t_struct(DelayedStake)16558_storage)"
      },
      {
        "astId": 16609,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "maxStakePerJuror",
        "offset": 0,
        "slot": "13",
        "type": "t_uint256"
      },
      {
        "astId": 16611,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "maxTotalStaked",
        "offset": 0,
        "slot": "14",
        "type": "t_uint256"
      },
      {
        "astId": 16613,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "totalStaked",
        "offset": 0,
        "slot": "15",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint96)dyn_storage": {
        "base": "t_uint96",
        "encoding": "dynamic_array",
        "label": "uint96[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IRNG)40220": {
        "encoding": "inplace",
        "label": "contract IRNG",
        "numberOfBytes": "20"
      },
      "t_contract(KlerosCore)16395": {
        "encoding": "inplace",
        "label": "contract KlerosCore",
        "numberOfBytes": "20"
      },
      "t_enum(Phase)26790": {
        "encoding": "inplace",
        "label": "enum ISortitionModule.Phase",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_struct(Juror)16566_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct SortitionModule.Juror)",
        "numberOfBytes": "32",
        "value": "t_struct(Juror)16566_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint256,t_struct(DelayedStake)16558_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct SortitionModule.DelayedStake)",
        "numberOfBytes": "32",
        "value": "t_struct(DelayedStake)16558_storage"
      },
      "t_mapping(t_userDefinedValueType(TreeKey)37762,t_struct(Tree)37785_storage)": {
        "encoding": "mapping",
        "key": "t_userDefinedValueType(TreeKey)37762",
        "label": "mapping(TreeKey => struct SortitionTrees.Tree)",
        "numberOfBytes": "32",
        "value": "t_struct(Tree)37785_storage"
      },
      "t_struct(DelayedStake)16558_storage": {
        "encoding": "inplace",
        "label": "struct SortitionModule.DelayedStake",
        "members": [
          {
            "astId": 16553,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "account",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 16555,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "courtID",
            "offset": 20,
            "slot": "0",
            "type": "t_uint96"
          },
          {
            "astId": 16557,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "stake",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Juror)16566_storage": {
        "encoding": "inplace",
        "label": "struct SortitionModule.Juror",
        "members": [
          {
            "astId": 16561,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "courtIDs",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint96)dyn_storage"
          },
          {
            "astId": 16563,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "stakedPnk",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 16565,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "lockedPnk",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Tree)37785_storage": {
        "encoding": "inplace",
        "label": "struct SortitionTrees.Tree",
        "members": [
          {
            "astId": 37770,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "K",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 37773,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "stack",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 37776,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "nodes",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 37780,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "IDsToNodeIndexes",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 37784,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "nodeIndexesToIDs",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_uint256,t_bytes32)"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint96": {
        "encoding": "inplace",
        "label": "uint96",
        "numberOfBytes": "12"
      },
      "t_userDefinedValueType(TreeKey)37762": {
        "encoding": "inplace",
        "label": "TreeKey",
        "numberOfBytes": "32"
      }
    }
  }
}
