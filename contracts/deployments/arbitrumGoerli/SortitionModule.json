{
  "address": "0x5Ae75Db8B66B574b2c5C29eE4D32cc9Fe62bfdEE",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_governor",
          "type": "address"
        },
        {
          "internalType": "contract KlerosCore",
          "name": "_core",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_minStakingTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxDrawingTime",
          "type": "uint256"
        },
        {
          "internalType": "contract RNG",
          "name": "_rng",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_rngLookahead",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum ISortitionModule.Phase",
          "name": "_phase",
          "type": "uint8"
        }
      ],
      "name": "NewPhase",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DEFAULT_K",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_STAKE_PATHS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxDrawingTime",
          "type": "uint256"
        }
      ],
      "name": "changeMaxDrawingTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minStakingTime",
          "type": "uint256"
        }
      ],
      "name": "changeMinStakingTime",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract RNG",
          "name": "_rng",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_rngLookahead",
          "type": "uint256"
        }
      ],
      "name": "changeRandomNumberGenerator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "core",
      "outputs": [
        {
          "internalType": "contract KlerosCore",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "createDisputeHook",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "createTree",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delayedStakeReadIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delayedStakeWriteIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "delayedStakes",
      "outputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "stake",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "penalty",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "disputesWithoutJurors",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_key",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_coreDisputeID",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_voteID",
          "type": "uint256"
        }
      ],
      "name": "draw",
      "outputs": [
        {
          "internalType": "address",
          "name": "drawnAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_iterations",
          "type": "uint256"
        }
      ],
      "name": "executeDelayedStakes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governor",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastPhaseChange",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxDrawingTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minStakingTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_randomNumber",
          "type": "uint256"
        }
      ],
      "name": "notifyRandomNumber",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "passPhase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "phase",
      "outputs": [
        {
          "internalType": "enum ISortitionModule.Phase",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "postDrawHook",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "_stake",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_penalty",
          "type": "uint256"
        }
      ],
      "name": "preStakeHook",
      "outputs": [
        {
          "internalType": "enum ISortitionModule.preStakeHookResult",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "randomNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "randomNumberRequestBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rng",
      "outputs": [
        {
          "internalType": "contract RNG",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rngLookahead",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        }
      ],
      "name": "setJurorInactive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_account",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "_courtID",
          "type": "uint96"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "setStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x9149980884d8a547e28f64de0ac06a4faa7ab6254a46b650147a0d6ebcee8755",
  "receipt": {
    "to": null,
    "from": "0xF50E77f2A2B6138D16c6c7511562E5C33c4B15A3",
    "contractAddress": "0x5Ae75Db8B66B574b2c5C29eE4D32cc9Fe62bfdEE",
    "transactionIndex": 1,
    "gasUsed": "1822849",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd3771b40ef9cde7ccad081915037bbba5b8f500b0ca9a869d513766d87df0717",
    "transactionHash": "0x9149980884d8a547e28f64de0ac06a4faa7ab6254a46b650147a0d6ebcee8755",
    "logs": [],
    "blockNumber": 27808421,
    "cumulativeGasUsed": "1822849",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xF50E77f2A2B6138D16c6c7511562E5C33c4B15A3",
    "0x8Af82E2F8890acb4AB84cbaB3c4C4Eb3E965CF24",
    1800,
    1800,
    "0xa90f7D2e35718FDE9AD96c8B6667AFcAa4BEfd4d",
    20
  ],
  "numDeployments": 3,
  "solcInputHash": "961befc2fb36daa22c7c449f4b260d32",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"contract KlerosCore\",\"name\":\"_core\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minStakingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDrawingTime\",\"type\":\"uint256\"},{\"internalType\":\"contract RNG\",\"name\":\"_rng\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rngLookahead\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum ISortitionModule.Phase\",\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"NewPhase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_K\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_STAKE_PATHS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDrawingTime\",\"type\":\"uint256\"}],\"name\":\"changeMaxDrawingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakingTime\",\"type\":\"uint256\"}],\"name\":\"changeMinStakingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract RNG\",\"name\":\"_rng\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rngLookahead\",\"type\":\"uint256\"}],\"name\":\"changeRandomNumberGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"contract KlerosCore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createDisputeHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"createTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedStakeReadIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedStakeWriteIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedStakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputesWithoutJurors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_coreDisputeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_voteID\",\"type\":\"uint256\"}],\"name\":\"draw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"drawnAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_iterations\",\"type\":\"uint256\"}],\"name\":\"executeDelayedStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPhaseChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDrawingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_randomNumber\",\"type\":\"uint256\"}],\"name\":\"notifyRandomNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"internalType\":\"enum ISortitionModule.Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"postDrawHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_penalty\",\"type\":\"uint256\"}],\"name\":\"preStakeHook\",\"outputs\":[{\"internalType\":\"enum ISortitionModule.preStakeHookResult\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomNumberRequestBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rng\",\"outputs\":[{\"internalType\":\"contract RNG\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rngLookahead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setJurorInactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_courtID\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"A factory of trees that keeps track of staked values for sortition.\",\"kind\":\"dev\",\"methods\":{\"changeMaxDrawingTime(uint256)\":{\"details\":\"Changes the `maxDrawingTime` storage variable.\",\"params\":{\"_maxDrawingTime\":\"The new value for the `maxDrawingTime` storage variable.\"}},\"changeMinStakingTime(uint256)\":{\"details\":\"Changes the `minStakingTime` storage variable.\",\"params\":{\"_minStakingTime\":\"The new value for the `minStakingTime` storage variable.\"}},\"changeRandomNumberGenerator(address,uint256)\":{\"details\":\"Changes the `_rng` and `_rngLookahead` storage variables.\",\"params\":{\"_rng\":\"The new value for the `RNGenerator` storage variable.\",\"_rngLookahead\":\"The new value for the `rngLookahead` storage variable.\"}},\"constructor\":{\"details\":\"Constructor.\",\"params\":{\"_core\":\"The KlerosCore.\",\"_maxDrawingTime\":\"Time after which the drawing phase can be switched\",\"_minStakingTime\":\"Minimal time to stake\",\"_rng\":\"The random number generator.\",\"_rngLookahead\":\"Lookahead value for rng.\"}},\"createTree(bytes32,bytes)\":{\"details\":\"Create a sortition sum tree at the specified key.\",\"params\":{\"_extraData\":\"Extra data that contains the number of children each node in the tree should have.\",\"_key\":\"The key of the new tree.\"}},\"draw(bytes32,uint256,uint256)\":{\"details\":\"Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\",\"params\":{\"_coreDisputeID\":\"Index of the dispute in Kleros Core.\",\"_key\":\"The key of the tree.\",\"_voteID\":\"ID of the voter.\"},\"returns\":{\"drawnAddress\":\"The drawn address. `O(k * log_k(n))` where `k` is the maximum number of children per node in the tree,  and `n` is the maximum number of nodes ever appended.\"}},\"executeDelayedStakes(uint256)\":{\"details\":\"Executes the next delayed stakes.\",\"params\":{\"_iterations\":\"The number of delayed stakes to execute.\"}},\"notifyRandomNumber(uint256)\":{\"details\":\"Saves the random number to use it in sortition. Not used by this contract because the storing of the number is inlined in passPhase().\",\"params\":{\"_randomNumber\":\"Random number returned by RNG contract.\"}},\"setJurorInactive(address)\":{\"details\":\"Unstakes the inactive juror from all courts. `O(n * (p * log_k(j)) )` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\",\"params\":{\"_account\":\"The juror to unstake.\"}},\"setStake(address,uint96,uint256)\":{\"details\":\"Sets the value for a particular court and its parent courts.\",\"params\":{\"_account\":\"Address of the juror. `O(log_k(n))` where `k` is the maximum number of children per node in the tree,  and `n` is the maximum number of nodes ever appended.\",\"_courtID\":\"ID of the court.\",\"_value\":\"The new value.\"}}},\"title\":\"SortitionModule\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/arbitration/SortitionModule.sol\":\"SortitionModule\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"src/arbitration/KlerosCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/// @custom:authors: [@unknownunknown1, @jaybuidl]\\n/// @custom:reviewers: []\\n/// @custom:auditors: []\\n/// @custom:bounties: []\\n/// @custom:deployments: []\\n\\npragma solidity 0.8.18;\\n\\nimport {IArbitrableV2, IArbitratorV2} from \\\"./interfaces/IArbitratorV2.sol\\\";\\nimport \\\"./interfaces/IDisputeKit.sol\\\";\\nimport \\\"./interfaces/ISortitionModule.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\n/// @title KlerosCore\\n/// Core arbitrator contract for Kleros v2.\\n/// Note that this contract trusts the PNK token, the dispute kit and the sortition module contracts.\\ncontract KlerosCore is IArbitratorV2 {\\n    using SafeERC20 for IERC20;\\n\\n    // ************************************* //\\n    // *         Enums / Structs           * //\\n    // ************************************* //\\n\\n    enum Period {\\n        evidence, // Evidence can be submitted. This is also when drawing has to take place.\\n        commit, // Jurors commit a hashed vote. This is skipped for courts without hidden votes.\\n        vote, // Jurors reveal/cast their vote depending on whether the court has hidden votes or not.\\n        appeal, // The dispute can be appealed.\\n        execution // Tokens are redistributed and the ruling is executed.\\n    }\\n\\n    struct Court {\\n        uint96 parent; // The parent court.\\n        bool hiddenVotes; // Whether to use commit and reveal or not.\\n        uint256[] children; // List of child courts.\\n        uint256 minStake; // Minimum PNKs needed to stake in the court.\\n        uint256 alpha; // Basis point of PNKs that are lost when incoherent.\\n        uint256 feeForJuror; // Arbitration fee paid per juror.\\n        uint256 jurorsForCourtJump; // The appeal after the one that reaches this number of jurors will go to the parent court if any.\\n        uint256[4] timesPerPeriod; // The time allotted to each dispute period in the form `timesPerPeriod[period]`.\\n        mapping(uint256 => bool) supportedDisputeKits; // True if DK with this ID is supported by the court.\\n        bool disabled; // True if the court is disabled. Unused for now, will be implemented later.\\n    }\\n\\n    struct Dispute {\\n        uint96 courtID; // The ID of the court the dispute is in.\\n        IArbitrableV2 arbitrated; // The arbitrable contract.\\n        Period period; // The current period of the dispute.\\n        bool ruled; // True if the ruling has been executed, false otherwise.\\n        uint256 lastPeriodChange; // The last time the period was changed.\\n        Round[] rounds;\\n    }\\n\\n    struct Round {\\n        uint256 disputeKitID; // Index of the dispute kit in the array.\\n        uint256 pnkAtStakePerJuror; // The amount of PNKs at stake for each juror in this round.\\n        uint256 totalFeesForJurors; // The total juror fees paid in this round.\\n        uint256 nbVotes; // The total number of votes the dispute can possibly have in the current round. Former votes[_round].length.\\n        uint256 repartitions; // A counter of reward repartitions made in this round.\\n        uint256 pnkPenalties; // The amount of PNKs collected from penalties in this round.\\n        address[] drawnJurors; // Addresses of the jurors that were drawn in this round.\\n        uint256 sumFeeRewardPaid; // Total sum of arbitration fees paid to coherent jurors as a reward in this round.\\n        uint256 sumPnkRewardPaid; // Total sum of PNK paid to coherent jurors as a reward in this round.\\n        IERC20 feeToken; // The token used for paying fees in this round.\\n    }\\n\\n    struct Juror {\\n        uint96[] courtIDs; // The IDs of courts where the juror's stake path ends. A stake path is a path from the general court to a court the juror directly staked in using `_setStake`.\\n        mapping(uint96 => uint256) stakedPnk; // The amount of PNKs the juror has staked in the court in the form `stakedPnk[courtID]`.\\n        mapping(uint96 => uint256) lockedPnk; // The amount of PNKs the juror has locked in the court in the form `lockedPnk[courtID]`.\\n    }\\n\\n    struct DisputeKitNode {\\n        uint256 parent; // Index of the parent dispute kit. If it's 0 then this DK is a root.\\n        uint256[] children; // List of child dispute kits.\\n        IDisputeKit disputeKit; // The dispute kit implementation.\\n        uint256 depthLevel; // How far this DK is from the root. 0 for root DK.\\n        bool disabled; // True if the dispute kit is disabled and can't be used. This parameter is added preemptively to avoid storage changes in the future.\\n    }\\n\\n    // Workaround \\\"stack too deep\\\" errors\\n    struct ExecuteParams {\\n        uint256 disputeID; // The ID of the dispute to execute.\\n        uint256 round; // The round to execute.\\n        uint256 coherentCount; // The number of coherent votes in the round.\\n        uint256 numberOfVotesInRound; // The number of votes in the round.\\n        uint256 pnkPenaltiesInRound; // The amount of PNKs collected from penalties in the round.\\n        uint256 repartition; // The index of the repartition to execute.\\n    }\\n\\n    struct CurrencyRate {\\n        bool feePaymentAccepted;\\n        uint64 rateInEth;\\n        uint8 rateDecimals;\\n    }\\n\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    uint96 public constant FORKING_COURT = 0; // Index of the forking court.\\n    uint96 public constant GENERAL_COURT = 1; // Index of the default (general) court.\\n    uint256 public constant NULL_DISPUTE_KIT = 0; // Null pattern to indicate a top-level DK which has no parent.\\n    uint256 public constant DISPUTE_KIT_CLASSIC = 1; // Index of the default DK. 0 index is skipped.\\n    uint256 public constant DEFAULT_NB_OF_JURORS = 3; // The default number of jurors in a dispute.\\n    uint256 public constant ALPHA_DIVISOR = 1e4; // The number to divide `Court.alpha` by.\\n    uint256 public constant NON_PAYABLE_AMOUNT = (2 ** 256 - 2) / 2; // An amount higher than the supply of ETH.\\n    uint256 public constant SEARCH_ITERATIONS = 10; // Number of iterations to search for suitable parent court before jumping to the top court.\\n    IERC20 public constant NATIVE_CURRENCY = IERC20(address(0)); // The native currency, such as ETH on Arbitrum, Optimism and Ethereum L1.\\n\\n    address public governor; // The governor of the contract.\\n    IERC20 public pinakion; // The Pinakion token contract.\\n    // TODO: interactions with jurorProsecutionModule.\\n    address public jurorProsecutionModule; // The module for juror's prosecution.\\n    ISortitionModule public sortitionModule; // Sortition module for drawing.\\n    Court[] public courts; // The courts.\\n    DisputeKitNode[] public disputeKitNodes; // The list of DisputeKitNode, indexed by DisputeKitID.\\n    Dispute[] public disputes; // The disputes.\\n    mapping(address => Juror) internal jurors; // The jurors.\\n    mapping(IERC20 => CurrencyRate) public currencyRates; // The price of each token in ETH.\\n\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    event StakeSet(address indexed _address, uint256 _courtID, uint256 _amount);\\n    event StakeDelayed(address indexed _address, uint256 _courtID, uint256 _amount, uint256 _penalty);\\n    event NewPeriod(uint256 indexed _disputeID, Period _period);\\n    event AppealPossible(uint256 indexed _disputeID, IArbitrableV2 indexed _arbitrable);\\n    event AppealDecision(uint256 indexed _disputeID, IArbitrableV2 indexed _arbitrable);\\n    event Draw(address indexed _address, uint256 indexed _disputeID, uint256 _roundID, uint256 _voteID);\\n    event CourtCreated(\\n        uint256 indexed _courtID,\\n        uint96 indexed _parent,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] _timesPerPeriod,\\n        uint256[] _supportedDisputeKits\\n    );\\n    event CourtModified(\\n        uint96 indexed _courtID,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] _timesPerPeriod\\n    );\\n    event DisputeKitCreated(\\n        uint256 indexed _disputeKitID,\\n        IDisputeKit indexed _disputeKitAddress,\\n        uint256 indexed _parent\\n    );\\n    event DisputeKitEnabled(uint96 indexed _courtID, uint256 indexed _disputeKitID, bool indexed _enable);\\n    event CourtJump(\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint96 indexed _fromCourtID,\\n        uint96 _toCourtID\\n    );\\n    event DisputeKitJump(\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint256 indexed _fromDisputeKitID,\\n        uint256 _toDisputeKitID\\n    );\\n    event TokenAndETHShift(\\n        address indexed _account,\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint256 _degreeOfCoherency,\\n        int256 _pnkAmount,\\n        int256 _feeAmount,\\n        IERC20 _feeToken\\n    );\\n    event LeftoverRewardSent(\\n        uint256 indexed _disputeID,\\n        uint256 indexed _roundID,\\n        uint256 _pnkAmount,\\n        uint256 _feeAmount,\\n        IERC20 _feeToken\\n    );\\n\\n    // ************************************* //\\n    // *        Function Modifiers         * //\\n    // ************************************* //\\n\\n    modifier onlyByGovernor() {\\n        if (governor != msg.sender) revert GovernorOnly();\\n        _;\\n    }\\n\\n    /// @dev Constructor.\\n    /// @param _governor The governor's address.\\n    /// @param _pinakion The address of the token contract.\\n    /// @param _jurorProsecutionModule The address of the juror prosecution module.\\n    /// @param _disputeKit The address of the default dispute kit.\\n    /// @param _hiddenVotes The `hiddenVotes` property value of the general court.\\n    /// @param _courtParameters Numeric parameters of General court (minStake, alpha, feeForJuror and jurorsForCourtJump respectively).\\n    /// @param _timesPerPeriod The `timesPerPeriod` property value of the general court.\\n    /// @param _sortitionExtraData The extra data for sortition module.\\n    /// @param _sortitionModuleAddress The sortition module responsible for sortition of the jurors.\\n    constructor(\\n        address _governor,\\n        IERC20 _pinakion,\\n        address _jurorProsecutionModule,\\n        IDisputeKit _disputeKit,\\n        bool _hiddenVotes,\\n        uint256[4] memory _courtParameters,\\n        uint256[4] memory _timesPerPeriod,\\n        bytes memory _sortitionExtraData,\\n        ISortitionModule _sortitionModuleAddress\\n    ) {\\n        governor = _governor;\\n        pinakion = _pinakion;\\n        jurorProsecutionModule = _jurorProsecutionModule;\\n        sortitionModule = _sortitionModuleAddress;\\n\\n        // NULL_DISPUTE_KIT: an empty element at index 0 to indicate when a node has no parent.\\n        disputeKitNodes.push();\\n\\n        // DISPUTE_KIT_CLASSIC\\n        disputeKitNodes.push(\\n            DisputeKitNode({\\n                parent: NULL_DISPUTE_KIT,\\n                children: new uint256[](0),\\n                disputeKit: _disputeKit,\\n                depthLevel: 0,\\n                disabled: false\\n            })\\n        );\\n        emit DisputeKitCreated(DISPUTE_KIT_CLASSIC, _disputeKit, NULL_DISPUTE_KIT);\\n\\n        // FORKING_COURT\\n        // TODO: Fill the properties for the Forking court, emit CourtCreated.\\n        courts.push();\\n        sortitionModule.createTree(bytes32(uint256(FORKING_COURT)), _sortitionExtraData);\\n\\n        // GENERAL_COURT\\n        Court storage court = courts.push();\\n        court.parent = FORKING_COURT;\\n        court.children = new uint256[](0);\\n        court.hiddenVotes = _hiddenVotes;\\n        court.minStake = _courtParameters[0];\\n        court.alpha = _courtParameters[1];\\n        court.feeForJuror = _courtParameters[2];\\n        court.jurorsForCourtJump = _courtParameters[3];\\n        court.timesPerPeriod = _timesPerPeriod;\\n\\n        sortitionModule.createTree(bytes32(uint256(GENERAL_COURT)), _sortitionExtraData);\\n\\n        emit CourtCreated(\\n            1,\\n            court.parent,\\n            _hiddenVotes,\\n            _courtParameters[0],\\n            _courtParameters[1],\\n            _courtParameters[2],\\n            _courtParameters[3],\\n            _timesPerPeriod,\\n            new uint256[](0)\\n        );\\n        _enableDisputeKit(GENERAL_COURT, DISPUTE_KIT_CLASSIC, true);\\n    }\\n\\n    // ************************************* //\\n    // *             Governance            * //\\n    // ************************************* //\\n\\n    /// @dev Allows the governor to call anything on behalf of the contract.\\n    /// @param _destination The destination of the call.\\n    /// @param _amount The value sent with the call.\\n    /// @param _data The data sent with the call.\\n    function executeGovernorProposal(\\n        address _destination,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) external onlyByGovernor {\\n        (bool success, ) = _destination.call{value: _amount}(_data);\\n        if (!success) revert UnsuccessfulCall();\\n    }\\n\\n    /// @dev Changes the `governor` storage variable.\\n    /// @param _governor The new value for the `governor` storage variable.\\n    function changeGovernor(address payable _governor) external onlyByGovernor {\\n        governor = _governor;\\n    }\\n\\n    /// @dev Changes the `pinakion` storage variable.\\n    /// @param _pinakion The new value for the `pinakion` storage variable.\\n    function changePinakion(IERC20 _pinakion) external onlyByGovernor {\\n        pinakion = _pinakion;\\n    }\\n\\n    /// @dev Changes the `jurorProsecutionModule` storage variable.\\n    /// @param _jurorProsecutionModule The new value for the `jurorProsecutionModule` storage variable.\\n    function changeJurorProsecutionModule(address _jurorProsecutionModule) external onlyByGovernor {\\n        jurorProsecutionModule = _jurorProsecutionModule;\\n    }\\n\\n    /// @dev Changes the `_sortitionModule` storage variable.\\n    /// Note that the new module should be initialized for all courts.\\n    /// @param _sortitionModule The new value for the `sortitionModule` storage variable.\\n    function changeSortitionModule(ISortitionModule _sortitionModule) external onlyByGovernor {\\n        sortitionModule = _sortitionModule;\\n    }\\n\\n    /// @dev Add a new supported dispute kit module to the court.\\n    /// @param _disputeKitAddress The address of the dispute kit contract.\\n    /// @param _parent The ID of the parent dispute kit. It is left empty when root DK is created.\\n    /// Note that the root DK must be supported by the general court.\\n    function addNewDisputeKit(IDisputeKit _disputeKitAddress, uint256 _parent) external onlyByGovernor {\\n        uint256 disputeKitID = disputeKitNodes.length;\\n        if (_parent >= disputeKitID) revert InvalidDisputKitParent();\\n        uint256 depthLevel;\\n        if (_parent != NULL_DISPUTE_KIT) {\\n            depthLevel = disputeKitNodes[_parent].depthLevel + 1;\\n            // It should be always possible to reach the root from the leaf with the defined number of search iterations.\\n            if (depthLevel >= SEARCH_ITERATIONS) revert DepthLevelMax();\\n        }\\n        disputeKitNodes.push(\\n            DisputeKitNode({\\n                parent: _parent,\\n                children: new uint256[](0),\\n                disputeKit: _disputeKitAddress,\\n                depthLevel: depthLevel,\\n                disabled: false\\n            })\\n        );\\n\\n        disputeKitNodes[_parent].children.push(disputeKitID);\\n        emit DisputeKitCreated(disputeKitID, _disputeKitAddress, _parent);\\n        if (_parent == NULL_DISPUTE_KIT) {\\n            // A new dispute kit tree root should always be supported by the General court.\\n            _enableDisputeKit(GENERAL_COURT, disputeKitID, true);\\n        }\\n    }\\n\\n    /// @dev Creates a court under a specified parent court.\\n    /// @param _parent The `parent` property value of the court.\\n    /// @param _hiddenVotes The `hiddenVotes` property value of the court.\\n    /// @param _minStake The `minStake` property value of the court.\\n    /// @param _alpha The `alpha` property value of the court.\\n    /// @param _feeForJuror The `feeForJuror` property value of the court.\\n    /// @param _jurorsForCourtJump The `jurorsForCourtJump` property value of the court.\\n    /// @param _timesPerPeriod The `timesPerPeriod` property value of the court.\\n    /// @param _sortitionExtraData Extra data for sortition module.\\n    /// @param _supportedDisputeKits Indexes of dispute kits that this court will support.\\n    function createCourt(\\n        uint96 _parent,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] memory _timesPerPeriod,\\n        bytes memory _sortitionExtraData,\\n        uint256[] memory _supportedDisputeKits\\n    ) external onlyByGovernor {\\n        if (courts[_parent].minStake > _minStake) revert MinStakeLowerThanParentCourt();\\n        if (_supportedDisputeKits.length == 0) revert UnsupportedDisputeKit();\\n        if (_parent == FORKING_COURT) revert InvalidForkingCourtAsParent();\\n\\n        uint256 courtID = courts.length;\\n        Court storage court = courts.push();\\n\\n        for (uint256 i = 0; i < _supportedDisputeKits.length; i++) {\\n            if (_supportedDisputeKits[i] == 0 || _supportedDisputeKits[i] >= disputeKitNodes.length) {\\n                revert WrongDisputeKitIndex();\\n            }\\n            court.supportedDisputeKits[_supportedDisputeKits[i]] = true;\\n        }\\n\\n        court.parent = _parent;\\n        court.children = new uint256[](0);\\n        court.hiddenVotes = _hiddenVotes;\\n        court.minStake = _minStake;\\n        court.alpha = _alpha;\\n        court.feeForJuror = _feeForJuror;\\n        court.jurorsForCourtJump = _jurorsForCourtJump;\\n        court.timesPerPeriod = _timesPerPeriod;\\n\\n        sortitionModule.createTree(bytes32(courtID), _sortitionExtraData);\\n\\n        // Update the parent.\\n        courts[_parent].children.push(courtID);\\n        emit CourtCreated(\\n            courtID,\\n            _parent,\\n            _hiddenVotes,\\n            _minStake,\\n            _alpha,\\n            _feeForJuror,\\n            _jurorsForCourtJump,\\n            _timesPerPeriod,\\n            _supportedDisputeKits\\n        );\\n    }\\n\\n    function changeCourtParameters(\\n        uint96 _courtID,\\n        bool _hiddenVotes,\\n        uint256 _minStake,\\n        uint256 _alpha,\\n        uint256 _feeForJuror,\\n        uint256 _jurorsForCourtJump,\\n        uint256[4] memory _timesPerPeriod\\n    ) external onlyByGovernor {\\n        if (_courtID != GENERAL_COURT && courts[courts[_courtID].parent].minStake > _minStake) {\\n            revert MinStakeLowerThanParentCourt();\\n        }\\n        for (uint256 i = 0; i < courts[_courtID].children.length; i++) {\\n            if (courts[courts[_courtID].children[i]].minStake < _minStake) {\\n                revert MinStakeLowerThanParentCourt();\\n            }\\n        }\\n        courts[_courtID].minStake = _minStake;\\n        courts[_courtID].hiddenVotes = _hiddenVotes;\\n        courts[_courtID].alpha = _alpha;\\n        courts[_courtID].feeForJuror = _feeForJuror;\\n        courts[_courtID].jurorsForCourtJump = _jurorsForCourtJump;\\n        courts[_courtID].timesPerPeriod = _timesPerPeriod;\\n        emit CourtModified(\\n            _courtID,\\n            _hiddenVotes,\\n            _minStake,\\n            _alpha,\\n            _feeForJuror,\\n            _jurorsForCourtJump,\\n            _timesPerPeriod\\n        );\\n    }\\n\\n    /// @dev Adds/removes court's support for specified dispute kits.\\n    /// @param _courtID The ID of the court.\\n    /// @param _disputeKitIDs The IDs of dispute kits which support should be added/removed.\\n    /// @param _enable Whether add or remove the dispute kits from the court.\\n    function enableDisputeKits(uint96 _courtID, uint256[] memory _disputeKitIDs, bool _enable) external onlyByGovernor {\\n        for (uint256 i = 0; i < _disputeKitIDs.length; i++) {\\n            if (_enable) {\\n                if (_disputeKitIDs[i] == 0 || _disputeKitIDs[i] >= disputeKitNodes.length) {\\n                    revert WrongDisputeKitIndex();\\n                }\\n                _enableDisputeKit(_courtID, _disputeKitIDs[i], true);\\n            } else {\\n                if (_courtID == GENERAL_COURT && disputeKitNodes[_disputeKitIDs[i]].parent == NULL_DISPUTE_KIT) {\\n                    revert CannotDisableRootDKInGeneral();\\n                }\\n                _enableDisputeKit(_courtID, _disputeKitIDs[i], false);\\n            }\\n        }\\n    }\\n\\n    /// @dev Changes the supported fee tokens.\\n    /// @param _feeToken The fee token.\\n    /// @param _accepted Whether the token is supported or not as a method of fee payment.\\n    function changeAcceptedFeeTokens(IERC20 _feeToken, bool _accepted) external onlyByGovernor {\\n        currencyRates[_feeToken].feePaymentAccepted = _accepted;\\n        emit AcceptedFeeToken(_feeToken, _accepted);\\n    }\\n\\n    /// @dev Changes the currency rate of a fee token.\\n    /// @param _feeToken The fee token.\\n    /// @param _rateInEth The new rate of the fee token in ETH.\\n    /// @param _rateDecimals The new decimals of the fee token rate.\\n    function changeCurrencyRates(IERC20 _feeToken, uint64 _rateInEth, uint8 _rateDecimals) external onlyByGovernor {\\n        CurrencyRate storage rate = currencyRates[_feeToken];\\n        rate.rateInEth = _rateInEth;\\n        rate.rateDecimals = _rateDecimals;\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @dev Sets the caller's stake in a court.\\n    /// @param _courtID The ID of the court.\\n    /// @param _stake The new stake.\\n    function setStake(uint96 _courtID, uint256 _stake) external {\\n        if (!_setStakeForAccount(msg.sender, _courtID, _stake, 0)) revert StakingFailed();\\n    }\\n\\n    function setStakeBySortitionModule(address _account, uint96 _courtID, uint256 _stake, uint256 _penalty) external {\\n        if (msg.sender != address(sortitionModule)) revert WrongCaller();\\n        _setStakeForAccount(_account, _courtID, _stake, _penalty);\\n    }\\n\\n    /// @inheritdoc IArbitratorV2\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes memory _extraData\\n    ) external payable override returns (uint256 disputeID) {\\n        if (msg.value < arbitrationCost(_extraData)) revert ArbitrationFeesNotEnough();\\n\\n        return _createDispute(_numberOfChoices, _extraData, NATIVE_CURRENCY, msg.value);\\n    }\\n\\n    /// @inheritdoc IArbitratorV2\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData,\\n        IERC20 _feeToken,\\n        uint256 _feeAmount\\n    ) external override returns (uint256 disputeID) {\\n        if (!currencyRates[_feeToken].feePaymentAccepted) revert TokenNotAccepted();\\n        if (_feeAmount < arbitrationCost(_extraData, _feeToken)) revert ArbitrationFeesNotEnough();\\n\\n        require(_feeToken.safeTransferFrom(msg.sender, address(this), _feeAmount), \\\"Transfer failed\\\");\\n        return _createDispute(_numberOfChoices, _extraData, _feeToken, _feeAmount);\\n    }\\n\\n    function _createDispute(\\n        uint256 _numberOfChoices,\\n        bytes memory _extraData,\\n        IERC20 _feeToken,\\n        uint256 _feeAmount\\n    ) internal returns (uint256 disputeID) {\\n        (uint96 courtID, , uint256 disputeKitID) = _extraDataToCourtIDMinJurorsDisputeKit(_extraData);\\n        if (!courts[courtID].supportedDisputeKits[disputeKitID]) revert DisputeKitNotSupportedByCourt();\\n\\n        disputeID = disputes.length;\\n        Dispute storage dispute = disputes.push();\\n        dispute.courtID = courtID;\\n        dispute.arbitrated = IArbitrableV2(msg.sender);\\n        dispute.lastPeriodChange = block.timestamp;\\n\\n        IDisputeKit disputeKit = disputeKitNodes[disputeKitID].disputeKit;\\n        Court storage court = courts[dispute.courtID];\\n        Round storage round = dispute.rounds.push();\\n\\n        // Obtain the feeForJuror in the same currency as the _feeAmount\\n        uint256 feeForJuror = (_feeToken == NATIVE_CURRENCY)\\n            ? court.feeForJuror\\n            : convertEthToTokenAmount(_feeToken, court.feeForJuror);\\n        round.nbVotes = _feeAmount / feeForJuror;\\n        round.disputeKitID = disputeKitID;\\n        round.pnkAtStakePerJuror = (court.minStake * court.alpha) / ALPHA_DIVISOR;\\n        round.totalFeesForJurors = _feeAmount;\\n        round.feeToken = IERC20(_feeToken);\\n\\n        sortitionModule.createDisputeHook(disputeID, 0); // Default round ID.\\n\\n        disputeKit.createDispute(disputeID, _numberOfChoices, _extraData, round.nbVotes);\\n        emit DisputeCreation(disputeID, IArbitrableV2(msg.sender));\\n    }\\n\\n    /// @dev Passes the period of a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    function passPeriod(uint256 _disputeID) external {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Court storage court = courts[dispute.courtID];\\n\\n        uint256 currentRound = dispute.rounds.length - 1;\\n        Round storage round = dispute.rounds[currentRound];\\n        if (dispute.period == Period.evidence) {\\n            if (\\n                currentRound == 0 &&\\n                block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)]\\n            ) {\\n                revert EvidenceNotPassedAndNotAppeal();\\n            }\\n            if (round.drawnJurors.length != round.nbVotes) revert DisputeStillDrawing();\\n            dispute.period = court.hiddenVotes ? Period.commit : Period.vote;\\n        } else if (dispute.period == Period.commit) {\\n            if (\\n                block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)] &&\\n                !disputeKitNodes[round.disputeKitID].disputeKit.areCommitsAllCast(_disputeID)\\n            ) {\\n                revert CommitPeriodNotPassed();\\n            }\\n            dispute.period = Period.vote;\\n        } else if (dispute.period == Period.vote) {\\n            if (\\n                block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)] &&\\n                !disputeKitNodes[round.disputeKitID].disputeKit.areVotesAllCast(_disputeID)\\n            ) {\\n                revert VotePeriodNotPassed();\\n            }\\n            dispute.period = Period.appeal;\\n            emit AppealPossible(_disputeID, dispute.arbitrated);\\n        } else if (dispute.period == Period.appeal) {\\n            if (block.timestamp - dispute.lastPeriodChange < court.timesPerPeriod[uint256(dispute.period)]) {\\n                revert AppealPeriodNotPassed();\\n            }\\n            dispute.period = Period.execution;\\n        } else if (dispute.period == Period.execution) {\\n            revert DisputePeriodIsFinal();\\n        }\\n\\n        dispute.lastPeriodChange = block.timestamp;\\n        emit NewPeriod(_disputeID, dispute.period);\\n    }\\n\\n    /// @dev Draws jurors for the dispute. Can be called in parts.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _iterations The number of iterations to run.\\n    function draw(uint256 _disputeID, uint256 _iterations) external {\\n        Dispute storage dispute = disputes[_disputeID];\\n        uint256 currentRound = dispute.rounds.length - 1;\\n        Round storage round = dispute.rounds[currentRound];\\n        if (dispute.period != Period.evidence) revert NotEvidencePeriod();\\n\\n        IDisputeKit disputeKit = disputeKitNodes[round.disputeKitID].disputeKit;\\n\\n        uint256 startIndex = round.drawnJurors.length;\\n        uint256 endIndex = startIndex + _iterations <= round.nbVotes ? startIndex + _iterations : round.nbVotes;\\n\\n        for (uint256 i = startIndex; i < endIndex; i++) {\\n            address drawnAddress = disputeKit.draw(_disputeID);\\n            if (drawnAddress != address(0)) {\\n                jurors[drawnAddress].lockedPnk[dispute.courtID] += round.pnkAtStakePerJuror;\\n                emit Draw(drawnAddress, _disputeID, currentRound, round.drawnJurors.length);\\n                round.drawnJurors.push(drawnAddress);\\n\\n                if (round.drawnJurors.length == round.nbVotes) {\\n                    sortitionModule.postDrawHook(_disputeID, currentRound);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Appeals the ruling of a specified dispute.\\n    /// Note: Access restricted to the Dispute Kit for this `disputeID`.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _numberOfChoices Number of choices for the dispute. Can be required during court jump.\\n    /// @param _extraData Extradata for the dispute. Can be required during court jump.\\n    function appeal(uint256 _disputeID, uint256 _numberOfChoices, bytes memory _extraData) external payable {\\n        if (msg.value < appealCost(_disputeID)) revert AppealFeesNotEnough();\\n\\n        Dispute storage dispute = disputes[_disputeID];\\n        if (dispute.period != Period.appeal) revert DisputeNotAppealable();\\n\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        if (msg.sender != address(disputeKitNodes[round.disputeKitID].disputeKit)) revert DisputeKitOnly();\\n\\n        uint96 newCourtID = dispute.courtID;\\n        uint256 newDisputeKitID = round.disputeKitID;\\n\\n        // Warning: the extra round must be created before calling disputeKit.createDispute()\\n        Round storage extraRound = dispute.rounds.push();\\n\\n        if (round.nbVotes >= courts[newCourtID].jurorsForCourtJump) {\\n            // Jump to parent court.\\n            newCourtID = courts[newCourtID].parent;\\n\\n            for (uint256 i = 0; i < SEARCH_ITERATIONS; i++) {\\n                if (courts[newCourtID].supportedDisputeKits[newDisputeKitID]) {\\n                    break;\\n                } else if (disputeKitNodes[newDisputeKitID].parent != NULL_DISPUTE_KIT) {\\n                    newDisputeKitID = disputeKitNodes[newDisputeKitID].parent;\\n                } else {\\n                    // DK's parent has 0 index, that means we reached the root DK (0 depth level).\\n                    // Jump to the next parent court if the current court doesn't support any DK from this tree.\\n                    // Note that we don't reset newDisputeKitID in this case as, a precaution.\\n                    newCourtID = courts[newCourtID].parent;\\n                }\\n            }\\n            // We didn't find a court that is compatible with DK from this tree, so we jump directly to the top court.\\n            // Note that this can only happen when disputeKitID is at its root, and each root DK is supported by the top court by default.\\n            if (!courts[newCourtID].supportedDisputeKits[newDisputeKitID]) {\\n                newCourtID = GENERAL_COURT;\\n            }\\n\\n            if (newCourtID != dispute.courtID) {\\n                emit CourtJump(_disputeID, dispute.rounds.length - 1, dispute.courtID, newCourtID);\\n            }\\n        }\\n\\n        dispute.courtID = newCourtID;\\n        dispute.period = Period.evidence;\\n        dispute.lastPeriodChange = block.timestamp;\\n\\n        Court storage court = courts[newCourtID];\\n        extraRound.nbVotes = msg.value / court.feeForJuror; // As many votes that can be afforded by the provided funds.\\n        extraRound.pnkAtStakePerJuror = (court.minStake * court.alpha) / ALPHA_DIVISOR;\\n        extraRound.totalFeesForJurors = msg.value;\\n        extraRound.disputeKitID = newDisputeKitID;\\n\\n        sortitionModule.createDisputeHook(_disputeID, dispute.rounds.length - 1);\\n\\n        // Dispute kit was changed, so create a dispute in the new DK contract.\\n        if (extraRound.disputeKitID != round.disputeKitID) {\\n            IDisputeKit disputeKit = disputeKitNodes[extraRound.disputeKitID].disputeKit;\\n            emit DisputeKitJump(_disputeID, dispute.rounds.length - 1, round.disputeKitID, extraRound.disputeKitID);\\n            disputeKit.createDispute(_disputeID, _numberOfChoices, _extraData, extraRound.nbVotes);\\n        }\\n\\n        emit AppealDecision(_disputeID, dispute.arbitrated);\\n        emit NewPeriod(_disputeID, Period.evidence);\\n    }\\n\\n    /// @dev Distribute the PNKs at stake and the dispute fees for the specific round of the dispute. Can be called in parts.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @param _round The appeal round.\\n    /// @param _iterations The number of iterations to run.\\n    function execute(uint256 _disputeID, uint256 _round, uint256 _iterations) external {\\n        Dispute storage dispute = disputes[_disputeID];\\n        if (dispute.period != Period.execution) revert NotExecutionPeriod();\\n\\n        Round storage round = dispute.rounds[_round];\\n        IDisputeKit disputeKit = disputeKitNodes[round.disputeKitID].disputeKit;\\n\\n        uint256 start = round.repartitions;\\n        uint256 end = round.repartitions + _iterations;\\n\\n        uint256 pnkPenaltiesInRoundCache = round.pnkPenalties; // For saving gas.\\n        uint256 numberOfVotesInRound = round.drawnJurors.length;\\n        uint256 coherentCount = disputeKit.getCoherentCount(_disputeID, _round); // Total number of jurors that are eligible to a reward in this round.\\n\\n        if (coherentCount == 0) {\\n            // We loop over the votes once as there are no rewards because it is not a tie and no one in this round is coherent with the final outcome.\\n            if (end > numberOfVotesInRound) end = numberOfVotesInRound;\\n        } else {\\n            // We loop over the votes twice, first to collect the PNK penalties, and second to distribute them as rewards along with arbitration fees.\\n            if (end > numberOfVotesInRound * 2) end = numberOfVotesInRound * 2;\\n        }\\n        round.repartitions = end;\\n\\n        for (uint256 i = start; i < end; i++) {\\n            if (i < numberOfVotesInRound) {\\n                pnkPenaltiesInRoundCache = _executePenalties(\\n                    ExecuteParams(_disputeID, _round, coherentCount, numberOfVotesInRound, pnkPenaltiesInRoundCache, i)\\n                );\\n            } else {\\n                _executeRewards(\\n                    ExecuteParams(_disputeID, _round, coherentCount, numberOfVotesInRound, pnkPenaltiesInRoundCache, i)\\n                );\\n            }\\n        }\\n        if (round.pnkPenalties != pnkPenaltiesInRoundCache) {\\n            round.pnkPenalties = pnkPenaltiesInRoundCache; // Reentrancy risk: breaks Check-Effect-Interact\\n        }\\n    }\\n\\n    /// @dev Distribute the PNKs at stake and the dispute fees for the specific round of the dispute, penalties only.\\n    /// @param _params The parameters for the execution, see `ExecuteParams`.\\n    /// @return pnkPenaltiesInRoundCache The updated penalties in round cache.\\n    function _executePenalties(ExecuteParams memory _params) internal returns (uint256) {\\n        Dispute storage dispute = disputes[_params.disputeID];\\n        Round storage round = dispute.rounds[_params.round];\\n        IDisputeKit disputeKit = disputeKitNodes[round.disputeKitID].disputeKit;\\n\\n        // [0, 1] value that determines how coherent the juror was in this round, in basis points.\\n        uint256 degreeOfCoherence = disputeKit.getDegreeOfCoherence(\\n            _params.disputeID,\\n            _params.round,\\n            _params.repartition\\n        );\\n        if (degreeOfCoherence > ALPHA_DIVISOR) {\\n            // Make sure the degree doesn't exceed 1, though it should be ensured by the dispute kit.\\n            degreeOfCoherence = ALPHA_DIVISOR;\\n        }\\n\\n        // Fully coherent jurors won't be penalized.\\n        uint256 penalty = (round.pnkAtStakePerJuror * (ALPHA_DIVISOR - degreeOfCoherence)) / ALPHA_DIVISOR;\\n        _params.pnkPenaltiesInRound += penalty;\\n\\n        // Unlock the PNKs affected by the penalty\\n        address account = round.drawnJurors[_params.repartition];\\n        jurors[account].lockedPnk[dispute.courtID] -= penalty;\\n\\n        // Apply the penalty to the staked PNKs\\n        if (jurors[account].stakedPnk[dispute.courtID] >= courts[dispute.courtID].minStake + penalty) {\\n            // The juror still has enough staked PNKs after penalty for this court.\\n            uint256 newStake = jurors[account].stakedPnk[dispute.courtID] - penalty;\\n            _setStakeForAccount(account, dispute.courtID, newStake, penalty);\\n        } else if (jurors[account].stakedPnk[dispute.courtID] != 0) {\\n            // The juror does not have enough staked PNKs after penalty for this court, unstake them.\\n            _setStakeForAccount(account, dispute.courtID, 0, penalty);\\n        }\\n        emit TokenAndETHShift(\\n            account,\\n            _params.disputeID,\\n            _params.round,\\n            degreeOfCoherence,\\n            -int256(penalty),\\n            0,\\n            round.feeToken\\n        );\\n\\n        if (!disputeKit.isVoteActive(_params.disputeID, _params.round, _params.repartition)) {\\n            // The juror is inactive, unstake them.\\n            sortitionModule.setJurorInactive(account);\\n        }\\n        if (_params.repartition == _params.numberOfVotesInRound - 1 && _params.coherentCount == 0) {\\n            // No one was coherent, send the rewards to the governor.\\n            if (round.feeToken == NATIVE_CURRENCY) {\\n                // The dispute fees were paid in ETH\\n                payable(governor).send(round.totalFeesForJurors);\\n            } else {\\n                // The dispute fees were paid in ERC20\\n                round.feeToken.safeTransfer(governor, round.totalFeesForJurors);\\n            }\\n            pinakion.safeTransfer(governor, _params.pnkPenaltiesInRound);\\n            emit LeftoverRewardSent(\\n                _params.disputeID,\\n                _params.round,\\n                _params.pnkPenaltiesInRound,\\n                round.totalFeesForJurors,\\n                round.feeToken\\n            );\\n        }\\n        return _params.pnkPenaltiesInRound;\\n    }\\n\\n    /// @dev Distribute the PNKs at stake and the dispute fees for the specific round of the dispute, rewards only.\\n    /// @param _params The parameters for the execution, see `ExecuteParams`.\\n    function _executeRewards(ExecuteParams memory _params) internal {\\n        Dispute storage dispute = disputes[_params.disputeID];\\n        Round storage round = dispute.rounds[_params.round];\\n        IDisputeKit disputeKit = disputeKitNodes[round.disputeKitID].disputeKit;\\n\\n        // [0, 1] value that determines how coherent the juror was in this round, in basis points.\\n        uint256 degreeOfCoherence = disputeKit.getDegreeOfCoherence(\\n            _params.disputeID,\\n            _params.round,\\n            _params.repartition % _params.numberOfVotesInRound\\n        );\\n\\n        // Make sure the degree doesn't exceed 1, though it should be ensured by the dispute kit.\\n        if (degreeOfCoherence > ALPHA_DIVISOR) {\\n            degreeOfCoherence = ALPHA_DIVISOR;\\n        }\\n\\n        address account = round.drawnJurors[_params.repartition % _params.numberOfVotesInRound];\\n        // TODO Change me\\n        uint256 pnkLocked = (round.pnkAtStakePerJuror * degreeOfCoherence) / ALPHA_DIVISOR;\\n\\n        // Release the rest of the PNKs of the juror for this round.\\n        jurors[account].lockedPnk[dispute.courtID] -= pnkLocked;\\n\\n        // Give back the locked PNKs in case the juror fully unstaked earlier.\\n        if (jurors[account].stakedPnk[dispute.courtID] == 0) {\\n            pinakion.safeTransfer(account, pnkLocked);\\n        }\\n\\n        // Transfer the rewards\\n        uint256 pnkReward = ((_params.pnkPenaltiesInRound / _params.coherentCount) * degreeOfCoherence) / ALPHA_DIVISOR;\\n        round.sumPnkRewardPaid += pnkReward;\\n        uint256 feeReward = ((round.totalFeesForJurors / _params.coherentCount) * degreeOfCoherence) / ALPHA_DIVISOR;\\n        round.sumFeeRewardPaid += feeReward;\\n        pinakion.safeTransfer(account, pnkReward);\\n        if (round.feeToken == NATIVE_CURRENCY) {\\n            // The dispute fees were paid in ETH\\n            payable(account).send(feeReward);\\n        } else {\\n            // The dispute fees were paid in ERC20\\n            round.feeToken.safeTransfer(account, feeReward);\\n        }\\n        emit TokenAndETHShift(\\n            account,\\n            _params.disputeID,\\n            _params.round,\\n            degreeOfCoherence,\\n            int256(pnkReward),\\n            int256(feeReward),\\n            round.feeToken\\n        );\\n\\n        // Transfer any residual rewards to the governor. It may happen due to partial coherence of the jurors.\\n        if (_params.repartition == _params.numberOfVotesInRound * 2 - 1) {\\n            uint256 leftoverPnkReward = _params.pnkPenaltiesInRound - round.sumPnkRewardPaid;\\n            uint256 leftoverFeeReward = round.totalFeesForJurors - round.sumFeeRewardPaid;\\n            if (leftoverPnkReward != 0 || leftoverFeeReward != 0) {\\n                if (leftoverPnkReward != 0) {\\n                    pinakion.safeTransfer(governor, leftoverPnkReward);\\n                }\\n                if (leftoverFeeReward != 0) {\\n                    if (round.feeToken == NATIVE_CURRENCY) {\\n                        // The dispute fees were paid in ETH\\n                        payable(governor).send(leftoverFeeReward);\\n                    } else {\\n                        // The dispute fees were paid in ERC20\\n                        round.feeToken.safeTransfer(governor, leftoverFeeReward);\\n                    }\\n                }\\n                emit LeftoverRewardSent(\\n                    _params.disputeID,\\n                    _params.round,\\n                    leftoverPnkReward,\\n                    leftoverFeeReward,\\n                    round.feeToken\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @dev Executes a specified dispute's ruling.\\n    /// @param _disputeID The ID of the dispute.\\n    function executeRuling(uint256 _disputeID) external {\\n        Dispute storage dispute = disputes[_disputeID];\\n        if (dispute.period != Period.execution) revert NotExecutionPeriod();\\n        if (dispute.ruled) revert RulingAlreadyExecuted();\\n\\n        (uint256 winningChoice, , ) = currentRuling(_disputeID);\\n        dispute.ruled = true;\\n        emit Ruling(dispute.arbitrated, _disputeID, winningChoice);\\n        dispute.arbitrated.rule(_disputeID, winningChoice);\\n    }\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @dev Compute the cost of arbitration denominated in ETH.\\n    ///      It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @return cost The arbitration cost in ETH.\\n    function arbitrationCost(bytes memory _extraData) public view override returns (uint256 cost) {\\n        (uint96 courtID, uint256 minJurors, ) = _extraDataToCourtIDMinJurorsDisputeKit(_extraData);\\n        cost = courts[courtID].feeForJuror * minJurors;\\n    }\\n\\n    /// @dev Compute the cost of arbitration denominated in `_feeToken`.\\n    ///      It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @param _feeToken The ERC20 token used to pay fees.\\n    /// @return cost The arbitration cost in `_feeToken`.\\n    function arbitrationCost(bytes calldata _extraData, IERC20 _feeToken) public view override returns (uint256 cost) {\\n        cost = convertEthToTokenAmount(_feeToken, arbitrationCost(_extraData));\\n    }\\n\\n    /// @dev Gets the cost of appealing a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return cost The appeal cost.\\n    function appealCost(uint256 _disputeID) public view returns (uint256 cost) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        Court storage court = courts[dispute.courtID];\\n        if (round.nbVotes >= court.jurorsForCourtJump) {\\n            // Jump to parent court.\\n            if (dispute.courtID == GENERAL_COURT) {\\n                // TODO: Handle the forking when appealed in General court.\\n                cost = NON_PAYABLE_AMOUNT; // Get the cost of the parent court.\\n            } else {\\n                cost = courts[court.parent].feeForJuror * ((round.nbVotes * 2) + 1);\\n            }\\n        } else {\\n            // Stay in current court.\\n            cost = court.feeForJuror * ((round.nbVotes * 2) + 1);\\n        }\\n    }\\n\\n    /// @dev Gets the start and the end of a specified dispute's current appeal period.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return start The start of the appeal period.\\n    /// @return end The end of the appeal period.\\n    function appealPeriod(uint256 _disputeID) public view returns (uint256 start, uint256 end) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        if (dispute.period == Period.appeal) {\\n            start = dispute.lastPeriodChange;\\n            end = dispute.lastPeriodChange + courts[dispute.courtID].timesPerPeriod[uint256(Period.appeal)];\\n        } else {\\n            start = 0;\\n            end = 0;\\n        }\\n    }\\n\\n    /// @dev Gets the current ruling of a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return ruling The current ruling.\\n    /// @return tied Whether it's a tie or not.\\n    /// @return overridden Whether the ruling was overridden by appeal funding or not.\\n    function currentRuling(uint256 _disputeID) public view returns (uint256 ruling, bool tied, bool overridden) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        IDisputeKit disputeKit = disputeKitNodes[round.disputeKitID].disputeKit;\\n        (ruling, tied, overridden) = disputeKit.currentRuling(_disputeID);\\n    }\\n\\n    function getRoundInfo(\\n        uint256 _disputeID,\\n        uint256 _round\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 disputeKitID,\\n            uint256 pnkAtStakePerJuror,\\n            uint256 totalFeesForJurors,\\n            uint256 nbVotes,\\n            uint256 repartitions,\\n            uint256 pnkPenalties,\\n            address[] memory drawnJurors,\\n            uint256 sumFeeRewardPaid,\\n            uint256 sumPnkRewardPaid,\\n            IERC20 feeToken\\n        )\\n    {\\n        Round storage round = disputes[_disputeID].rounds[_round];\\n        return (\\n            round.disputeKitID,\\n            round.pnkAtStakePerJuror,\\n            round.totalFeesForJurors,\\n            round.nbVotes,\\n            round.repartitions,\\n            round.pnkPenalties,\\n            round.drawnJurors,\\n            round.sumFeeRewardPaid,\\n            round.sumPnkRewardPaid,\\n            round.feeToken\\n        );\\n    }\\n\\n    function getNumberOfRounds(uint256 _disputeID) external view returns (uint256) {\\n        return disputes[_disputeID].rounds.length;\\n    }\\n\\n    function getJurorBalance(\\n        address _juror,\\n        uint96 _courtID\\n    ) external view returns (uint256 staked, uint256 locked, uint256 nbCourts) {\\n        Juror storage juror = jurors[_juror];\\n        staked = juror.stakedPnk[_courtID];\\n        locked = juror.lockedPnk[_courtID];\\n        nbCourts = juror.courtIDs.length;\\n    }\\n\\n    function isSupported(uint96 _courtID, uint256 _disputeKitID) external view returns (bool) {\\n        return courts[_courtID].supportedDisputeKits[_disputeKitID];\\n    }\\n\\n    /// @dev Gets non-primitive properties of a specified dispute kit node.\\n    /// @param _disputeKitID The ID of the dispute kit.\\n    /// @return children Indexes of children of this DK.\\n    function getDisputeKitChildren(uint256 _disputeKitID) external view returns (uint256[] memory) {\\n        return disputeKitNodes[_disputeKitID].children;\\n    }\\n\\n    /// @dev Gets the timesPerPeriod array for a given court.\\n    /// @param _courtID The ID of the court to get the times from.\\n    /// @return timesPerPeriod The timesPerPeriod array for the given court.\\n    function getTimesPerPeriod(uint96 _courtID) external view returns (uint256[4] memory timesPerPeriod) {\\n        Court storage court = courts[_courtID];\\n        timesPerPeriod = court.timesPerPeriod;\\n    }\\n\\n    // ************************************* //\\n    // *   Public Views for Dispute Kits   * //\\n    // ************************************* //\\n\\n    /// @dev Gets the number of votes permitted for the specified dispute in the latest round.\\n    /// @param _disputeID The ID of the dispute.\\n    function getNumberOfVotes(uint256 _disputeID) external view returns (uint256) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        return dispute.rounds[dispute.rounds.length - 1].nbVotes;\\n    }\\n\\n    /// @dev Returns true if the dispute kit will be switched to a parent DK.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return Whether DK will be switched or not.\\n    function isDisputeKitJumping(uint256 _disputeID) external view returns (bool) {\\n        Dispute storage dispute = disputes[_disputeID];\\n        Round storage round = dispute.rounds[dispute.rounds.length - 1];\\n        Court storage court = courts[dispute.courtID];\\n\\n        if (round.nbVotes < court.jurorsForCourtJump) {\\n            return false;\\n        }\\n\\n        // Jump if the parent court doesn't support the current DK.\\n        return !courts[court.parent].supportedDisputeKits[round.disputeKitID];\\n    }\\n\\n    function getDisputeKitNodesLength() external view returns (uint256) {\\n        return disputeKitNodes.length;\\n    }\\n\\n    /// @dev Gets the dispute kit for a specific `_disputeKitID`.\\n    /// @param _disputeKitID The ID of the dispute kit.\\n    function getDisputeKit(uint256 _disputeKitID) external view returns (IDisputeKit) {\\n        return disputeKitNodes[_disputeKitID].disputeKit;\\n    }\\n\\n    /// @dev Gets the court identifiers where a specific `_juror` has staked.\\n    /// @param _juror The address of the juror.\\n    function getJurorCourtIDs(address _juror) public view returns (uint96[] memory) {\\n        return jurors[_juror].courtIDs;\\n    }\\n\\n    function convertEthToTokenAmount(IERC20 _toToken, uint256 _amountInEth) public view returns (uint256) {\\n        CurrencyRate storage rate = currencyRates[_toToken];\\n        return (_amountInEth * 10 ** rate.rateDecimals) / rate.rateInEth;\\n    }\\n\\n    // ************************************* //\\n    // *            Internal               * //\\n    // ************************************* //\\n\\n    /// @dev Toggles the dispute kit support for a given court.\\n    /// @param _courtID The ID of the court to toggle the support for.\\n    /// @param _disputeKitID The ID of the dispute kit to toggle the support for.\\n    /// @param _enable Whether to enable or disable the support.\\n    function _enableDisputeKit(uint96 _courtID, uint256 _disputeKitID, bool _enable) internal {\\n        courts[_courtID].supportedDisputeKits[_disputeKitID] = _enable;\\n        emit DisputeKitEnabled(_courtID, _disputeKitID, _enable);\\n    }\\n\\n    /// @dev Sets the specified juror's stake in a court.\\n    /// `O(n + p * log_k(j))` where\\n    /// `n` is the number of courts the juror has staked in,\\n    /// `p` is the depth of the court tree,\\n    /// `k` is the minimum number of children per node of one of these courts' sortition sum tree,\\n    /// and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\\n    /// @param _account The address of the juror.\\n    /// @param _courtID The ID of the court.\\n    /// @param _stake The new stake.\\n    /// @param _penalty Penalized amount won't be transferred back to juror when the stake is lowered.\\n    /// @return succeeded True if the call succeeded, false otherwise.\\n    function _setStakeForAccount(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _stake,\\n        uint256 _penalty\\n    ) internal returns (bool succeeded) {\\n        if (_courtID == FORKING_COURT || _courtID > courts.length) return false;\\n\\n        Juror storage juror = jurors[_account];\\n        uint256 currentStake = juror.stakedPnk[_courtID];\\n\\n        if (_stake != 0) {\\n            // Check against locked PNKs in case the min stake was lowered.\\n            if (_stake < courts[_courtID].minStake || _stake < juror.lockedPnk[_courtID]) return false;\\n        }\\n\\n        ISortitionModule.preStakeHookResult result = sortitionModule.preStakeHook(_account, _courtID, _stake, _penalty);\\n        if (result == ISortitionModule.preStakeHookResult.failed) {\\n            return false;\\n        } else if (result == ISortitionModule.preStakeHookResult.delayed) {\\n            emit StakeDelayed(_account, _courtID, _stake, _penalty);\\n            return true;\\n        }\\n\\n        uint256 transferredAmount;\\n        if (_stake >= currentStake) {\\n            transferredAmount = _stake - currentStake;\\n            if (transferredAmount > 0) {\\n                if (pinakion.safeTransferFrom(_account, address(this), transferredAmount)) {\\n                    if (currentStake == 0) {\\n                        juror.courtIDs.push(_courtID);\\n                    }\\n                } else {\\n                    return false;\\n                }\\n            }\\n        } else {\\n            if (_stake == 0) {\\n                // Keep locked PNKs in the contract and release them after dispute is executed.\\n                transferredAmount = currentStake - juror.lockedPnk[_courtID] - _penalty;\\n                if (transferredAmount > 0) {\\n                    if (pinakion.safeTransfer(_account, transferredAmount)) {\\n                        for (uint256 i = juror.courtIDs.length; i > 0; i--) {\\n                            if (juror.courtIDs[i - 1] == _courtID) {\\n                                juror.courtIDs[i - 1] = juror.courtIDs[juror.courtIDs.length - 1];\\n                                juror.courtIDs.pop();\\n                                break;\\n                            }\\n                        }\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n            } else {\\n                transferredAmount = currentStake - _stake - _penalty;\\n                if (transferredAmount > 0) {\\n                    if (!pinakion.safeTransfer(_account, transferredAmount)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Update juror's records.\\n        juror.stakedPnk[_courtID] = _stake;\\n\\n        sortitionModule.setStake(_account, _courtID, _stake);\\n        emit StakeSet(_account, _courtID, _stake);\\n        return true;\\n    }\\n\\n    /// @dev Gets a court ID, the minimum number of jurors and an ID of a dispute kit from a specified extra data bytes array.\\n    /// Note that if extradata contains an incorrect value then this value will be switched to default.\\n    /// @param _extraData The extra data bytes array. The first 32 bytes are the court ID, the next are the minimum number of jurors and the last are the dispute kit ID.\\n    /// @return courtID The court ID.\\n    /// @return minJurors The minimum number of jurors required.\\n    /// @return disputeKitID The ID of the dispute kit.\\n    function _extraDataToCourtIDMinJurorsDisputeKit(\\n        bytes memory _extraData\\n    ) internal view returns (uint96 courtID, uint256 minJurors, uint256 disputeKitID) {\\n        // Note that if the extradata doesn't contain 32 bytes for the dispute kit ID it'll return the default 0 index.\\n        if (_extraData.length >= 64) {\\n            assembly {\\n                // solium-disable-line security/no-inline-assembly\\n                courtID := mload(add(_extraData, 0x20))\\n                minJurors := mload(add(_extraData, 0x40))\\n                disputeKitID := mload(add(_extraData, 0x60))\\n            }\\n            if (courtID == FORKING_COURT || courtID >= courts.length) {\\n                courtID = GENERAL_COURT;\\n            }\\n            if (minJurors == 0) {\\n                minJurors = DEFAULT_NB_OF_JURORS;\\n            }\\n            if (disputeKitID == NULL_DISPUTE_KIT || disputeKitID >= disputeKitNodes.length) {\\n                disputeKitID = DISPUTE_KIT_CLASSIC; // 0 index is not used.\\n            }\\n        } else {\\n            courtID = GENERAL_COURT;\\n            minJurors = DEFAULT_NB_OF_JURORS;\\n            disputeKitID = DISPUTE_KIT_CLASSIC;\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *              Errors               * //\\n    // ************************************* //\\n\\n    error GovernorOnly();\\n    error UnsuccessfulCall();\\n    error InvalidDisputKitParent();\\n    error DepthLevelMax();\\n    error MinStakeLowerThanParentCourt();\\n    error UnsupportedDisputeKit();\\n    error InvalidForkingCourtAsParent();\\n    error WrongDisputeKitIndex();\\n    error CannotDisableRootDKInGeneral();\\n    error ArraysLengthMismatch();\\n    error StakingFailed();\\n    error WrongCaller();\\n    error ArbitrationFeesNotEnough();\\n    error DisputeKitNotSupportedByCourt();\\n    error TokenNotAccepted();\\n    error EvidenceNotPassedAndNotAppeal();\\n    error DisputeStillDrawing();\\n    error CommitPeriodNotPassed();\\n    error VotePeriodNotPassed();\\n    error AppealPeriodNotPassed();\\n    error NotEvidencePeriod();\\n    error AppealFeesNotEnough();\\n    error DisputeNotAppealable();\\n    error DisputeKitOnly();\\n    error NotExecutionPeriod();\\n    error RulingAlreadyExecuted();\\n    error DisputePeriodIsFinal();\\n}\\n\",\"keccak256\":\"0xe57e56a2886c61842b0ab35e8e8b54eac1d1213fa002c8f263305b80d3f702bf\",\"license\":\"MIT\"},\"src/arbitration/SortitionModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @custom:authors: [@epiqueras, @unknownunknown1, @shotaronowhere]\\n *  @custom:reviewers: []\\n *  @custom:auditors: []\\n *  @custom:bounties: []\\n *  @custom:deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./KlerosCore.sol\\\";\\nimport \\\"./interfaces/ISortitionModule.sol\\\";\\nimport \\\"./interfaces/IDisputeKit.sol\\\";\\nimport \\\"../rng/RNG.sol\\\";\\n\\n/// @title SortitionModule\\n/// @dev A factory of trees that keeps track of staked values for sortition.\\ncontract SortitionModule is ISortitionModule {\\n    // ************************************* //\\n    // *         Enums / Structs           * //\\n    // ************************************* //\\n\\n    struct SortitionSumTree {\\n        uint256 K; // The maximum number of children per node.\\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\\n        uint256[] stack;\\n        uint256[] nodes;\\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\\n        mapping(bytes32 => uint256) IDsToNodeIndexes;\\n        mapping(uint256 => bytes32) nodeIndexesToIDs;\\n    }\\n\\n    struct DelayedStake {\\n        address account; // The address of the juror.\\n        uint96 courtID; // The ID of the court.\\n        uint256 stake; // The new stake.\\n        uint256 penalty; // Penalty value, in case the stake was set during execution.\\n    }\\n\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    uint256 public constant MAX_STAKE_PATHS = 4; // The maximum number of stake paths a juror can have.\\n    uint256 public constant DEFAULT_K = 6; // Default number of children per node.\\n\\n    address public governor; // The governor of the contract.\\n    KlerosCore public core; // The core arbitrator contract.\\n    Phase public phase; // The current phase.\\n    uint256 public minStakingTime; // The time after which the phase can be switched to Drawing if there are open disputes.\\n    uint256 public maxDrawingTime; // The time after which the phase can be switched back to Staking.\\n    uint256 public lastPhaseChange; // The last time the phase was changed.\\n    uint256 public randomNumberRequestBlock; // Number of the block when RNG request was made.\\n    uint256 public disputesWithoutJurors; // The number of disputes that have not finished drawing jurors.\\n    RNG public rng; // The random number generator.\\n    uint256 public randomNumber; // Random number returned by RNG.\\n    uint256 public rngLookahead; // Minimal block distance between requesting and obtaining a random number.\\n    uint256 public delayedStakeWriteIndex; // The index of the last `delayedStake` item that was written to the array. 0 index is skipped.\\n    uint256 public delayedStakeReadIndex = 1; // The index of the next `delayedStake` item that should be processed. Starts at 1 because 0 index is skipped.\\n    mapping(bytes32 => SortitionSumTree) sortitionSumTrees; // The mapping trees by keys.\\n    mapping(uint256 => DelayedStake) public delayedStakes; // Stores the stakes that were changed during Drawing phase, to update them when the phase is switched to Staking.\\n\\n    // ************************************* //\\n    // *        Function Modifiers         * //\\n    // ************************************* //\\n\\n    modifier onlyByGovernor() {\\n        require(address(governor) == msg.sender, \\\"Access not allowed: Governor only.\\\");\\n        _;\\n    }\\n\\n    modifier onlyByCore() {\\n        require(address(core) == msg.sender, \\\"Access not allowed: KlerosCore only.\\\");\\n        _;\\n    }\\n\\n    // ************************************* //\\n    // *            Constructor            * //\\n    // ************************************* //\\n\\n    /// @dev Constructor.\\n    /// @param _core The KlerosCore.\\n    /// @param _minStakingTime Minimal time to stake\\n    /// @param _maxDrawingTime Time after which the drawing phase can be switched\\n    /// @param _rng The random number generator.\\n    /// @param _rngLookahead Lookahead value for rng.\\n    constructor(\\n        address _governor,\\n        KlerosCore _core,\\n        uint256 _minStakingTime,\\n        uint256 _maxDrawingTime,\\n        RNG _rng,\\n        uint256 _rngLookahead\\n    ) {\\n        governor = _governor;\\n        core = _core;\\n        minStakingTime = _minStakingTime;\\n        maxDrawingTime = _maxDrawingTime;\\n        lastPhaseChange = block.timestamp;\\n        rng = _rng;\\n        rngLookahead = _rngLookahead;\\n    }\\n\\n    // ************************************* //\\n    // *             Governance            * //\\n    // ************************************* //\\n\\n    /// @dev Changes the `minStakingTime` storage variable.\\n    /// @param _minStakingTime The new value for the `minStakingTime` storage variable.\\n    function changeMinStakingTime(uint256 _minStakingTime) external onlyByGovernor {\\n        minStakingTime = _minStakingTime;\\n    }\\n\\n    /// @dev Changes the `maxDrawingTime` storage variable.\\n    /// @param _maxDrawingTime The new value for the `maxDrawingTime` storage variable.\\n    function changeMaxDrawingTime(uint256 _maxDrawingTime) external onlyByGovernor {\\n        maxDrawingTime = _maxDrawingTime;\\n    }\\n\\n    /// @dev Changes the `_rng` and `_rngLookahead` storage variables.\\n    /// @param _rng The new value for the `RNGenerator` storage variable.\\n    /// @param _rngLookahead The new value for the `rngLookahead` storage variable.\\n    function changeRandomNumberGenerator(RNG _rng, uint256 _rngLookahead) external onlyByGovernor {\\n        rng = _rng;\\n        rngLookahead = _rngLookahead;\\n        if (phase == Phase.generating) {\\n            rng.requestRandomness(block.number + rngLookahead);\\n            randomNumberRequestBlock = block.number;\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    function passPhase() external {\\n        if (phase == Phase.staking) {\\n            require(\\n                block.timestamp - lastPhaseChange >= minStakingTime,\\n                \\\"The minimum staking time has not passed yet.\\\"\\n            );\\n            require(disputesWithoutJurors > 0, \\\"There are no disputes that need jurors.\\\");\\n            rng.requestRandomness(block.number + rngLookahead);\\n            randomNumberRequestBlock = block.number;\\n            phase = Phase.generating;\\n        } else if (phase == Phase.generating) {\\n            randomNumber = rng.receiveRandomness(randomNumberRequestBlock + rngLookahead);\\n            require(randomNumber != 0, \\\"Random number is not ready yet\\\");\\n            phase = Phase.drawing;\\n        } else if (phase == Phase.drawing) {\\n            require(\\n                disputesWithoutJurors == 0 || block.timestamp - lastPhaseChange >= maxDrawingTime,\\n                \\\"There are still disputes without jurors and the maximum drawing time has not passed yet.\\\"\\n            );\\n            phase = Phase.staking;\\n        }\\n\\n        lastPhaseChange = block.timestamp;\\n        emit NewPhase(phase);\\n    }\\n\\n    /// @dev Create a sortition sum tree at the specified key.\\n    /// @param _key The key of the new tree.\\n    /// @param _extraData Extra data that contains the number of children each node in the tree should have.\\n    function createTree(bytes32 _key, bytes memory _extraData) external override onlyByCore {\\n        SortitionSumTree storage tree = sortitionSumTrees[_key];\\n        uint256 K = _extraDataToTreeK(_extraData);\\n        require(tree.K == 0, \\\"Tree already exists.\\\");\\n        require(K > 1, \\\"K must be greater than one.\\\");\\n        tree.K = K;\\n        tree.nodes.push(0);\\n    }\\n\\n    /// @dev Executes the next delayed stakes.\\n    /// @param _iterations The number of delayed stakes to execute.\\n    function executeDelayedStakes(uint256 _iterations) external {\\n        require(phase == Phase.staking, \\\"Should be in Staking phase.\\\");\\n\\n        uint256 actualIterations = (delayedStakeReadIndex + _iterations) - 1 > delayedStakeWriteIndex\\n            ? (delayedStakeWriteIndex - delayedStakeReadIndex) + 1\\n            : _iterations;\\n        uint256 newDelayedStakeReadIndex = delayedStakeReadIndex + actualIterations;\\n\\n        for (uint256 i = delayedStakeReadIndex; i < newDelayedStakeReadIndex; i++) {\\n            DelayedStake storage delayedStake = delayedStakes[i];\\n            core.setStakeBySortitionModule(\\n                delayedStake.account,\\n                delayedStake.courtID,\\n                delayedStake.stake,\\n                delayedStake.penalty\\n            );\\n            delete delayedStakes[i];\\n        }\\n        delayedStakeReadIndex = newDelayedStakeReadIndex;\\n    }\\n\\n    function preStakeHook(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _stake,\\n        uint256 _penalty\\n    ) external override onlyByCore returns (preStakeHookResult) {\\n        (uint256 currentStake, , uint256 nbCourts) = core.getJurorBalance(_account, _courtID);\\n        if (currentStake == 0 && nbCourts >= MAX_STAKE_PATHS) {\\n            // Prevent staking beyond MAX_STAKE_PATHS but unstaking is always allowed.\\n            return preStakeHookResult.failed;\\n        } else {\\n            if (phase != Phase.staking) {\\n                delayedStakes[++delayedStakeWriteIndex] = DelayedStake({\\n                    account: _account,\\n                    courtID: _courtID,\\n                    stake: _stake,\\n                    penalty: _penalty\\n                });\\n                return preStakeHookResult.delayed;\\n            }\\n        }\\n        return preStakeHookResult.ok;\\n    }\\n\\n    function createDisputeHook(uint256 /*_disputeID*/, uint256 /*_roundID*/) external override onlyByCore {\\n        disputesWithoutJurors++;\\n    }\\n\\n    function postDrawHook(uint256 /*_disputeID*/, uint256 /*_roundID*/) external override onlyByCore {\\n        disputesWithoutJurors--;\\n    }\\n\\n    /// @dev Saves the random number to use it in sortition. Not used by this contract because the storing of the number is inlined in passPhase().\\n    /// @param _randomNumber Random number returned by RNG contract.\\n    function notifyRandomNumber(uint256 _randomNumber) public override {}\\n\\n    /// @dev Sets the value for a particular court and its parent courts.\\n    /// @param _courtID ID of the court.\\n    /// @param _value The new value.\\n    /// @param _account Address of the juror.\\n    /// `O(log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    function setStake(address _account, uint96 _courtID, uint256 _value) external override onlyByCore {\\n        bytes32 stakePathID = _accountAndCourtIDToStakePathID(_account, _courtID);\\n        bool finished = false;\\n        uint96 currenCourtID = _courtID;\\n        while (!finished) {\\n            // Tokens are also implicitly staked in parent courts through sortition module to increase the chance of being drawn.\\n            _set(bytes32(uint256(currenCourtID)), _value, stakePathID);\\n            if (currenCourtID == core.GENERAL_COURT()) {\\n                finished = true;\\n            } else {\\n                (currenCourtID, , , , , , ) = core.courts(currenCourtID);\\n            }\\n        }\\n    }\\n\\n    /// @dev Unstakes the inactive juror from all courts.\\n    /// `O(n * (p * log_k(j)) )` where\\n    /// `n` is the number of courts the juror has staked in,\\n    /// `p` is the depth of the court tree,\\n    /// `k` is the minimum number of children per node of one of these courts' sortition sum tree,\\n    /// and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.\\n    /// @param _account The juror to unstake.\\n    function setJurorInactive(address _account) external override onlyByCore {\\n        uint96[] memory courtIDs = core.getJurorCourtIDs(_account);\\n        for (uint256 j = courtIDs.length; j > 0; j--) {\\n            core.setStakeBySortitionModule(_account, courtIDs[j - 1], 0, 0);\\n        }\\n    }\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @dev Draw an ID from a tree using a number.\\n    /// Note that this function reverts if the sum of all values in the tree is 0.\\n    /// @param _key The key of the tree.\\n    /// @param _coreDisputeID Index of the dispute in Kleros Core.\\n    /// @param _voteID ID of the voter.\\n    /// @return drawnAddress The drawn address.\\n    /// `O(k * log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    function draw(\\n        bytes32 _key,\\n        uint256 _coreDisputeID,\\n        uint256 _voteID\\n    ) public view override returns (address drawnAddress) {\\n        require(phase == Phase.drawing, \\\"Wrong phase.\\\");\\n        SortitionSumTree storage tree = sortitionSumTrees[_key];\\n\\n        uint256 treeIndex = 0;\\n        uint256 currentDrawnNumber = uint256(keccak256(abi.encodePacked(randomNumber, _coreDisputeID, _voteID))) %\\n            tree.nodes[0];\\n\\n        // While it still has children\\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length) {\\n            for (uint256 i = 1; i <= tree.K; i++) {\\n                // Loop over children.\\n                uint256 nodeIndex = (tree.K * treeIndex) + i;\\n                uint256 nodeValue = tree.nodes[nodeIndex];\\n\\n                if (currentDrawnNumber >= nodeValue) {\\n                    // Go to the next child.\\n                    currentDrawnNumber -= nodeValue;\\n                } else {\\n                    // Pick this child.\\n                    treeIndex = nodeIndex;\\n                    break;\\n                }\\n            }\\n        }\\n        drawnAddress = _stakePathIDToAccount(tree.nodeIndexesToIDs[treeIndex]);\\n    }\\n\\n    // ************************************* //\\n    // *            Internal               * //\\n    // ************************************* //\\n\\n    /// @dev Update all the parents of a node.\\n    /// @param _key The key of the tree to update.\\n    /// @param _treeIndex The index of the node to start from.\\n    /// @param _plusOrMinus Whether to add (true) or substract (false).\\n    /// @param _value The value to add or substract.\\n    /// `O(log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    function _updateParents(bytes32 _key, uint256 _treeIndex, bool _plusOrMinus, uint256 _value) private {\\n        SortitionSumTree storage tree = sortitionSumTrees[_key];\\n\\n        uint256 parentIndex = _treeIndex;\\n        while (parentIndex != 0) {\\n            parentIndex = (parentIndex - 1) / tree.K;\\n            tree.nodes[parentIndex] = _plusOrMinus\\n                ? tree.nodes[parentIndex] + _value\\n                : tree.nodes[parentIndex] - _value;\\n        }\\n    }\\n\\n    /// @dev Retrieves a juror's address from the stake path ID.\\n    /// @param _stakePathID The stake path ID to unpack.\\n    /// @return account The account.\\n    function _stakePathIDToAccount(bytes32 _stakePathID) internal pure returns (address account) {\\n        assembly {\\n            // solium-disable-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            for {\\n                let i := 0x00\\n            } lt(i, 0x14) {\\n                i := add(i, 0x01)\\n            } {\\n                mstore8(add(add(ptr, 0x0c), i), byte(i, _stakePathID))\\n            }\\n            account := mload(ptr)\\n        }\\n    }\\n\\n    function _extraDataToTreeK(bytes memory _extraData) internal pure returns (uint256 K) {\\n        if (_extraData.length >= 32) {\\n            assembly {\\n                // solium-disable-line security/no-inline-assembly\\n                K := mload(add(_extraData, 0x20))\\n            }\\n        } else {\\n            K = DEFAULT_K;\\n        }\\n    }\\n\\n    /// @dev Set a value in a tree.\\n    /// @param _key The key of the tree.\\n    /// @param _value The new value.\\n    /// @param _ID The ID of the value.\\n    /// `O(log_k(n))` where\\n    /// `k` is the maximum number of children per node in the tree,\\n    ///  and `n` is the maximum number of nodes ever appended.\\n    function _set(bytes32 _key, uint256 _value, bytes32 _ID) internal {\\n        SortitionSumTree storage tree = sortitionSumTrees[_key];\\n        uint256 treeIndex = tree.IDsToNodeIndexes[_ID];\\n\\n        if (treeIndex == 0) {\\n            // No existing node.\\n            if (_value != 0) {\\n                // Non zero value.\\n                // Append.\\n                // Add node.\\n                if (tree.stack.length == 0) {\\n                    // No vacant spots.\\n                    // Get the index and append the value.\\n                    treeIndex = tree.nodes.length;\\n                    tree.nodes.push(_value);\\n\\n                    // Potentially append a new node and make the parent a sum node.\\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) {\\n                        // Is first child.\\n                        uint256 parentIndex = treeIndex / tree.K;\\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\\n                        uint256 newIndex = treeIndex + 1;\\n                        tree.nodes.push(tree.nodes[parentIndex]);\\n                        delete tree.nodeIndexesToIDs[parentIndex];\\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\\n                    }\\n                } else {\\n                    // Some vacant spot.\\n                    // Pop the stack and append the value.\\n                    treeIndex = tree.stack[tree.stack.length - 1];\\n                    tree.stack.pop();\\n                    tree.nodes[treeIndex] = _value;\\n                }\\n\\n                // Add label.\\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\\n\\n                _updateParents(_key, treeIndex, true, _value);\\n            }\\n        } else {\\n            // Existing node.\\n            if (_value == 0) {\\n                // Zero value.\\n                // Remove.\\n                // Remember value and set to 0.\\n                uint256 value = tree.nodes[treeIndex];\\n                tree.nodes[treeIndex] = 0;\\n\\n                // Push to stack.\\n                tree.stack.push(treeIndex);\\n\\n                // Clear label.\\n                delete tree.IDsToNodeIndexes[_ID];\\n                delete tree.nodeIndexesToIDs[treeIndex];\\n\\n                _updateParents(_key, treeIndex, false, value);\\n            } else if (_value != tree.nodes[treeIndex]) {\\n                // New, non zero value.\\n                // Set.\\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\\n                uint256 plusOrMinusValue = plusOrMinus\\n                    ? _value - tree.nodes[treeIndex]\\n                    : tree.nodes[treeIndex] - _value;\\n                tree.nodes[treeIndex] = _value;\\n\\n                _updateParents(_key, treeIndex, plusOrMinus, plusOrMinusValue);\\n            }\\n        }\\n    }\\n\\n    /// @dev Packs an account and a court ID into a stake path ID.\\n    /// @param _account The address of the juror to pack.\\n    /// @param _courtID The court ID to pack.\\n    /// @return stakePathID The stake path ID.\\n    function _accountAndCourtIDToStakePathID(\\n        address _account,\\n        uint96 _courtID\\n    ) internal pure returns (bytes32 stakePathID) {\\n        assembly {\\n            // solium-disable-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            for {\\n                let i := 0x00\\n            } lt(i, 0x14) {\\n                i := add(i, 0x01)\\n            } {\\n                mstore8(add(ptr, i), byte(add(0x0c, i), _account))\\n            }\\n            for {\\n                let i := 0x14\\n            } lt(i, 0x20) {\\n                i := add(i, 0x01)\\n            } {\\n                mstore8(add(ptr, i), byte(i, _courtID))\\n            }\\n            stakePathID := mload(ptr)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7cf6a006b7aaa07754dfc13b75a42912e403ec97a726e102e4963c9691f63425\",\"license\":\"MIT\"},\"src/arbitration/interfaces/IArbitrableV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./IArbitratorV2.sol\\\";\\n\\n/// @title IArbitrableV2\\n/// @notice Arbitrable interface.\\n/// When developing arbitrable contracts, we need to:\\n/// - Define the action taken when a ruling is received by the contract.\\n/// - Allow dispute creation. For this a function must call arbitrator.createDispute{value: _fee}(_choices,_extraData);\\ninterface IArbitrableV2 {\\n    /// @dev To be emitted when a new dispute template is created.\\n    /// @param _templateId The identifier of the dispute template.\\n    /// @param _templateTag An optional tag for the dispute template, such as \\\"registration\\\" or \\\"removal\\\".\\n    /// @param _templateData The template data.\\n    event DisputeTemplate(uint256 indexed _templateId, string indexed _templateTag, string _templateData);\\n\\n    /// @dev To be emitted when a dispute is created to link the correct meta-evidence to the disputeID.\\n    /// @param _arbitrator The arbitrator of the contract.\\n    /// @param _arbitrableDisputeID The identifier of the dispute in the Arbitrable contract.\\n    /// @param _externalDisputeID An identifier created outside Kleros by the protocol requesting arbitration.\\n    /// @param _templateId The identifier of the dispute template. Should not be used with _templateUri.\\n    /// @param _templateUri The URI to the dispute template. For example on IPFS: starting with '/ipfs/'. Should not be used with _templateId.\\n    event DisputeRequest(\\n        IArbitratorV2 indexed _arbitrator,\\n        uint256 indexed _arbitrableDisputeID,\\n        uint256 _externalDisputeID,\\n        uint256 _templateId,\\n        string _templateUri\\n    );\\n\\n    /// @dev To be raised when a ruling is given.\\n    /// @param _arbitrator The arbitrator giving the ruling.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling The ruling which was given.\\n    event Ruling(IArbitratorV2 indexed _arbitrator, uint256 indexed _disputeID, uint256 _ruling);\\n\\n    /// @dev Give a ruling for a dispute.\\n    ///      Must be called by the arbitrator.\\n    ///      The purpose of this function is to ensure that the address calling it has the right to rule on the contract.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling Ruling given by the arbitrator.\\n    /// Note that 0 is reserved for \\\"Not able/wanting to make a decision\\\".\\n    function rule(uint256 _disputeID, uint256 _ruling) external;\\n}\\n\",\"keccak256\":\"0x7a259401627ba5546d9eb0264275aa1be9762f8a514545ae99d8c356ebf41f4f\",\"license\":\"MIT\"},\"src/arbitration/interfaces/IArbitratorV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IArbitrableV2.sol\\\";\\n\\n/// @title Arbitrator\\n/// Arbitrator interface that implements the new arbitration standard.\\n/// Unlike the ERC-792 this standard is not concerned with appeals, so each arbitrator can implement an appeal system that suits it the most.\\n/// When developing arbitrator contracts we need to:\\n/// - Define the functions for dispute creation (createDispute). Don't forget to store the arbitrated contract and the disputeID (which should be unique, may nbDisputes).\\n/// - Define the functions for cost display (arbitrationCost).\\n/// - Allow giving rulings. For this a function must call arbitrable.rule(disputeID, ruling).\\ninterface IArbitratorV2 {\\n    /// @dev To be emitted when a dispute is created.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _arbitrable The contract which created the dispute.\\n    event DisputeCreation(uint256 indexed _disputeID, IArbitrableV2 indexed _arbitrable);\\n\\n    /// @dev To be raised when a ruling is given.\\n    /// @param _arbitrable The arbitrable receiving the ruling.\\n    /// @param _disputeID The identifier of the dispute in the Arbitrator contract.\\n    /// @param _ruling The ruling which was given.\\n    event Ruling(IArbitrableV2 indexed _arbitrable, uint256 indexed _disputeID, uint256 _ruling);\\n\\n    /// @dev To be emitted when an ERC20 token is added or removed as a method to pay fees.\\n    /// @param _token The ERC20 token.\\n    /// @param _accepted Whether the token is accepted or not.\\n    event AcceptedFeeToken(IERC20 indexed _token, bool indexed _accepted);\\n\\n    /// @dev Create a dispute and pay for the fees in the native currency, typically ETH.\\n    ///      Must be called by the arbitrable contract.\\n    ///      Must pay at least arbitrationCost(_extraData).\\n    /// @param _numberOfChoices The number of choices the arbitrator can choose from in this dispute.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @return disputeID The identifier of the dispute created.\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData\\n    ) external payable returns (uint256 disputeID);\\n\\n    /// @dev Create a dispute and pay for the fees in a supported ERC20 token.\\n    ///      Must be called by the arbitrable contract.\\n    ///      Must pay at least arbitrationCost(_extraData).\\n    /// @param _numberOfChoices The number of choices the arbitrator can choose from in this dispute.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @param _feeToken The ERC20 token used to pay fees.\\n    /// @param _feeAmount Amount of the ERC20 token used to pay fees.\\n    /// @return disputeID The identifier of the dispute created.\\n    function createDispute(\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData,\\n        IERC20 _feeToken,\\n        uint256 _feeAmount\\n    ) external returns (uint256 disputeID);\\n\\n    /// @dev Compute the cost of arbitration denominated in the native currency, typically ETH.\\n    ///      It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @return cost The arbitration cost in ETH.\\n    function arbitrationCost(bytes calldata _extraData) external view returns (uint256 cost);\\n\\n    /// @dev Compute the cost of arbitration denominated in `_feeToken`.\\n    ///      It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\\n    /// @param _extraData Additional info about the dispute. We use it to pass the ID of the dispute's court (first 32 bytes), the minimum number of jurors required (next 32 bytes) and the ID of the specific dispute kit (last 32 bytes).\\n    /// @param _feeToken The ERC20 token used to pay fees.\\n    /// @return cost The arbitration cost in `_feeToken`.\\n    function arbitrationCost(bytes calldata _extraData, IERC20 _feeToken) external view returns (uint256 cost);\\n\\n    /// @dev Gets the current ruling of a specified dispute.\\n    /// @param _disputeID The ID of the dispute.\\n    /// @return ruling The current ruling.\\n    /// @return tied Whether it's a tie or not.\\n    /// @return overridden Whether the ruling was overridden by appeal funding or not.\\n    function currentRuling(uint256 _disputeID) external view returns (uint256 ruling, bool tied, bool overridden);\\n}\\n\",\"keccak256\":\"0x9001274313a4e7eeda92332bbeeac8972f55e6378874babfaccd56eb283816f0\",\"license\":\"MIT\"},\"src/arbitration/interfaces/IDisputeKit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/// @custom:authors: [@unknownunknown1, @jaybuidl]\\n/// @custom:reviewers: []\\n/// @custom:auditors: []\\n/// @custom:bounties: []\\n/// @custom:deployments: []\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./IArbitratorV2.sol\\\";\\n\\n/// @title IDisputeKit\\n/// An abstraction of the Dispute Kits intended for interfacing with KlerosCore.\\n/// It does not intend to abstract the interactions with the user (such as voting or appeal funding) to allow for implementation-specific parameters.\\ninterface IDisputeKit {\\n    // ************************************ //\\n    // *             Events               * //\\n    // ************************************ //\\n\\n    /// @dev Emitted when casting a vote to provide the justification of juror's choice.\\n    /// @param _coreDisputeID ID of the dispute in the core contract.\\n    /// @param _juror Address of the juror.\\n    /// @param _choice The choice juror voted for.\\n    /// @param _justification Justification of the choice.\\n    event Justification(\\n        uint256 indexed _coreDisputeID,\\n        address indexed _juror,\\n        uint256 indexed _choice,\\n        string _justification\\n    );\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @dev Creates a local dispute and maps it to the dispute ID in the Core contract.\\n    /// Note: Access restricted to Kleros Core only.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _numberOfChoices Number of choices of the dispute\\n    /// @param _extraData Additional info about the dispute, for possible use in future dispute kits.\\n    function createDispute(\\n        uint256 _coreDisputeID,\\n        uint256 _numberOfChoices,\\n        bytes calldata _extraData,\\n        uint256 _nbVotes\\n    ) external;\\n\\n    /// @dev Draws the juror from the sortition tree. The drawn address is picked up by Kleros Core.\\n    /// Note: Access restricted to Kleros Core only.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return drawnAddress The drawn address.\\n    function draw(uint256 _coreDisputeID) external returns (address drawnAddress);\\n\\n    // ************************************* //\\n    // *           Public Views            * //\\n    // ************************************* //\\n\\n    /// @dev Gets the current ruling of a specified dispute.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return ruling The current ruling.\\n    /// @return tied Whether it's a tie or not.\\n    /// @return overridden Whether the ruling was overridden by appeal funding or not.\\n    function currentRuling(uint256 _coreDisputeID) external view returns (uint256 ruling, bool tied, bool overridden);\\n\\n    /// @dev Gets the degree of coherence of a particular voter. This function is called by Kleros Core in order to determine the amount of the reward.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @param _voteID The ID of the vote.\\n    /// @return The degree of coherence in basis points.\\n    function getDegreeOfCoherence(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _voteID\\n    ) external view returns (uint256);\\n\\n    /// @dev Gets the number of jurors who are eligible to a reward in this round.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @return The number of coherent jurors.\\n    function getCoherentCount(uint256 _coreDisputeID, uint256 _coreRoundID) external view returns (uint256);\\n\\n    /// @dev Returns true if all of the jurors have cast their commits for the last round.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return Whether all of the jurors have cast their commits for the last round.\\n    function areCommitsAllCast(uint256 _coreDisputeID) external view returns (bool);\\n\\n    /// @dev Returns true if all of the jurors have cast their votes for the last round.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @return Whether all of the jurors have cast their votes for the last round.\\n    function areVotesAllCast(uint256 _coreDisputeID) external view returns (bool);\\n\\n    /// @dev Returns true if the specified voter was active in this round.\\n    /// @param _coreDisputeID The ID of the dispute in Kleros Core, not in the Dispute Kit.\\n    /// @param _coreRoundID The ID of the round in Kleros Core, not in the Dispute Kit.\\n    /// @param _voteID The ID of the voter.\\n    /// @return Whether the voter was active or not.\\n    function isVoteActive(uint256 _coreDisputeID, uint256 _coreRoundID, uint256 _voteID) external view returns (bool);\\n\\n    function getRoundInfo(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _choice\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 winningChoice,\\n            bool tied,\\n            uint256 totalVoted,\\n            uint256 totalCommited,\\n            uint256 nbVoters,\\n            uint256 choiceCount\\n        );\\n\\n    function getVoteInfo(\\n        uint256 _coreDisputeID,\\n        uint256 _coreRoundID,\\n        uint256 _voteID\\n    ) external view returns (address account, bytes32 commit, uint256 choice, bool voted);\\n}\\n\",\"keccak256\":\"0xd51cc7a11480d19abbd810733ddd5bf84f998e8b855ef8dd826a4b76a97ddd36\",\"license\":\"MIT\"},\"src/arbitration/interfaces/ISortitionModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\ninterface ISortitionModule {\\n    enum Phase {\\n        staking, // Stake sum trees can be updated. Pass after `minStakingTime` passes and there is at least one dispute without jurors.\\n        generating, // Waiting for a random number. Pass as soon as it is ready.\\n        drawing // Jurors can be drawn. Pass after all disputes have jurors or `maxDrawingTime` passes.\\n    }\\n\\n    enum preStakeHookResult {\\n        ok,\\n        delayed,\\n        failed\\n    }\\n\\n    event NewPhase(Phase _phase);\\n\\n    function createTree(bytes32 _key, bytes memory _extraData) external;\\n\\n    function setStake(address _account, uint96 _courtID, uint256 _value) external;\\n\\n    function setJurorInactive(address _account) external;\\n\\n    function notifyRandomNumber(uint256 _drawnNumber) external;\\n\\n    function draw(bytes32 _court, uint256 _coreDisputeID, uint256 _voteID) external view returns (address);\\n\\n    function preStakeHook(\\n        address _account,\\n        uint96 _courtID,\\n        uint256 _stake,\\n        uint256 _penalty\\n    ) external returns (preStakeHookResult);\\n\\n    function createDisputeHook(uint256 _disputeID, uint256 _roundID) external;\\n\\n    function postDrawHook(uint256 _disputeID, uint256 _roundID) external;\\n}\\n\",\"keccak256\":\"0x28911aa78669746f40c4c3bce723db21600a49a74142c0fe378680b1b356d633\",\"license\":\"MIT\"},\"src/libraries/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a7a94c77463acea95d979aae1580fb0ddc3b6a1e/contracts/token/ERC20/utils/SafeERC20.sol\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title SafeERC20\\n/// @dev Wrappers around ERC20 operations that throw on failure (when the token\\n/// contract returns false). Tokens that return no value (and instead revert or\\n/// throw on failure) are also supported, non-reverting calls are assumed to be\\n/// successful.\\n/// To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n/// which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\nlibrary SafeERC20 {\\n    /// @dev Increases the allowance granted to `spender` by the caller.\\n    /// @param _token Token to transfer.\\n    /// @param _spender The address which will spend the funds.\\n    /// @param _addedValue The amount of tokens to increase the allowance by.\\n    function increaseAllowance(IERC20 _token, address _spender, uint256 _addedValue) internal returns (bool) {\\n        _token.approve(_spender, _token.allowance(address(this), _spender) + _addedValue);\\n        return true;\\n    }\\n\\n    /// @dev Calls transfer() without reverting.\\n    /// @param _token Token to transfer.\\n    /// @param _to Recepient address.\\n    /// @param _value Amount transferred.\\n    /// @return Whether transfer succeeded or not.\\n    function safeTransfer(IERC20 _token, address _to, uint256 _value) internal returns (bool) {\\n        (bool success, bytes memory data) = address(_token).call(abi.encodeCall(IERC20.transfer, (_to, _value)));\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    /// @dev Calls transferFrom() without reverting.\\n    /// @param _token Token to transfer.\\n    /// @param _from Sender address.\\n    /// @param _to Recepient address.\\n    /// @param _value Amount transferred.\\n    /// @return Whether transfer succeeded or not.\\n    function safeTransferFrom(IERC20 _token, address _from, address _to, uint256 _value) internal returns (bool) {\\n        (bool success, bytes memory data) = address(_token).call(\\n            abi.encodeCall(IERC20.transferFrom, (_from, _to, _value))\\n        );\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\",\"keccak256\":\"0x37a19df56a98cd466fb6e70b8c56e13bfc439221bfabd8c5108d36d0e3ffc0e5\",\"license\":\"MIT\"},\"src/rng/RNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\ninterface RNG {\\n    /// @dev Request a random number.\\n    /// @param _block Block linked to the request.\\n    function requestRandomness(uint256 _block) external;\\n\\n    /// @dev Receive the random number.\\n    /// @param _block Block the random number is linked to.\\n    /// @return randomNumber Random Number. If the number is not ready or has not been required 0 instead.\\n    function receiveRandomness(uint256 _block) external returns (uint256 randomNumber);\\n}\\n\",\"keccak256\":\"0x5afe7121f49aebe72218df356bd91b66c2171b9ad15e7945a15a091784291a43\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040526001600b553480156200001657600080fd5b5060405162001ddf38038062001ddf8339810160408190526200003991620000a9565b600080546001600160a01b03199081166001600160a01b039889161790915560018054821696881696909617909555600293909355600391909155426004556007805490931693169290921790556009556200011a565b6001600160a01b0381168114620000a657600080fd5b50565b60008060008060008060c08789031215620000c357600080fd5b8651620000d08162000090565b6020880151909650620000e38162000090565b8095505060408701519350606087015192506080870151620001058162000090565b8092505060a087015190509295509295509295565b611cb5806200012a6000396000f3fe608060405234801561001057600080fd5b506004361061018f5760003560e01c80635d2d7846116100e4578063c057eca711610092578063c057eca7146102ff578063c157261814610308578063ccbac9f514610311578063d09f392d1461031a578063d605787b1461032d578063dd5e5cb514610340578063f2f4eb2614610353578063f6b4d82d1461036657600080fd5b80635d2d7846146102985780637dc38f14146102ab578063823cfd70146102b4578063b1c9fe6e146102c7578063b4a61608146102db578063b5d69e99146102e3578063b888adfa146102f657600080fd5b806335975f4a1161014157806335975f4a1461021057806341334e2e1461022357806345988e2c14610243578063477a655c146102565780634c70a0d6146102695780634dbbebbc1461027c57806356acb0501461028f57600080fd5b806303432744146101945780630b274f2e146101b05780630b51806d146101ba5780630c340a24146101c25780630e083ec9146101ed5780631b92bbbe146101f657806321ea9b3f146101ff575b600080fd5b61019d60065481565b6040519081526020015b60405180910390f35b6101b86103c0565b005b61019d600681565b6000546101d5906001600160a01b031681565b6040516001600160a01b0390911681526020016101a7565b61019d600a5481565b61019d60035481565b6101b861020d3660046116b0565b50565b6101b861021e3660046116b0565b610798565b6102366102313660046116f3565b610937565b6040516101a7919061176d565b6101b8610251366004611780565b610ae5565b6101b8610264366004611808565b610c5e565b6101d56102773660046118a7565b610d55565b6101b861028a3660046118d3565b610f05565b61019d600b5481565b6101b86102a63660046118ff565b610fee565b61019d60095481565b6101b86102c23660046116b0565b611031565b60015461023690600160a01b900460ff1681565b61019d600481565b6101b86102f1366004611921565b611060565b61019d60045481565b61019d60025481565b61019d60055481565b61019d60085481565b6101b86103283660046118ff565b6111af565b6007546101d5906001600160a01b031681565b6101b861034e3660046116b0565b6111e9565b6001546101d5906001600160a01b031681565b6103b06103743660046116b0565b600d602052600090815260409020805460018201546002909201546001600160a01b03821692600160a01b9092046001600160601b0316919084565b6040516101a79493929190611945565b6000600154600160a01b900460ff1660028111156103e0576103e0611739565b03610553576002546004546103f5904261198a565b101561045d5760405162461bcd60e51b815260206004820152602c60248201527f546865206d696e696d756d207374616b696e672074696d6520686173206e6f7460448201526b103830b9b9b2b2103cb2ba1760a11b60648201526084015b60405180910390fd5b6000600654116104bf5760405162461bcd60e51b815260206004820152602760248201527f546865726520617265206e6f2064697370757465732074686174206e65656420604482015266353ab937b9399760c91b6064820152608401610454565b6007546009546001600160a01b0390911690637363ae1f906104e190436119a3565b6040518263ffffffff1660e01b81526004016104ff91815260200190565b600060405180830381600087803b15801561051957600080fd5b505af115801561052d573d6000803e3d6000fd5b505043600555505060018054819060ff60a01b1916600160a01b825b021790555061074d565b60018054600160a01b900460ff16600281111561057257610572611739565b0361066a576007546009546005546001600160a01b03909216916313cf90549161059b916119a3565b6040518263ffffffff1660e01b81526004016105b991815260200190565b6020604051808303816000875af11580156105d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fc91906119b6565b60088190556000036106505760405162461bcd60e51b815260206004820152601e60248201527f52616e646f6d206e756d626572206973206e6f742072656164792079657400006044820152606401610454565b600180546002919060ff60a01b1916600160a01b83610549565b6002600154600160a01b900460ff16600281111561068a5761068a611739565b0361074d5760065415806106ac57506003546004546106a9904261198a565b10155b61073f5760405162461bcd60e51b815260206004820152605860248201527f546865726520617265207374696c6c20646973707574657320776974686f757460448201527f206a75726f727320616e6420746865206d6178696d756d2064726177696e67206064820152773a34b6b2903430b9903737ba103830b9b9b2b2103cb2ba1760411b608482015260a401610454565b6001805460ff60a01b191690555b426004556001546040517f31f72b44f546d9e7eaec13f65636997665e15f134a81c82924f568f5c0d07b939161078e91600160a01b90910460ff169061176d565b60405180910390a1565b6000600154600160a01b900460ff1660028111156107b8576107b8611739565b146108055760405162461bcd60e51b815260206004820152601b60248201527f53686f756c6420626520696e205374616b696e672070686173652e00000000006044820152606401610454565b6000600a54600183600b5461081a91906119a3565b610824919061198a565b1161082f578161084a565b600b54600a5461083f919061198a565b61084a9060016119a3565b9050600081600b5461085c91906119a3565b600b549091505b8181101561092f576000818152600d602052604090819020600180548254918301546002840154945163f56f072560e01b815293946001600160a01b039283169463f56f0725946108cd94811693600160a01b9091046001600160601b0316929091600401611945565b600060405180830381600087803b1580156108e757600080fd5b505af11580156108fb573d6000803e3d6000fd5b5050506000838152600d60205260408120818155600181018290556002015550819050610927816119cf565b915050610863565b50600b555050565b6001546000906001600160a01b031633146109645760405162461bcd60e51b8152600401610454906119e8565b600154604051631a383be960e31b81526001600160a01b0387811660048301526001600160601b0387166024830152600092839291169063d1c1df4890604401606060405180830381865afa1580156109c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e59190611a2c565b92505091508160001480156109fb575060048110155b15610a0b57600292505050610add565b6000600154600160a01b900460ff166002811115610a2b57610a2b611739565b14610ad6576040518060800160405280886001600160a01b03168152602001876001600160601b0316815260200186815260200185815250600d6000600a60008154610a76906119cf565b9182905550815260208082019290925260409081016000208351928401516001600160601b0316600160a01b026001600160a01b039093169290921782558201516001808301919091556060909201516002909101559250610add915050565b6000925050505b949350505050565b6001546001600160a01b03163314610b0f5760405162461bcd60e51b8152600401610454906119e8565b6000610b1b8484611218565b90506000835b81610c5657610b3a6001600160601b0382168585611260565b600160009054906101000a90046001600160a01b03166001600160a01b03166334d5fb316040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb19190611a5a565b6001600160601b0316816001600160601b031603610bd25760019150610b21565b600154604051630fad06e960e11b81526001600160601b03831660048201526001600160a01b0390911690631f5a0dd29060240160e060405180830381865afa158015610c23573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c479190611a87565b50949550610b21945050505050565b505050505050565b6001546001600160a01b03163314610c885760405162461bcd60e51b8152600401610454906119e8565b6000828152600c6020526040812090610ca0836115b4565b825490915015610ce95760405162461bcd60e51b81526020600482015260146024820152732a3932b29030b63932b0b23c9032bc34b9ba399760611b6044820152606401610454565b60018111610d395760405162461bcd60e51b815260206004820152601b60248201527f4b206d7573742062652067726561746572207468616e206f6e652e00000000006044820152606401610454565b8155600201805460018101825560009182526020822001555050565b60006002600154600160a01b900460ff166002811115610d7757610d77611739565b14610db35760405162461bcd60e51b815260206004820152600c60248201526b2bb937b73390383430b9b29760a11b6044820152606401610454565b6000848152600c602052604081206002810180549192918291908290610ddb57610ddb611af3565b90600052602060002001546008548787604051602001610e0e939291909283526020830191909152604082015260600190565b6040516020818303038152906040528051906020012060001c610e319190611b1f565b90505b60028301548354610e46908490611b33565b610e519060016119a3565b1015610ee05760015b83548111610eda57600081848660000154610e759190611b33565b610e7f91906119a3565b90506000856002018281548110610e9857610e98611af3565b90600052602060002001549050808410610ebd57610eb6818561198a565b9350610ec5565b509250610eda565b50508080610ed2906119cf565b915050610e5a565b50610e34565b6000828152600484016020526040902054610efa906115d0565b979650505050505050565b6000546001600160a01b03163314610f2f5760405162461bcd60e51b815260040161045490611b4a565b600780546001600160a01b0319166001600160a01b038416179055600981905560018054600160a01b900460ff166002811115610f6e57610f6e611739565b03610fea576007546009546001600160a01b0390911690637363ae1f90610f9590436119a3565b6040518263ffffffff1660e01b8152600401610fb391815260200190565b600060405180830381600087803b158015610fcd57600080fd5b505af1158015610fe1573d6000803e3d6000fd5b50504360055550505b5050565b6001546001600160a01b031633146110185760405162461bcd60e51b8152600401610454906119e8565b6006805490600061102883611b8c565b91905055505050565b6000546001600160a01b0316331461105b5760405162461bcd60e51b815260040161045490611b4a565b600255565b6001546001600160a01b0316331461108a5760405162461bcd60e51b8152600401610454906119e8565b600154604051632a1fc51b60e11b81526001600160a01b038381166004830152600092169063543f8a3690602401600060405180830381865afa1580156110d5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526110fd9190810190611ba3565b80519091505b80156111aa57600180546001600160a01b03169063f56f0725908590859061112b908661198a565b8151811061113b5761113b611af3565b60200260200101516000806040518563ffffffff1660e01b81526004016111659493929190611945565b600060405180830381600087803b15801561117f57600080fd5b505af1158015611193573d6000803e3d6000fd5b5050505080806111a290611b8c565b915050611103565b505050565b6001546001600160a01b031633146111d95760405162461bcd60e51b8152600401610454906119e8565b60068054906000611028836119cf565b6000546001600160a01b031633146112135760405162461bcd60e51b815260040161045490611b4a565b600355565b600060405160005b601481101561123b578481600c011a81830153600101611220565b5060145b60208110156112575783811a8183015360010161123f565b50519392505050565b6000838152600c6020908152604080832084845260038101909252822054909181900361142d57831561142857600182015460000361137b5750600281018054600180820183556000928352602090922081018590559081148015906112da575081546112ce60018361198a565b6112d89190611b1f565b155b156113765781546000906112ee9083611c55565b600081815260048501602052604081205491925061130d8460016119a3565b90508460020185600201848154811061132857611328611af3565b60009182526020808320909101548354600181018555938352818320909301929092559384526004860180825260408086208690558486526003880183528086208490559285529052909120555b6113f6565b60018083018054909161138d9161198a565b8154811061139d5761139d611af3565b90600052602060002001549050816001018054806113bd576113bd611c69565b60019003818190600052602060002001600090559055838260020182815481106113e9576113e9611af3565b6000918252602090912001555b6000838152600383016020908152604080832084905583835260048501909152902083905561142885826001876115fb565b6115ad565b836000036114cb57600082600201828154811061144c5761144c611af3565b90600052602060002001549050600083600201838154811061147057611470611af3565b60009182526020808320909101929092556001808601805491820181558252828220018490558581526003850182526040808220829055848252600486019092529081208190556114c59087908490846115fb565b506115ad565b8160020181815481106114e0576114e0611af3565b906000526020600020015484146115ad5760008483600201838154811061150957611509611af3565b90600052602060002001541115905060008161154f578584600201848154811061153557611535611af3565b906000526020600020015461154a919061198a565b61157a565b83600201838154811061156457611564611af3565b90600052602060002001548661157a919061198a565b90508584600201848154811061159257611592611af3565b6000918252602090912001556115aa878484846115fb565b50505b5050505050565b600060208251106115c757506020015190565b5060065b919050565b600060405160005b60148110156115f35783811a81600c840101536001016115d8565b505192915050565b6000848152600c60205260409020835b8015610c5657815461161e60018361198a565b6116289190611c55565b90508361165f578282600201828154811061164557611645611af3565b906000526020600020015461165a919061198a565b61168a565b8282600201828154811061167557611675611af3565b906000526020600020015461168a91906119a3565b82600201828154811061169f5761169f611af3565b60009182526020909120015561160b565b6000602082840312156116c257600080fd5b5035919050565b6001600160a01b038116811461020d57600080fd5b6001600160601b038116811461020d57600080fd5b6000806000806080858703121561170957600080fd5b8435611714816116c9565b93506020850135611724816116de565b93969395505050506040820135916060013590565b634e487b7160e01b600052602160045260246000fd5b6003811061020d57634e487b7160e01b600052602160045260246000fd5b6020810161177a8361174f565b91905290565b60008060006060848603121561179557600080fd5b83356117a0816116c9565b925060208401356117b0816116de565b929592945050506040919091013590565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611800576118006117c1565b604052919050565b6000806040838503121561181b57600080fd5b8235915060208084013567ffffffffffffffff8082111561183b57600080fd5b818601915086601f83011261184f57600080fd5b813581811115611861576118616117c1565b611873601f8201601f191685016117d7565b9150808252878482850101111561188957600080fd5b80848401858401376000848284010152508093505050509250929050565b6000806000606084860312156118bc57600080fd5b505081359360208301359350604090920135919050565b600080604083850312156118e657600080fd5b82356118f1816116c9565b946020939093013593505050565b6000806040838503121561191257600080fd5b50508035926020909101359150565b60006020828403121561193357600080fd5b813561193e816116c9565b9392505050565b6001600160a01b039490941684526001600160601b039290921660208401526040830152606082015260800190565b634e487b7160e01b600052601160045260246000fd5b8181038181111561199d5761199d611974565b92915050565b8082018082111561199d5761199d611974565b6000602082840312156119c857600080fd5b5051919050565b6000600182016119e1576119e1611974565b5060010190565b60208082526024908201527f416363657373206e6f7420616c6c6f7765643a204b6c65726f73436f7265206f60408201526337363c9760e11b606082015260800190565b600080600060608486031215611a4157600080fd5b8351925060208401519150604084015190509250925092565b600060208284031215611a6c57600080fd5b815161193e816116de565b805180151581146115cb57600080fd5b600080600080600080600060e0888a031215611aa257600080fd5b8751611aad816116de565b9650611abb60208901611a77565b955060408801519450606088015193506080880151925060a08801519150611ae560c08901611a77565b905092959891949750929550565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600082611b2e57611b2e611b09565b500690565b808202811582820484141761199d5761199d611974565b60208082526022908201527f416363657373206e6f7420616c6c6f7765643a20476f7665726e6f72206f6e6c6040820152613c9760f11b606082015260800190565b600081611b9b57611b9b611974565b506000190190565b60006020808385031215611bb657600080fd5b825167ffffffffffffffff80821115611bce57600080fd5b818501915085601f830112611be257600080fd5b815181811115611bf457611bf46117c1565b8060051b9150611c058483016117d7565b8181529183018401918481019088841115611c1f57600080fd5b938501935b83851015611c495784519250611c39836116de565b8282529385019390850190611c24565b98975050505050505050565b600082611c6457611c64611b09565b500490565b634e487b7160e01b600052603160045260246000fdfea2646970667358221220321564f2b444714b30ad203dc138ead38255b626f347ea1f2a2c9ec60dd0ab6f64736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061018f5760003560e01c80635d2d7846116100e4578063c057eca711610092578063c057eca7146102ff578063c157261814610308578063ccbac9f514610311578063d09f392d1461031a578063d605787b1461032d578063dd5e5cb514610340578063f2f4eb2614610353578063f6b4d82d1461036657600080fd5b80635d2d7846146102985780637dc38f14146102ab578063823cfd70146102b4578063b1c9fe6e146102c7578063b4a61608146102db578063b5d69e99146102e3578063b888adfa146102f657600080fd5b806335975f4a1161014157806335975f4a1461021057806341334e2e1461022357806345988e2c14610243578063477a655c146102565780634c70a0d6146102695780634dbbebbc1461027c57806356acb0501461028f57600080fd5b806303432744146101945780630b274f2e146101b05780630b51806d146101ba5780630c340a24146101c25780630e083ec9146101ed5780631b92bbbe146101f657806321ea9b3f146101ff575b600080fd5b61019d60065481565b6040519081526020015b60405180910390f35b6101b86103c0565b005b61019d600681565b6000546101d5906001600160a01b031681565b6040516001600160a01b0390911681526020016101a7565b61019d600a5481565b61019d60035481565b6101b861020d3660046116b0565b50565b6101b861021e3660046116b0565b610798565b6102366102313660046116f3565b610937565b6040516101a7919061176d565b6101b8610251366004611780565b610ae5565b6101b8610264366004611808565b610c5e565b6101d56102773660046118a7565b610d55565b6101b861028a3660046118d3565b610f05565b61019d600b5481565b6101b86102a63660046118ff565b610fee565b61019d60095481565b6101b86102c23660046116b0565b611031565b60015461023690600160a01b900460ff1681565b61019d600481565b6101b86102f1366004611921565b611060565b61019d60045481565b61019d60025481565b61019d60055481565b61019d60085481565b6101b86103283660046118ff565b6111af565b6007546101d5906001600160a01b031681565b6101b861034e3660046116b0565b6111e9565b6001546101d5906001600160a01b031681565b6103b06103743660046116b0565b600d602052600090815260409020805460018201546002909201546001600160a01b03821692600160a01b9092046001600160601b0316919084565b6040516101a79493929190611945565b6000600154600160a01b900460ff1660028111156103e0576103e0611739565b03610553576002546004546103f5904261198a565b101561045d5760405162461bcd60e51b815260206004820152602c60248201527f546865206d696e696d756d207374616b696e672074696d6520686173206e6f7460448201526b103830b9b9b2b2103cb2ba1760a11b60648201526084015b60405180910390fd5b6000600654116104bf5760405162461bcd60e51b815260206004820152602760248201527f546865726520617265206e6f2064697370757465732074686174206e65656420604482015266353ab937b9399760c91b6064820152608401610454565b6007546009546001600160a01b0390911690637363ae1f906104e190436119a3565b6040518263ffffffff1660e01b81526004016104ff91815260200190565b600060405180830381600087803b15801561051957600080fd5b505af115801561052d573d6000803e3d6000fd5b505043600555505060018054819060ff60a01b1916600160a01b825b021790555061074d565b60018054600160a01b900460ff16600281111561057257610572611739565b0361066a576007546009546005546001600160a01b03909216916313cf90549161059b916119a3565b6040518263ffffffff1660e01b81526004016105b991815260200190565b6020604051808303816000875af11580156105d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fc91906119b6565b60088190556000036106505760405162461bcd60e51b815260206004820152601e60248201527f52616e646f6d206e756d626572206973206e6f742072656164792079657400006044820152606401610454565b600180546002919060ff60a01b1916600160a01b83610549565b6002600154600160a01b900460ff16600281111561068a5761068a611739565b0361074d5760065415806106ac57506003546004546106a9904261198a565b10155b61073f5760405162461bcd60e51b815260206004820152605860248201527f546865726520617265207374696c6c20646973707574657320776974686f757460448201527f206a75726f727320616e6420746865206d6178696d756d2064726177696e67206064820152773a34b6b2903430b9903737ba103830b9b9b2b2103cb2ba1760411b608482015260a401610454565b6001805460ff60a01b191690555b426004556001546040517f31f72b44f546d9e7eaec13f65636997665e15f134a81c82924f568f5c0d07b939161078e91600160a01b90910460ff169061176d565b60405180910390a1565b6000600154600160a01b900460ff1660028111156107b8576107b8611739565b146108055760405162461bcd60e51b815260206004820152601b60248201527f53686f756c6420626520696e205374616b696e672070686173652e00000000006044820152606401610454565b6000600a54600183600b5461081a91906119a3565b610824919061198a565b1161082f578161084a565b600b54600a5461083f919061198a565b61084a9060016119a3565b9050600081600b5461085c91906119a3565b600b549091505b8181101561092f576000818152600d602052604090819020600180548254918301546002840154945163f56f072560e01b815293946001600160a01b039283169463f56f0725946108cd94811693600160a01b9091046001600160601b0316929091600401611945565b600060405180830381600087803b1580156108e757600080fd5b505af11580156108fb573d6000803e3d6000fd5b5050506000838152600d60205260408120818155600181018290556002015550819050610927816119cf565b915050610863565b50600b555050565b6001546000906001600160a01b031633146109645760405162461bcd60e51b8152600401610454906119e8565b600154604051631a383be960e31b81526001600160a01b0387811660048301526001600160601b0387166024830152600092839291169063d1c1df4890604401606060405180830381865afa1580156109c1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109e59190611a2c565b92505091508160001480156109fb575060048110155b15610a0b57600292505050610add565b6000600154600160a01b900460ff166002811115610a2b57610a2b611739565b14610ad6576040518060800160405280886001600160a01b03168152602001876001600160601b0316815260200186815260200185815250600d6000600a60008154610a76906119cf565b9182905550815260208082019290925260409081016000208351928401516001600160601b0316600160a01b026001600160a01b039093169290921782558201516001808301919091556060909201516002909101559250610add915050565b6000925050505b949350505050565b6001546001600160a01b03163314610b0f5760405162461bcd60e51b8152600401610454906119e8565b6000610b1b8484611218565b90506000835b81610c5657610b3a6001600160601b0382168585611260565b600160009054906101000a90046001600160a01b03166001600160a01b03166334d5fb316040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bb19190611a5a565b6001600160601b0316816001600160601b031603610bd25760019150610b21565b600154604051630fad06e960e11b81526001600160601b03831660048201526001600160a01b0390911690631f5a0dd29060240160e060405180830381865afa158015610c23573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c479190611a87565b50949550610b21945050505050565b505050505050565b6001546001600160a01b03163314610c885760405162461bcd60e51b8152600401610454906119e8565b6000828152600c6020526040812090610ca0836115b4565b825490915015610ce95760405162461bcd60e51b81526020600482015260146024820152732a3932b29030b63932b0b23c9032bc34b9ba399760611b6044820152606401610454565b60018111610d395760405162461bcd60e51b815260206004820152601b60248201527f4b206d7573742062652067726561746572207468616e206f6e652e00000000006044820152606401610454565b8155600201805460018101825560009182526020822001555050565b60006002600154600160a01b900460ff166002811115610d7757610d77611739565b14610db35760405162461bcd60e51b815260206004820152600c60248201526b2bb937b73390383430b9b29760a11b6044820152606401610454565b6000848152600c602052604081206002810180549192918291908290610ddb57610ddb611af3565b90600052602060002001546008548787604051602001610e0e939291909283526020830191909152604082015260600190565b6040516020818303038152906040528051906020012060001c610e319190611b1f565b90505b60028301548354610e46908490611b33565b610e519060016119a3565b1015610ee05760015b83548111610eda57600081848660000154610e759190611b33565b610e7f91906119a3565b90506000856002018281548110610e9857610e98611af3565b90600052602060002001549050808410610ebd57610eb6818561198a565b9350610ec5565b509250610eda565b50508080610ed2906119cf565b915050610e5a565b50610e34565b6000828152600484016020526040902054610efa906115d0565b979650505050505050565b6000546001600160a01b03163314610f2f5760405162461bcd60e51b815260040161045490611b4a565b600780546001600160a01b0319166001600160a01b038416179055600981905560018054600160a01b900460ff166002811115610f6e57610f6e611739565b03610fea576007546009546001600160a01b0390911690637363ae1f90610f9590436119a3565b6040518263ffffffff1660e01b8152600401610fb391815260200190565b600060405180830381600087803b158015610fcd57600080fd5b505af1158015610fe1573d6000803e3d6000fd5b50504360055550505b5050565b6001546001600160a01b031633146110185760405162461bcd60e51b8152600401610454906119e8565b6006805490600061102883611b8c565b91905055505050565b6000546001600160a01b0316331461105b5760405162461bcd60e51b815260040161045490611b4a565b600255565b6001546001600160a01b0316331461108a5760405162461bcd60e51b8152600401610454906119e8565b600154604051632a1fc51b60e11b81526001600160a01b038381166004830152600092169063543f8a3690602401600060405180830381865afa1580156110d5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526110fd9190810190611ba3565b80519091505b80156111aa57600180546001600160a01b03169063f56f0725908590859061112b908661198a565b8151811061113b5761113b611af3565b60200260200101516000806040518563ffffffff1660e01b81526004016111659493929190611945565b600060405180830381600087803b15801561117f57600080fd5b505af1158015611193573d6000803e3d6000fd5b5050505080806111a290611b8c565b915050611103565b505050565b6001546001600160a01b031633146111d95760405162461bcd60e51b8152600401610454906119e8565b60068054906000611028836119cf565b6000546001600160a01b031633146112135760405162461bcd60e51b815260040161045490611b4a565b600355565b600060405160005b601481101561123b578481600c011a81830153600101611220565b5060145b60208110156112575783811a8183015360010161123f565b50519392505050565b6000838152600c6020908152604080832084845260038101909252822054909181900361142d57831561142857600182015460000361137b5750600281018054600180820183556000928352602090922081018590559081148015906112da575081546112ce60018361198a565b6112d89190611b1f565b155b156113765781546000906112ee9083611c55565b600081815260048501602052604081205491925061130d8460016119a3565b90508460020185600201848154811061132857611328611af3565b60009182526020808320909101548354600181018555938352818320909301929092559384526004860180825260408086208690558486526003880183528086208490559285529052909120555b6113f6565b60018083018054909161138d9161198a565b8154811061139d5761139d611af3565b90600052602060002001549050816001018054806113bd576113bd611c69565b60019003818190600052602060002001600090559055838260020182815481106113e9576113e9611af3565b6000918252602090912001555b6000838152600383016020908152604080832084905583835260048501909152902083905561142885826001876115fb565b6115ad565b836000036114cb57600082600201828154811061144c5761144c611af3565b90600052602060002001549050600083600201838154811061147057611470611af3565b60009182526020808320909101929092556001808601805491820181558252828220018490558581526003850182526040808220829055848252600486019092529081208190556114c59087908490846115fb565b506115ad565b8160020181815481106114e0576114e0611af3565b906000526020600020015484146115ad5760008483600201838154811061150957611509611af3565b90600052602060002001541115905060008161154f578584600201848154811061153557611535611af3565b906000526020600020015461154a919061198a565b61157a565b83600201838154811061156457611564611af3565b90600052602060002001548661157a919061198a565b90508584600201848154811061159257611592611af3565b6000918252602090912001556115aa878484846115fb565b50505b5050505050565b600060208251106115c757506020015190565b5060065b919050565b600060405160005b60148110156115f35783811a81600c840101536001016115d8565b505192915050565b6000848152600c60205260409020835b8015610c5657815461161e60018361198a565b6116289190611c55565b90508361165f578282600201828154811061164557611645611af3565b906000526020600020015461165a919061198a565b61168a565b8282600201828154811061167557611675611af3565b906000526020600020015461168a91906119a3565b82600201828154811061169f5761169f611af3565b60009182526020909120015561160b565b6000602082840312156116c257600080fd5b5035919050565b6001600160a01b038116811461020d57600080fd5b6001600160601b038116811461020d57600080fd5b6000806000806080858703121561170957600080fd5b8435611714816116c9565b93506020850135611724816116de565b93969395505050506040820135916060013590565b634e487b7160e01b600052602160045260246000fd5b6003811061020d57634e487b7160e01b600052602160045260246000fd5b6020810161177a8361174f565b91905290565b60008060006060848603121561179557600080fd5b83356117a0816116c9565b925060208401356117b0816116de565b929592945050506040919091013590565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611800576118006117c1565b604052919050565b6000806040838503121561181b57600080fd5b8235915060208084013567ffffffffffffffff8082111561183b57600080fd5b818601915086601f83011261184f57600080fd5b813581811115611861576118616117c1565b611873601f8201601f191685016117d7565b9150808252878482850101111561188957600080fd5b80848401858401376000848284010152508093505050509250929050565b6000806000606084860312156118bc57600080fd5b505081359360208301359350604090920135919050565b600080604083850312156118e657600080fd5b82356118f1816116c9565b946020939093013593505050565b6000806040838503121561191257600080fd5b50508035926020909101359150565b60006020828403121561193357600080fd5b813561193e816116c9565b9392505050565b6001600160a01b039490941684526001600160601b039290921660208401526040830152606082015260800190565b634e487b7160e01b600052601160045260246000fd5b8181038181111561199d5761199d611974565b92915050565b8082018082111561199d5761199d611974565b6000602082840312156119c857600080fd5b5051919050565b6000600182016119e1576119e1611974565b5060010190565b60208082526024908201527f416363657373206e6f7420616c6c6f7765643a204b6c65726f73436f7265206f60408201526337363c9760e11b606082015260800190565b600080600060608486031215611a4157600080fd5b8351925060208401519150604084015190509250925092565b600060208284031215611a6c57600080fd5b815161193e816116de565b805180151581146115cb57600080fd5b600080600080600080600060e0888a031215611aa257600080fd5b8751611aad816116de565b9650611abb60208901611a77565b955060408801519450606088015193506080880151925060a08801519150611ae560c08901611a77565b905092959891949750929550565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601260045260246000fd5b600082611b2e57611b2e611b09565b500690565b808202811582820484141761199d5761199d611974565b60208082526022908201527f416363657373206e6f7420616c6c6f7765643a20476f7665726e6f72206f6e6c6040820152613c9760f11b606082015260800190565b600081611b9b57611b9b611974565b506000190190565b60006020808385031215611bb657600080fd5b825167ffffffffffffffff80821115611bce57600080fd5b818501915085601f830112611be257600080fd5b815181811115611bf457611bf46117c1565b8060051b9150611c058483016117d7565b8181529183018401918481019088841115611c1f57600080fd5b938501935b83851015611c495784519250611c39836116de565b8282529385019390850190611c24565b98975050505050505050565b600082611c6457611c64611b09565b500490565b634e487b7160e01b600052603160045260246000fdfea2646970667358221220321564f2b444714b30ad203dc138ead38255b626f347ea1f2a2c9ec60dd0ab6f64736f6c63430008120033",
  "devdoc": {
    "details": "A factory of trees that keeps track of staked values for sortition.",
    "kind": "dev",
    "methods": {
      "changeMaxDrawingTime(uint256)": {
        "details": "Changes the `maxDrawingTime` storage variable.",
        "params": {
          "_maxDrawingTime": "The new value for the `maxDrawingTime` storage variable."
        }
      },
      "changeMinStakingTime(uint256)": {
        "details": "Changes the `minStakingTime` storage variable.",
        "params": {
          "_minStakingTime": "The new value for the `minStakingTime` storage variable."
        }
      },
      "changeRandomNumberGenerator(address,uint256)": {
        "details": "Changes the `_rng` and `_rngLookahead` storage variables.",
        "params": {
          "_rng": "The new value for the `RNGenerator` storage variable.",
          "_rngLookahead": "The new value for the `rngLookahead` storage variable."
        }
      },
      "constructor": {
        "details": "Constructor.",
        "params": {
          "_core": "The KlerosCore.",
          "_maxDrawingTime": "Time after which the drawing phase can be switched",
          "_minStakingTime": "Minimal time to stake",
          "_rng": "The random number generator.",
          "_rngLookahead": "Lookahead value for rng."
        }
      },
      "createTree(bytes32,bytes)": {
        "details": "Create a sortition sum tree at the specified key.",
        "params": {
          "_extraData": "Extra data that contains the number of children each node in the tree should have.",
          "_key": "The key of the new tree."
        }
      },
      "draw(bytes32,uint256,uint256)": {
        "details": "Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.",
        "params": {
          "_coreDisputeID": "Index of the dispute in Kleros Core.",
          "_key": "The key of the tree.",
          "_voteID": "ID of the voter."
        },
        "returns": {
          "drawnAddress": "The drawn address. `O(k * log_k(n))` where `k` is the maximum number of children per node in the tree,  and `n` is the maximum number of nodes ever appended."
        }
      },
      "executeDelayedStakes(uint256)": {
        "details": "Executes the next delayed stakes.",
        "params": {
          "_iterations": "The number of delayed stakes to execute."
        }
      },
      "notifyRandomNumber(uint256)": {
        "details": "Saves the random number to use it in sortition. Not used by this contract because the storing of the number is inlined in passPhase().",
        "params": {
          "_randomNumber": "Random number returned by RNG contract."
        }
      },
      "setJurorInactive(address)": {
        "details": "Unstakes the inactive juror from all courts. `O(n * (p * log_k(j)) )` where `n` is the number of courts the juror has staked in, `p` is the depth of the court tree, `k` is the minimum number of children per node of one of these courts' sortition sum tree, and `j` is the maximum number of jurors that ever staked in one of these courts simultaneously.",
        "params": {
          "_account": "The juror to unstake."
        }
      },
      "setStake(address,uint96,uint256)": {
        "details": "Sets the value for a particular court and its parent courts.",
        "params": {
          "_account": "Address of the juror. `O(log_k(n))` where `k` is the maximum number of children per node in the tree,  and `n` is the maximum number of nodes ever appended.",
          "_courtID": "ID of the court.",
          "_value": "The new value."
        }
      }
    },
    "title": "SortitionModule",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8096,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "governor",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 8099,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "core",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(KlerosCore)6601"
      },
      {
        "astId": 8102,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "phase",
        "offset": 20,
        "slot": "1",
        "type": "t_enum(Phase)15309"
      },
      {
        "astId": 8104,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "minStakingTime",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 8106,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "maxDrawingTime",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 8108,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "lastPhaseChange",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 8110,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "randomNumberRequestBlock",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 8112,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "disputesWithoutJurors",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 8115,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "rng",
        "offset": 0,
        "slot": "7",
        "type": "t_contract(RNG)21373"
      },
      {
        "astId": 8117,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "randomNumber",
        "offset": 0,
        "slot": "8",
        "type": "t_uint256"
      },
      {
        "astId": 8119,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "rngLookahead",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 8121,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "delayedStakeWriteIndex",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      },
      {
        "astId": 8124,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "delayedStakeReadIndex",
        "offset": 0,
        "slot": "11",
        "type": "t_uint256"
      },
      {
        "astId": 8129,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "sortitionSumTrees",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_bytes32,t_struct(SortitionSumTree)8079_storage)"
      },
      {
        "astId": 8134,
        "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
        "label": "delayedStakes",
        "offset": 0,
        "slot": "13",
        "type": "t_mapping(t_uint256,t_struct(DelayedStake)8088_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(KlerosCore)6601": {
        "encoding": "inplace",
        "label": "contract KlerosCore",
        "numberOfBytes": "20"
      },
      "t_contract(RNG)21373": {
        "encoding": "inplace",
        "label": "contract RNG",
        "numberOfBytes": "20"
      },
      "t_enum(Phase)15309": {
        "encoding": "inplace",
        "label": "enum ISortitionModule.Phase",
        "numberOfBytes": "1"
      },
      "t_mapping(t_bytes32,t_struct(SortitionSumTree)8079_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct SortitionModule.SortitionSumTree)",
        "numberOfBytes": "32",
        "value": "t_struct(SortitionSumTree)8079_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint256,t_struct(DelayedStake)8088_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct SortitionModule.DelayedStake)",
        "numberOfBytes": "32",
        "value": "t_struct(DelayedStake)8088_storage"
      },
      "t_struct(DelayedStake)8088_storage": {
        "encoding": "inplace",
        "label": "struct SortitionModule.DelayedStake",
        "members": [
          {
            "astId": 8081,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "account",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 8083,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "courtID",
            "offset": 20,
            "slot": "0",
            "type": "t_uint96"
          },
          {
            "astId": 8085,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "stake",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 8087,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "penalty",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(SortitionSumTree)8079_storage": {
        "encoding": "inplace",
        "label": "struct SortitionModule.SortitionSumTree",
        "members": [
          {
            "astId": 8064,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "K",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 8067,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "stack",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 8070,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "nodes",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 8074,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "IDsToNodeIndexes",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 8078,
            "contract": "src/arbitration/SortitionModule.sol:SortitionModule",
            "label": "nodeIndexesToIDs",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_uint256,t_bytes32)"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint96": {
        "encoding": "inplace",
        "label": "uint96",
        "numberOfBytes": "12"
      }
    }
  }
}
